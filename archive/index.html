<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Social Tennis Match Maker</title>
<script src="xlsx.full.min.js"></script>
<script src="Member Master List.js"></script>  
<style>
    body { font-family: Arial, sans-serif; padding: 20px; background: #f4f4f4; }

/* Logo Section Styles */
.logo-section {
  text-align: center;
  margin-bottom: 20px;
  padding: 15px;
  background: white;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}
/* Step Header Styles */
.step-header {
  background: linear-gradient(135deg, #1e40af 0%, #3b82f6 100%);
  color: white;
  font-size: 24px;
  font-weight: bold;
  padding: 20px 30px;
  margin: -15px -15px 20px -15px;
  border-radius: 8px 8px 0 0;
  text-align: left;
  box-shadow: 0 2px 8px rgba(30, 64, 175, 0.3);
}
.logo {
  max-height: 80px;
  max-width: 100%;
  height: auto;
  border-radius: 8px;
  transition: all 0.3s ease;
}
.logo:hover {
  transform: scale(1.02);
  box-shadow: 0 4px 12px rgba(0,0,0,0.15);
}

h1 { text-align: center; color: #333; }

/* Check-in Server Status Styles */
.checkin-status {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  padding: 8px 16px;
  border-radius: 20px;
  font-size: 14px;
  font-weight: 500;
  margin-left: 10px;
}

.checkin-status.connected {
  background: #e8f5e9;
  color: #2e7d32;
}

.checkin-status.disconnected {
  background: #ffebee;
  color: #c62828;
}

.checkin-status .dot {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background: currentColor;
}

.checkin-status.connected .dot {
  animation: pulse 2s infinite;
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}
    .section { background: white; margin: 15px 0; padding: 15px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    .error { color: red; font-weight: bold; }
    .success { color: green; font-weight: bold; }
    .warning { color: orange; font-weight: bold; }
    button { padding: 10px 20px; margin: 10px 5px; border: none; border-radius: 5px; cursor: pointer; }
    .primary { background: #007acc; color: white; }
    .secondary { background: #6c757d; color: white; }
    .danger { background: #dc3545; color: white; }
    
    /* Court Selection Styles */
    .court-pool {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
      gap: 8px;
      margin: 15px 0;
      padding: 15px;
      border: 2px dashed #ddd;
      border-radius: 8px;
      background: #fafafa;
      min-height: 120px;
    }
    .court-item {
      background: #007acc;
      color: white;
      padding: 10px;
      text-align: center;
      border-radius: 5px;
      cursor: move;
      user-select: none;
      font-weight: bold;
      transition: all 0.2s;
    }

/* Court type specific colors */
.court-item.grass-court {
  background: #28a745 !important; /* Green for grass courts */
}

.court-item.grass-court:hover {
  background: #1e7e34 !important; /* Darker green on hover */
}

.court-item.hard-court {
  background: #007acc !important; /* Blue for hard courts */
}

.court-item.hard-court:hover {
  background: #005a99 !important; /* Darker blue on hover */
}

/* Also apply to available courts area */
.available-courts .court-item.grass-court {
  background: #28a745 !important;
}

.available-courts .court-item.grass-court:hover {
  background: #1e7e34 !important;
}

.available-courts .court-item.hard-court {
  background: #007acc !important;
}

.available-courts .court-item.hard-court:hover {
  background: #005a99 !important;
}

.court-item:hover { background: #005a99; transform: scale(1.05); }

    .court-item:hover { background: #005a99; transform: scale(1.05); }
    .court-item.dragging { opacity: 0.5; }
    
    .available-courts {
      min-height: 80px;
      padding: 15px;
      border: 2px dashed #28a745;
      border-radius: 8px;
      background: #f8fff8;
      margin: 15px 0;
    }
    .available-courts.drag-over { border-color: #007acc; background: #e3f2fd; }
    .available-courts .court-item { 
      background: #28a745; 
      margin: 5px;
      display: inline-block;
    }
    .available-courts .court-item:hover { background: #1e7e34; }
    
    /* Player Table Styles */
    .player-table {
      width: 100%;
      border-collapse: collapse;
      margin: 15px 0;
    }
.player-table th, .player-table td {
  border: 1px solid #ddd;
  padding: 2px 8px;
  text-align: center;
  font-size: 16px;
}
    .player-table th {
  background: #f8f9fa;
  font-weight: bold;
  border-right: 3px solid #ccc;
}
    .player-table thead th {
      position: sticky;
      top: 0;
      z-index: 10;
      box-shadow: 0 2px 2px -1px rgba(0, 0, 0, 0.4);
      padding: 24px 8px;
      font-size: 18px;
      background: #e0e0e0;
    }
    .player-table tr:nth-child(even) {
      background: #f9f9f9;
    }
    .player-table tr:hover {
      background: #e8f4fd;
    }
    
    .name-input {
  width: 70%;
  padding: 5px;
  border: 1px solid #ddd;
  border-radius: 3px;
  font-size: 16px;
}
   .name-input:focus {
      border-color: #007acc;
      outline: 3px solid #007acc !important;
      outline-offset: 2px;
      background-color: #fffbf0 !important;
    }
    
    .autocomplete-suggestions {
      position: absolute;
      background: white;
      border: 1px solid #ddd;
      border-top: none;
      max-height: 200px;
      overflow-y: auto;
      z-index: 1000;
      width: 100%;
    }
   .autocomplete-suggestion {
  display: block;           /* ensure full-row click */
  box-sizing: border-box;   /* padding doesn't overflow */
  width: 100%;              /* fill the menu width */
  min-height: 34px;         /* comfortable target size */
  line-height: 1.3;         /* better text/row spacing */
  padding: 10px 12px;       /* slightly larger hit box */
  cursor: pointer;
  border-bottom: 1px solid #eee;
  font-size: 16px;
  user-select: none;        /* avoid accidental selections */
}

    .autocomplete-suggestion:hover {
      background: #e8f4fd;
    }
    .autocomplete-suggestion.selected {
      background: #007acc;
      color: white;
    }
    
    .checkbox-cell {
      text-align: center;
      width: 60px;
    }
   .status-checkbox {
      width: 18px;
      height: 18px;
      cursor: pointer;
    }
    .status-checkbox.readonly {
      pointer-events: none;
      cursor: default;
    }
.grade-select, .gender-select {
      width: 100%;
      padding: 4px;
      border: 1px solid #ddd;
      border-radius: 3px;
      font-size: 14px;
      background: white;
    }
    .grade-select:focus, .gender-select:focus {
      border-color: #007acc;
      outline: 3px solid #007acc !important;
      outline-offset: 2px;
      background-color: #fffbf0 !important;
    }

    /* Format and Set Number Button Styles */
    .format-buttons, .set-buttons {
      display: flex;
      gap: 8px;
      margin: 15px 0;
    }
    
    .format-btn, .set-btn {
      flex: 1;
      padding: 12px 20px;
      border: 2px solid #ddd;
      background: white;
      border-radius: 8px;
      cursor: pointer;
      text-align: center;
      font-size: 16px;
      font-weight: 500;
      transition: all 0.3s ease;
      color: #666;
    }
    
    .format-btn:hover, .set-btn:hover {
      border-color: #007acc;
      background: #f8f9fa;
    }
    
    .format-btn.active {
      background: #007acc;
      border-color: #005a99;
      color: white;
      font-weight: bold;
    }
    
    .set-btn.active {
      background: #007acc;
      border-color: #005a99;
      color: white;
      font-weight: bold;
    }
    
    .format-section, .set-section {
      margin-bottom: 20px;
    }
    
    .format-label, .set-label {
      display: flex;
      align-items: center;
      font-weight: bold;
      margin-bottom: 10px;
      font-size: 16px;
      color: #666;
  
    }
    
    /* Sets Selection Modal Styles */
    .sets-modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.6);
      z-index: 9999;
      align-items: center;
      justify-content: center;
    }
    
    .sets-modal-overlay.active {
      display: flex;
    }
    
   .sets-modal {
  background: white;
  border-radius: 12px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
  width: 90%;
  max-width: 900px;
  max-height: 80vh;
  overflow: auto;
}
    
    .sets-modal-header {
      background: linear-gradient(135deg, #1e40af 0%, #3b82f6 100%);
      color: white;
      padding: 20px;
      border-radius: 12px 12px 0 0;
      font-size: 20px;
      font-weight: bold;
    }
    
    .sets-modal-body {
      padding: 30px;
    }
    
    .sets-modal-instructions {
      margin-bottom: 20px;
      color: #666;
      font-size: 14px;
      line-height: 1.5;
    }
    
.sets-checkbox-grid {
  display: grid;
  grid-template-columns: repeat(6, 1fr);
  gap: 12px;
  margin-bottom: 25px;
}

.set-checkbox-item {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 20px 10px;
  border: 2px solid #ddd;
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.2s;
  background: white;
}

.set-checkbox-item:hover {
  border-color: #007acc;
  background: #f8f9fa;
}

.set-checkbox-item.checked {
  border-color: #dc3545;
  background: #fff5f5;
}

.set-checkbox-item input[type="checkbox"] {
  appearance: none;
  -webkit-appearance: none;
  width: 40px;
  height: 40px;
  border: 3px solid #ddd;
  border-radius: 6px;
  cursor: pointer;
  position: relative;
  background: white;
  transition: all 0.2s;
}

.set-checkbox-item input[type="checkbox"]:checked {
  border-color: #dc3545;
  background: #dc3545;
}

.set-checkbox-item input[type="checkbox"]:checked::after {
  content: '√ó';
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: white;
  font-size: 32px;
  font-weight: bold;
  line-height: 1;
}

.set-checkbox-item label {
  font-size: 16px;
  font-weight: 500;
  cursor: pointer;
  margin-top: 10px;
}
    
    .sets-modal-footer {
      padding: 20px 30px;
      border-top: 1px solid #eee;
      display: flex;
      gap: 10px;
      justify-content: flex-end;
    }
    
    .sets-modal-btn {
      padding: 12px 24px;
      border: none;
      border-radius: 6px;
      font-size: 16px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .sets-modal-btn.primary {
      background: #007acc;
      color: white;
    }
    
    .sets-modal-btn.primary:hover {
      background: #005a99;
    }
    
    .sets-modal-btn.secondary {
      background: #6c757d;
      color: white;
    }
    
    .sets-modal-btn.secondary:hover {
      background: #545b62;
    }
    
    .sets-button {
      padding: 8px 16px;
      background: white;
      border: 2px solid #ddd;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      color: #333;
      transition: all 0.2s;
      width: 100%;
      text-align: center;
    }
    
    .sets-button:hover {
      border-color: #007acc;
      background: #f8f9fa;
    }
    
    .sets-button.has-selections {
      border-color: #dc3545;
      background: #fff5f5;
      color: #dc3545;
    }
       
    .sit-off-calculator {
      background: #fff3cd;
      border: 1px solid #ffc107;
      padding: 15px;
      border-radius: 5px;
      margin: 15px 0;
      text-align: center;
      font-size: 18px;
      font-weight: bold;
    }
    .sit-off-good { background: #d4edda; border-color: #28a745; color: #155724; }
    .sit-off-bad { background: #f8d7da; border-color: #dc3545; color: #721c24; }
    
    /* Manual Match Setup Styles */
    .manual-match-setup {
      border: 2px solid #ffc107;
      background: #fff8dc;
      border-radius: 8px;
      padding: 15px;
      margin: 15px 0;
    }
    .manual-match-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }
    .manual-match-title {
      font-size: 18px;
      font-weight: bold;
      color: #856404;
    }
    .manual-matches-list {
      margin: 15px 0;
    }
    .manual-match-item {
      background: white;
      border: 1px solid #ffc107;
      border-radius: 5px;
      padding: 12px;
      margin: 8px 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .manual-match-details {
      flex: 1;
    }
    .manual-match-court {
      font-weight: bold;
      color: #007acc;
      margin-bottom: 5px;
    }
    .manual-match-teams {
      font-size: 14px;
      color: #333;
    }
    
    /* Player Selection for Manual Matches */
    .manual-player-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 10px;
      margin: 15px 0;
    }
    .manual-player-item {
      background: white;
      border: 1px solid #ddd;
      border-radius: 5px;
      padding: 8px;
      cursor: pointer;
      transition: all 0.2s;
      user-select: none;
    }
    .manual-player-item:hover {
      border-color: #007acc;
      background: #f8f9fa;
    }
    .manual-player-item.selected {
      background: #007acc;
      color: white;
      border-color: #0056b3;
    }
    .manual-player-item.excluded {
      background: #f8f9f9;
      color: #6c757d;
      border-color: #dee2e6;
      cursor: not-allowed;
    }
    
    /* Team Formation Area */
    .team-formation {
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      gap: 20px;
      margin: 20px 0;
      align-items: center;
    }
    .team-slot {
      border: 2px dashed #ddd;
      border-radius: 8px;
      padding: 15px;
      min-height: 100px;
      background: #fafafa;
    }
    .team-slot.has-players {
      border-color: #007acc;
      background: #e3f2fd;
    }
    .team-slot-title {
      font-weight: bold;
      margin-bottom: 10px;
      text-align: center;
    }
    .team-player {
      background: white;
      border: 1px solid #007acc;
      border-radius: 4px;
      padding: 5px 8px;
      margin: 3px 0;
      font-size: 14px;
    }
    .vs-divider {
      font-size: 24px;
      font-weight: bold;
      text-align: center;
      color: #666;
    }
    
    /* Court Selection for Manual Matches */
    .court-selector {
      margin: 15px 0;
    }
    .court-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
      gap: 8px;
      margin: 10px 0;
    }
    .court-option {
      background: white;
      border: 2px solid #ddd;
      border-radius: 5px;
      padding: 10px;
      text-align: center;
      cursor: pointer;
      transition: all 0.2s;
    }
    .court-option:hover {
      border-color: #007acc;
    }
    .court-option.selected {
      background: #007acc;
      color: white;
      border-color: #0056b3;
    }
    .court-option.excluded {
      background: #f8f9f9;
      color: #6c757d;
      border-color: #dee2e6;
      cursor: not-allowed;
    }
    
    /* Match Display Styles */
    .match-container {
      background: #f9f9f9; border: 1px solid #ddd; padding: 15px; margin: 8px 0;
      border-radius: 6px; border-left: 4px solid #007acc;
    }
  .match-container.manual-match {
  border-left: 4px solid #666666;
  background: #e6e6e6;
}
    .court-box {
      display: inline-block; background: #007acc; color: white; padding: 8px 12px;
      border-radius: 5px; margin-bottom: 10px; font-weight: bold; cursor: move;
      user-select: none;
    }
    .court-box.manual {
      background: #ffc107;
      color: #856404;
    }
    .court-box:hover { background: #005a99; }
    .court-box.manual:hover { background: #e0a800; }
    .court-box.dragging { opacity: 0.5; }
    .court-box.drag-over { background: #28a745; }
    
    .teams-row { display: flex; gap: 20px; align-items: flex-start; }
    .team-column { flex: 1; min-height: 80px; }
    .team-header {
      font-weight: bold; margin-bottom: 8px; text-align: center;
      padding: 5px; background: #e9e9e9; border-radius: 3px;
    }
    .player-box {
      background: white; border: 2px solid #ddd; padding: 8px; margin: 4px 0;
      border-radius: 5px; cursor: move; user-select: none; text-align: center;
      transition: all 0.2s ease;
    }
.player-box.grade-gap { 
  background: repeating-linear-gradient(
    45deg,
    white 0px,
    white 6px,
    #ff8c42 6px,
    #ff8c42 7px
  ) !important;
  border: 2px solid #ff8c42 !important; 
  font-weight: bold; 
}
    .player-box:hover { border-color: #007acc; box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
    .player-box.dragging { opacity: 0.5; transform: rotate(2deg); }
    .player-box.nhc { background-color: #8ec6e0; font-weight: bold; }

    .player-box.repeat-partner { background-color: #ff9800; border: 2px solid #f57c00; font-weight: bold; }
.player-box.repeat-opponent {
  border: 3px dashed #dc3545 !important;
  box-shadow: 0 0 5px rgba(220, 53, 69, 0.5);
}

.playing-down-arrow {
  color: #cc0000;
  font-weight: bold;
  margin-right: 2px;
}

  .player-box.manual-match { background-color: #fff8dc; border: 2px solid #ffc107; }
    .player-box.drag-over { border-color: #28a745; border-width: 3px; background-color: #e8f5e8; }
    .format { font-style: italic; color: #666; margin-top: 8px; font-size: 0.9em; }
    
    .info-box { background: #cff4fc; border: 1px solid #0dcaf0; padding: 15px; border-radius: 5px; margin: 15px 0; }
    .warning-box { background: #fff3cd; border: 1px solid #ffc107; padding: 15px; border-radius: 5px; margin: 15px 0; }

/* === REGEN MODAL STYLES START === */
#regenModalOverlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.45);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 20000;
}
#regenModal {
  background: #ffffff;
  border-radius: 10px;
  width: min(420px, 92vw);
  box-shadow: 0 10px 30px rgba(0,0,0,0.25);
  border-top: 6px solid #1e40af; /* blue header accent */
  font-family: Arial, sans-serif;
}
#regenModalHeader {
  padding: 16px 20px 8px 20px;
}
#regenModalHeader h3 {
  margin: 0;
  color: #1e40af;
  font-size: 19px;
}
#regenModalBody {
  padding: 0 20px 16px 20px;
  color: #333;
  font-size: 14px;
}
#regenModalButtons {
  display: flex;
  gap: 10px;
  padding: 14px 20px 18px 20px;
  justify-content: flex-end;
  background: #f3f4f6;
  border-bottom-left-radius: 10px;
  border-bottom-right-radius: 10px;
}
.regen-btn {
  border: none;
  border-radius: 6px;
  padding: 8px 14px;
  cursor: pointer;
  font-size: 14px;
}
.regen-cancel {
  background: #e5e7eb;
  color: #111827;
}
.regen-rerun {
  background: #1d4ed8;
  color: #fff;
}
.regen-next {
  background: #0f766e;
  color: #fff;
}
.regen-btn:disabled {
  opacity: 0.55;
  cursor: not-allowed;
}
/* === REGEN MODAL STYLES END === */


    /* Player Selection Styles */
.selection-grid { 
  display: grid; 
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); 
  gap: 10px; 
  margin: 15px 0; 
}
.player-checkbox { 
  display: flex; 
  align-items: center; 
  padding: 8px; 
  border: 1px solid #ddd; 
  border-radius: 5px; 
  background: white; 
  cursor: pointer; 
  transition: all 0.2s;
}
.player-checkbox:hover { 
  border-color: #007acc; 
  background: #f8f9fa; 
}
.player-checkbox.pso { 
  background-color: #fff3cd; 
  border-color: #ffc107; 
}
.player-checkbox.selected { 
  background-color: #d4edda; 
  border-color: #28a745; 
}
.player-checkbox input { 
  margin-right: 10px; 
}

/* Auto-save indicator */
.save-status {
  position: fixed;
  top: 20px;
  right: 20px;
  background: #28a745;
  color: white;
  padding: 8px 16px;
  border-radius: 4px;
  font-size: 14px;
  z-index: 10000;
  transition: opacity 0.3s;
  opacity: 0;
}

.save-status.show {
  opacity: 1;
}


/* Sat-off player styles */
.sat-off-player {
  background: #fff8dc !important;
  border: 2px solid #ffc107 !important;
  font-weight: bold;
}

.sat-off-player:hover {
  background: #f0e68c !important;
  transform: scale(1.05);
}

.sat-off-player.dragging {
  opacity: 0.5;
}

#satOffPlayersContainer {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  min-height: 50px;
  padding: 10px;
  border: 2px dashed #ffc107;
  border-radius: 5px;
  background: #fffbf0;
}

#satOffPlayersContainer.drag-over {
  border-color: #007acc;
  background: #e3f2fd;
}
  </style>
</head>
<body>
  <!-- Logo Section -->
<div class="logo-section" style="position: relative;">
  <div style="display: flex; align-items: center; justify-content: center; gap: 20px;">
    <img src="CTClogo.jpg" alt="Tennis Club Logo" class="logo">
    <h1 style="margin: 0; color: #333;">Social Tennis Match Maker</h1>
  </div>
  <div style="position: absolute; bottom: 10px; right: 15px; font-size: 11px; color: #999;">
    ¬© 2025 Problems?: Paul Oen 0438 374 643
  </div>
  <div style="position: absolute; bottom: 10px; left: 15px; font-size: 11px; color: #999;">
    <span id="versionDisplay">Version: </span>
  </div>
  <script>
    // Display filename without .html extension, decoded and cleaned
    const filename = decodeURIComponent(window.location.pathname.split('/').pop().replace('.html', ''));
    document.getElementById('versionDisplay').textContent = 'Version: ' + filename;
  </script>
</div>

<div id="memberLoadStatus" style="margin: 15px 0;"></div>
  
<div style="text-align: center; margin: 15px 0; padding: 10px; background: #e3f2fd; border-radius: 5px;">
 <button id="importExcelBtn" class="secondary" style="background: #007acc;">üìã Import Excel File</button>
  <button onclick="clearSavedData()" class="danger" style="margin-left: 10px;">Start New Session</button>
 <button id="downloadBtnTop" class="primary" style="background: #28a745; margin-left: 10px;">üìã Download Today's Results</button>
 <button id="connectCheckinBtn" class="secondary" style="background: #9c27b0; margin-left: 10px;">üì± iPad Check-in</button>
 <span id="checkinStatus" class="checkin-status disconnected" style="display: none;">
   <span class="dot"></span>
   <span class="text">Disconnected</span>
 </span>
  <input type="file" id="excelFileInput" accept=".xlsx,.xls" style="display: none;">
 
</div> 

 <!-- Court Selection Section -->
<div class="section">
  <div class="step-header">Step 1: Select available courts</div>
  
  
     
    <h4>Selected Courts</h4>
    <div id="availableCourts" class="available-courts">
      <em style="color: #666;">Click or Drag courts here in the order they will initially be used</em>
    </div>
    
    <h4>Unselected Courts:</h4>
    <div id="courtPool" class="court-pool"></div>
    
    <button id="clearCourts" class="secondary">Clear All Courts</button>
  </div>

 <!-- Set Configuration -->
  <div class="section">
    <div class="step-header">Step 2: Choose match format and set number</div>
    
    <div class="format-section">
      <div class="format-label">Set Format Preference</div>
      <div class="format-buttons">
        <button type="button" class="format-btn active" data-format="Same-Sex">Same-Sex Doubles</button>
        <button type="button" class="format-btn" data-format="Mixed">Mixed Doubles</button>
      </div>
    </div>
    
    <div class="set-section">
      <div class="set-label">Set Number</div>
      <div class="set-buttons">
        <button type="button" class="set-btn active" data-set="1">Set 1</button>
        <button type="button" class="set-btn" data-set="2">Set 2</button>
        <button type="button" class="set-btn" data-set="3">Set 3</button>
        <button type="button" class="set-btn" data-set="4">Set 4</button>
        <button type="button" class="set-btn" data-set="5">Set 5</button>
        <button type="button" class="set-btn" data-set="6">Set 6</button>
      </div>
    </div>
    
    <!-- Hidden selects for compatibility -->
    <select id="formatSelector" style="display: none;">
      <option value="Same-Sex" selected>Same-Sex Doubles</option>
      <option value="Mixed">Mixed Doubles</option>
    </select>
    <select id="setNumberSelector" style="display: none;">
      <option value="1" selected>Set 1</option>
      <option value="2">Set 2</option>
      <option value="3">Set 3</option>
      <option value="4">Set 4</option>
      <option value="5">Set 5</option>
      <option value="6">Set 6</option>
    </select>
  </div>

  <!-- Player Selection Section -->
  <div id="playerSelectionSection" class="section" style="display:none;">
    <div class="step-header">Step 3: Player Input</div>
    
  
    
 <table class="player-table">
  <thead>
    <tr>
      <th style="width: 200px;">Name</th>
      <th style="width: 60px;">Grade</th>
      <th style="width: 60px;">Gender</th>
      <th style="width: 100px; font-size: 18px;" title="Select sets player is NOT available">Sets Not<br>Avail.</th>
      <th style="width: 60px;" title="No Hard Court">NHC</th>
      <th style="width: 50px;" title="Plus or Minus player">+/-</th>
      <th style="width: 50px;">Rest</th>
      <th style="width: 60px; font-size: 18px; padding: 8px 8px;" title="Previously Sat Out">Prev<br>Sat off</th>
      <th style="width: 60px; font-size: 18px; padding: 8px 8px;" title="Sitting Out">Sit Off</th>
    </tr>
  </thead>
  <tbody id="playerTableBody">
  </tbody>
  
</table>

<div id="changeWarningBanner" class="warning-box" style="display: none;">
  <h4>‚ö†Ô∏è Changes Detected</h4>
  <p>Player or court information has been modified after matches were generated. After sitting off the needed number of players, please click "Update Players and Proceed" to incorporate these changes.</p>
</div>
    
  <div style="text-align: center; margin: 15px 0;">
  <button id="addMoreRows" class="secondary">Add 10 More Rows</button>
<button id="openStripView" class="secondary" style="background: #6f42c1; margin-left: 10px;">Open Strip View</button>
  <button id="sortByFirstNameBtn" class="secondary" style="background: #6f42c1; margin-right: 10px;">Sort by First Name</button>
<button id="sortByArrivalBtn" class="secondary" style="background: #28a745;">Sort by Arrival Order</button>
  <button id="updateMasterList" class="secondary" style="background: #28a745; display: none;">Download New Member List</button>
  <button id="proceedToMatches" class="primary" disabled>Update Players and Proceed</button>
</div>

 <div id="sitOffCalculator" class="sit-off-calculator">
  <span id="sitOffCount">Players to sit off: -</span>
</div>

  <!-- Manual Match Setup Section -->
<div id="manualMatchSection" class="section" style="display:none !important;">
  <div class="step-header">Step 4: Manual Match Setup (optional)</div>
  <div class="manual-match-setup">
    <div class="manual-match-header">
    
      <button id="toggleManualSetup" class="secondary">Setup Manual Match</button>
    </div>
      
      <div id="manualSetupPanel" style="display:none;">
        <div class="info-box">
          <h4>Create Manual Matches</h4>
          <p>Set up special requests or exhibition games. These players will be excluded from automatic match generation.</p>
        </div>
        
        <div id="manualPlayerSelection">
          <h4>Available Players:</h4>
          <div id="manualPlayerGrid" class="manual-player-grid"></div>
        </div>
        
        <div class="team-formation">
          <div id="team1Slot" class="team-slot">
            <div class="team-slot-title">Team 1</div>
            <div id="team1Players"></div>
          </div>
          <div class="vs-divider">VS</div>
          <div id="team2Slot" class="team-slot">
            <div class="team-slot-title">Team 2</div>
            <div id="team2Players"></div>
          </div>
        </div>
        
        <div class="court-selector">
          <h4>Select Court:</h4>
          <div id="courtGrid" class="court-grid"></div>
        </div>
        
        <div style="text-align: center; margin: 20px 0;">
          <button id="addManualMatch" class="primary" disabled>Add Manual Match</button>
          <button id="clearManualSetup" class="secondary">Clear Setup</button>
        </div>
      </div>
      
      <div id="manualMatchesList" class="manual-matches-list"></div>
    </div>
    
    <div style="text-align: center; margin: 20px 0;">
      <button id="generateMatches" class="primary">Generate Remaining Matches</button>
    </div>
  </div>

  <!-- Results Section -->
<div id="matches" class="section" style="display:none;">
  <div class="step-header">Step 4: Generated Matches</div>
 
<div style="margin-bottom: 15px; display: flex; justify-content: space-between; align-items: center;">
  <div>
    <button id="downloadBtn" class="primary" style="background: #28a745;">üìã Download Today's Results</button>
    <button id="printBtn" class="primary" style="background: #007acc; margin-left: 10px;">üñ®Ô∏è Print Match Sheet</button>
    <button id="fullScreenBtn" class="primary" style="background: #6f42c1; margin-left: 10px;">üì∫ Full Screen Display</button>
  </div>
  <div>
    <button id="exportInputBtn" class="primary" style="background: #17a2b8; display: none;">üì§ Output Results as Input Files</button>
  </div>
</div>
    
<div id="matchResults"></div>
  </div>

<script>
// Global variables
let hasPlayerChanges = false;
let hasPlayerChangesAfterMatches = false;
let masterListData = [];
let availableCourts = [];
let playerRows = [];
let arrivalCounter = 0; // Counter for arrival order (1, 2, 3, ...)
let debugLog = [];
let currentData = null;
let currentMatches = null;
let allSetsData = {};
let currentSetNumber = 1;


// Auto-scroll variables for drag and drop
let autoScrollInterval = null;
let autoScrollSpeed = 0;
const SCROLL_ZONE_SIZE = 50; // pixels from top/bottom to trigger scrolling
const SCROLL_SPEED_MAX = 8; // maximum scroll speed

// ===== A/B SMART MIXING HELPERS (paste once) =====

// Cut an array into [A,B] halves (A gets the extra if odd)
function splitAB(arr) {
  const mid = Math.ceil(arr.length / 2);
  return [arr.slice(0, mid), arr.slice(mid)];
}

// Simple cyclic rotation (positive = right; negative = left)
function rotateRight(arr, k) {
  const n = arr.length;
  if (n === 0) return arr.slice();
  const r = ((k % n) + n) % n;
  if (r === 0) return arr.slice();
  return arr.slice(n - r).concat(arr.slice(0, n - r));
}

// Interleave two arrays A and B like A0,B0,A1,B1,...
function interleaveAB(A, B) {
  const out = [];
  const n = Math.max(A.length, B.length);
  for (let i = 0; i < n; i++) {
    if (i < A.length) out.push(A[i]);
    if (i < B.length) out.push(B[i]);
  }
  return out;
}

// A/B Smart Mixing for one gender list (already grade-sorted high‚Üílow)
// setNum = 1,2,3,...  (Set 1 = no rotation)
function mixABSmart(oneGenderSorted, setNum) {
  const n = oneGenderSorted.length;
  if (n <= 1) return oneGenderSorted.slice();

  // Split into A (top half) and B (bottom half)
  let [A, B] = splitAB(oneGenderSorted);

  // Drift each half by different amounts to avoid sticky tails.
  // Using small, different steps spreads matchups well.
  const shiftA = (setNum - 1);       // 0,1,2,3,...
  const shiftB = 2 * (setNum - 1);   // 0,2,4,6,...

  A = rotateRight(A, shiftA);
  B = rotateRight(B, shiftB);

  // Interleave to produce the mixed order
  return interleaveAB(A, B);
}


// Toggle which mixing mode to use by commenting/uncommenting one line:
// const MIXING_MODE = "torus";    // old Torus drift rotation
const MIXING_MODE = "ab-smart";   // new A/B Smart Mixing (default)


// Manual match variables
let manualMatches = [];


// Perfect 16 detection and management

function getPerfect16Schedule(setNumber) {
  // Each array represents one match: [player1, player2, player3, player4]
  // Players 1&2 are partners vs players 3&4 as partners
  // Players numbered 0-15
  
 const schedules = {
  1: [
    [0, 1, 2, 3],
    [4, 5, 6, 7],
    [8, 9, 10, 11],
    [12, 13, 14, 15]
  ],
  2: [
    [0, 4, 8, 12],
    [1, 5, 9, 13],
    [2, 6, 10, 14],
    [3, 7, 11, 15]
  ],
  3: [
    [0, 5, 10, 15],
    [1, 4, 11, 14],
    [2, 7, 8, 13],
    [3, 6, 9, 12]
  ],
  4: [
    [0, 6, 11, 13],
    [1, 7, 10, 12],
    [2, 4, 9, 15],
    [3, 5, 8, 14]
  ],
  5: [
    [0, 7, 9, 14],
    [1, 6, 8, 15],
    [2, 5, 11, 12],
    [3, 4, 10, 13]
  ]
};

  
  return schedules[setNumber] || null;
}

function generatePerfect16Matches(setNumber) {
  log("Generating Perfect 16 matches for Set " + setNumber);
  
  // Get the 16 players in order of entry
  const players = playerRows.filter(p => 
    p.name && p.name.trim() !== '' && 
    p.grade !== '' && 
    p.gender !== '' && 
    !p.resting && 
    !p.so
  );
  
  if (players.length !== 16) {
    log("ERROR: Expected 16 players, found " + players.length);
    return null;
  }
  
  // Number players 0-15 for the algorithm
  const numberedPlayers = players.map((player, index) => ({
    ...player,
    id: index
  }));
  
  // Get the predetermined schedule for this set
  const schedule = getPerfect16Schedule(setNumber);
  if (!schedule) {
    log("ERROR: No schedule found for Set " + setNumber);
    return null;
  }
  
  // Convert schedule to actual matches
  const matches = [];
  let courtIndex = 0;
  
  schedule.forEach(round => {
    if (courtIndex >= currentData.courts.length) {
      log("ERROR: Not enough courts for Perfect 16");
      return null;
    }
    
    const court = currentData.courts[courtIndex].court;
    const team1 = [numberedPlayers[round[0]], numberedPlayers[round[1]]];
    const team2 = [numberedPlayers[round[2]], numberedPlayers[round[3]]];
    
    // Determine format
    const format = players[0].gender === 'M' ? "Same-Sex Doubles (Men)" : "Same-Sex Doubles (Women)";
    
    matches.push({
      court: court,
      team1: team1,
      team2: team2,
      format: format,
      note: "Perfect 16 Set " + setNumber
    });
    
    courtIndex++;
  });
  
  log("Perfect 16: Generated " + matches.length + " matches for Set " + setNumber);
  return matches;
}

function detectPerfect16Scenario() {


  const currentSetNum = parseInt(document.getElementById('setNumberSelector').value);
  
  // Only applies to sets 1-5
  if (currentSetNum < 1 || currentSetNum > 5) {
    return false;
  }
  
  // Check if any manual matches exist for any set 1-5
  for (let setNum = 1; setNum <= 5; setNum++) {
    if (allSetsData[setNum] && allSetsData[setNum].matches) {
      const hasManualMatches = allSetsData[setNum].matches.some(match => match.isManual);
      if (hasManualMatches) {
        log("Perfect 16 disabled: Manual matches detected in Set " + setNum);
        return false;
      }
    }
  }
  
  // Check current manual matches
  if (manualMatches && manualMatches.length > 0) {
    log("Perfect 16 disabled: Manual matches selected for current set");
    return false;
  }
  
  // Check if we have exactly 16 players
  const activePlayers = playerRows.filter(p => 
    p.name && p.name.trim() !== '' && 
    p.grade !== '' && 
    p.gender !== '' && 
    !p.resting && 
    !p.so
  );
  
  if (activePlayers.length !== 16) {
    return false;
  }
  
  // Check if all players are same gender
  const genders = [...new Set(activePlayers.map(p => p.gender))];
  if (genders.length !== 1) {
    return false;
  }
  
  // Check if all players are same grade
  const grades = [...new Set(activePlayers.map(p => p.grade))];
  if (grades.length !== 1) {
    return false;
  }
  
  log("=== PERFECT 16 DETECTED ===");
  log("16 players, all " + genders[0] + ", all grade " + translateGrade(grades[0]));
  return true;
}

let selectedManualPlayers = [];
let selectedCourt = null;
let manualTeam1 = [];
let manualTeam2 = [];

// Auto-save functionality
function saveDataToStorage() {
  try {
    const dataToSave = {
      version: '1.0',
      timestamp: new Date().toISOString(),
      availableCourts: availableCourts,
      playerRows: playerRows,
      currentSetNumber: parseInt(document.getElementById('setNumberSelector').value),
      allSetsData: allSetsData,
      manualMatches: manualMatches,
      currentData: currentData,
      currentMatches: currentMatches,
      setFormatPreference: document.getElementById('formatSelector').value
    };
    
    localStorage.setItem('tennisMatchMaker_autoSave', JSON.stringify(dataToSave));
    localStorage.setItem('tennisMatchMaker_lastSave', new Date().toISOString());
    
    // Show brief save indicator
    showSaveIndicator();
    
  } catch (error) {
    console.warn('Failed to auto-save data:', error);
  }
}

function loadDataFromStorage() {
  try {
    const savedData = localStorage.getItem('tennisMatchMaker_autoSave');
    const lastSave = localStorage.getItem('tennisMatchMaker_lastSave');
    
    if (!savedData) return false;
    
    const data = JSON.parse(savedData);
    const saveDate = new Date(lastSave);
    const hoursSinceSave = (new Date() - saveDate) / (1000 * 60 * 60);
    
    // Don't auto-restore if more than 24 hours old
    if (hoursSinceSave > 24) {
      localStorage.removeItem('tennisMatchMaker_autoSave');
      localStorage.removeItem('tennisMatchMaker_lastSave');
      return false;
    }
    
   // Create custom dialog with buttons
const dialogHtml = `
  <div id="restoreDialog" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; display: flex; align-items: center; justify-content: center;">
    <div style="background: white; padding: 30px; border-radius: 8px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); max-width: 400px; text-align: center;">
      <h3 style="margin-top: 0; color: #333;">Previous Session Found</h3>
      <p style="color: #666; margin: 15px 0;">Data saved on ${saveDate.toLocaleString()}</p>
      <div style="margin: 25px 0;">
  <button id="freshBtn" style="background: #28a745; color: white; border: none; padding: 12px 20px; margin: 5px; border-radius: 5px; cursor: pointer; font-size: 16px;">Start Fresh</button>
  <button id="restoreBtn" style="background: #007acc; color: white; border: none; padding: 12px 20px; margin: 5px; border-radius: 5px; cursor: pointer; font-size: 16px;">Restore Old</button>
</div>
    </div>
  </div>
`;

// Add dialog to page
document.body.insertAdjacentHTML('beforeend', dialogHtml);

// Handle button clicks
document.getElementById('restoreBtn').onclick = () => {
  document.getElementById('restoreDialog').remove();
  restoreDataFromSave(data);
};

document.getElementById('freshBtn').onclick = () => {
  document.getElementById('restoreDialog').remove();
  localStorage.removeItem('tennisMatchMaker_autoSave');
  localStorage.removeItem('tennisMatchMaker_lastSave');
  
  // Try to clear check-in server (if running)
  fetch('http://localhost:3000/api/clear', { method: 'POST' })
    .then(() => console.log('Check-in server cleared'))
    .catch(() => console.log('Check-in server not running (OK)'));
  
  // Refresh the page to ensure clean state
  window.location.reload();
};

return false; // Don't auto-restore, let buttons handle it
    
  } catch (error) {
    console.warn('Failed to load saved data:', error);
  }
  return false;
}

function restoreDataFromSave(data) {
  try {
    // Restore basic data
    availableCourts = data.availableCourts || [];
    playerRows = data.playerRows || [];
    allSetsData = data.allSetsData || {};
    manualMatches = data.manualMatches || [];
    currentData = data.currentData;
    currentMatches = data.currentMatches;
     // FIXED: Restore arrivalCounter to continue from the highest existing arrival order
    const maxArrivalOrder = Math.max(0, ...playerRows.map(p => p.arrivalOrder || 0));
    arrivalCounter = maxArrivalOrder;
    console.log(`Restored arrivalCounter to ${arrivalCounter} (max from saved data)`);
    
   // Restore UI elements
document.getElementById('setNumberSelector').value = data.currentSetNumber || 1;
document.getElementById('formatSelector').value = data.setFormatPreference || 'Same-Sex';

// Update set number buttons to reflect restored set
document.querySelectorAll('.set-btn').forEach(btn => {
  btn.classList.remove('active');
  if (btn.dataset.set == (data.currentSetNumber || 1)) {
    btn.classList.add('active');
  }
});

// Update format buttons to reflect restored format
document.querySelectorAll('.format-btn').forEach(btn => {
  btn.classList.remove('active');
  if (btn.dataset.format === (data.setFormatPreference || 'Same-Sex')) {
    btn.classList.add('active');
  }
});
    
    // Update court display
    updateAvailableCourtsDisplay();

// FIX: Remove selected courts from the court pool
    initializeCourts(); // Rebuild the full court pool first
    availableCourts.forEach(selectedCourt => {
      const courtElement = document.querySelector(`[data-court="${selectedCourt}"]`);
      if (courtElement && courtElement.parentElement.id === 'courtPool') {
        courtElement.remove();
      }
    });
    
    // Restore player table
    restorePlayerTable();
    
    // Show appropriate sections
    if (playerRows.some(p => p.name && p.name.trim() !== '')) {
      document.getElementById('playerSelectionSection').style.display = 'block';
    }
    
   // if (availableCourts.length > 0 && playerRows.some(p => p.name && p.name.trim() !== '')) {
   //   document.getElementById('manualMatchSection').style.display = 'block';
   // }
    
    if (currentMatches && currentMatches.length > 0) {
      document.getElementById('matches').style.display = 'block';
      displayResults(currentData, currentMatches);
    }
    
    updateSitOffCalculation();
    updateProceedButton();
    
  //  alert('Data restored successfully!');
    
  } catch (error) {
    alert('Error restoring data: ' + error.message);
  }
}

function restorePlayerTable() {
  const tbody = document.getElementById('playerTableBody');
  tbody.innerHTML = '';
  
  while (playerRows.length < 10) {
    playerRows.push({
name: '', grade: '', gender: '', nhc: false, plusMinus: '',
      resting: false, pso: false, so: false
    });
  }
  
  playerRows.forEach((player, index) => {
    addPlayerRowAtIndex(index);
    // Restore player data
    if (player.name) {
      const nameInput = document.querySelector(`.name-input[data-row="${index}"]`);

      nameInput.value = player.name;


// FIX: Trigger the input event to properly initialize autocomplete, but skip suggestions for restored names
nameInput.dataset.skipAutocomplete = 'true';
const inputEvent = new Event('input', { bubbles: true });
nameInput.dispatchEvent(inputEvent);
// Remove the flag after a brief delay
setTimeout(() => {
  delete nameInput.dataset.skipAutocomplete;
}, 100);
      
      // **FIX: Manually update the playerRows data for visitor names**
      playerRows[index].name = player.name;
      
      document.getElementById(`grade-${index}`).value = player.grade;
      document.getElementById(`gender-${index}`).value = player.gender;
      document.getElementById(`nhc-${index}`).checked = player.nhc;
      document.getElementById(`plusminus-${index}`).value = player.plusMinus || '';
      document.getElementById(`resting-${index}`).checked = player.resting;
      document.getElementById(`pso-${index}`).checked = player.pso;
      document.getElementById(`so-${index}`).checked = player.so;
      
      // Restore unavailable sets
      if (player.unavailableSets) {
        const selectedSets = [];
        for (let i = 1; i <= 6; i++) {
          if (player.unavailableSets[`set${i}`]) {
            selectedSets.push(i.toString());
          }
        }
        
        // Update hidden input
        const hiddenInput = document.getElementById(`unavailable-${index}`);
        if (hiddenInput) {
          hiddenInput.value = selectedSets.join(',');
        }
        
        // Update button text
        const button = document.getElementById(`sets-btn-${index}`);
        if (button) {
          if (selectedSets.length === 0) {
            button.textContent = 'None';
            button.classList.remove('has-selections');
          } else {
            button.textContent = selectedSets.join(', ');
            button.classList.add('has-selections');
          }
        }
      }
      
      // Show delete button if player has data
      if (player.name && player.grade && player.gender) {
        document.querySelector(`[data-row="${index}"].delete-player-btn`).style.display = 'block';
      }
    }
  });
}

function addPlayerRowAtIndex(rowIndex) {
  const tbody = document.getElementById('playerTableBody');
  
  const tr = document.createElement('tr');
  tr.innerHTML = `
    <td style="position: relative;">
      <div style="display: flex; align-items: center; gap: 5px;">
        <input type="text" class="name-input" placeholder="Start typing name..." 
               data-row="${rowIndex}" autocomplete="off" style="flex: 1;">
        <button type="button" class="delete-player-btn" data-row="${rowIndex}" 
                style="background: #dc3545; color: white; border: none; border-radius: 3px; 
                       padding: 3px 6px; font-size: 12px; cursor: pointer; display: none;"
                title="Remove player">√ó</button>
      </div>
      <div class="autocomplete-suggestions" id="suggestions-${rowIndex}" style="display: none;"></div>
    </td>
    <td>
      <select class="grade-select" id="grade-${rowIndex}" data-row="${rowIndex}">
        <option value="">-</option>
        <option value="5">2</option>
        <option value="4">2A</option>
        <option value="3">2B</option>
        <option value="2">3</option>
        <option value="1">3A</option>
      </select>
    </td>
    <td>
      <select class="gender-select" id="gender-${rowIndex}" data-row="${rowIndex}">
        <option value="">-</option>
        <option value="M">M</option>
        <option value="F">F</option>
      </select>
    </td>

<td>
      <button class="sets-button" id="sets-btn-${rowIndex}" data-row="${rowIndex}" 
              title="Click to select sets player is NOT available">
        None
      </button>
      <input type="hidden" id="unavailable-${rowIndex}" data-row="${rowIndex}">
    </td>

    <td class="checkbox-cell">
      <input type="checkbox" class="status-checkbox" id="nhc-${rowIndex}" data-row="${rowIndex}">
    </td>
<td>
  <select class="grade-select" id="plusminus-${rowIndex}" data-row="${rowIndex}">
    <option value=""></option>
    <option value="+">+</option>
    <option value="-">-</option>
  </select>
</td>
    <td class="checkbox-cell">
      <input type="checkbox" class="status-checkbox" id="resting-${rowIndex}" data-row="${rowIndex}">
    </td>
    <td class="checkbox-cell">
      <input type="checkbox" class="status-checkbox readonly" id="pso-${rowIndex}" data-row="${rowIndex}">
    </td>
    <td class="checkbox-cell">
      <input type="checkbox" class="status-checkbox" id="so-${rowIndex}" data-row="${rowIndex}">
    </td>
  `;
  
  tbody.appendChild(tr);
  
  // Add all the event listeners (same as in addPlayerRow function)
  const nameInput = tr.querySelector('.name-input');
  attachNameInputHandlers(tr, nameInput, rowIndex);
updateStripDisplay(); // Update magnetic strip display
  
  // Add other event listeners...
  const restingCheckbox = tr.querySelector(`#resting-${rowIndex}`);
  restingCheckbox.addEventListener('change', (e) => {
    playerRows[rowIndex].resting = e.target.checked;
   updateSitOffCalculation();
    updateProceedButton();
    saveDataToStorage(); // Auto-save
    checkForPlayerChangesAfterMatches(); // Track changes
  });
  
  const psoCheckbox = tr.querySelector(`#pso-${rowIndex}`);
  psoCheckbox.addEventListener('change', (e) => {
    playerRows[rowIndex].pso = e.target.checked;
    saveDataToStorage(); // Auto-save
  });
  
  const soCheckbox = tr.querySelector(`#so-${rowIndex}`);
  soCheckbox.addEventListener('change', (e) => {
    playerRows[rowIndex].so = e.target.checked;
    updateSitOffCalculation();
    updateProceedButton();
    saveDataToStorage(); // Auto-save
checkForPlayerChangesAfterMatches();
  });
  
  const deleteBtn = tr.querySelector(`[data-row="${rowIndex}"].delete-player-btn`);
  deleteBtn.addEventListener('click', () => {
    // Capture player name before clearing for server notification
    const deletedPlayerName = playerRows[rowIndex].name;
    
   document.querySelector(`[data-row="${rowIndex}"]`).value = '';
    document.getElementById(`grade-${rowIndex}`).value = '';
    document.getElementById(`gender-${rowIndex}`).value = '';
    document.getElementById(`nhc-${rowIndex}`).checked = false;
    document.getElementById(`plusminus-${rowIndex}`).value = '';
    document.getElementById(`resting-${rowIndex}`).checked = false;
    document.getElementById(`pso-${rowIndex}`).checked = false;
    document.getElementById(`so-${rowIndex}`).checked = false;
    // Clear multi-select
    const unavailableInput = document.getElementById(`unavailable-${rowIndex}`);
    unavailableInput.value = '';
    
    // Also reset the button display
    const setsButton = document.getElementById(`sets-btn-${rowIndex}`);
    if (setsButton) {
      setsButton.textContent = 'None';
      setsButton.classList.remove('has-selections');
    }
    
    // Notify check-in server of player removal
    if (checkinServerConnected && deletedPlayerName) {
      notifyServerPlayerRemoved(deletedPlayerName);
    }
    
    setTimeout(() => {
      playerRows.splice(rowIndex, 1);
      while (playerRows.length < 10) {
       playerRows.push({
          name: '',
          grade: '',
          gender: '',
          nhc: false,
          plusMinus: '',
          resting: false,
          pso: false,
          so: false,
          arrivalOrder: null,
          unavailableSets: { set1: false, set2: false, set3: false, set4: false, set5: false, set6: false }
        });
      }
      refreshPlayerTable();
     updateSitOffCalculation();
    updateProceedButton();
    saveDataToStorage(); // Auto-save
    checkForPlayerChangesAfterMatches();
    updateStripDisplay(); // Update magnetic strip display
    }, 100);
  });
  
  const gradeSelect = tr.querySelector(`#grade-${rowIndex}`);
  gradeSelect.addEventListener('change', (e) => {
    playerRows[rowIndex].grade = e.target.value === '' ? '' : parseInt(e.target.value);
    // Show delete button if player has name, grade, and gender
    const nameInput = tr.querySelector('.name-input');
    const deleteBtn = tr.querySelector(`[data-row="${rowIndex}"].delete-player-btn`);
    if (nameInput.value.trim() !== '' && playerRows[rowIndex].grade !== '' && playerRows[rowIndex].gender !== '') {
      deleteBtn.style.display = 'block';
      // Assign arrival order if this is the first time all fields are complete
      if (!playerRows[rowIndex].arrivalOrder) {
        playerRows[rowIndex].arrivalOrder = ++arrivalCounter;
        console.log(`Player ${nameInput.value.trim()} assigned arrival order: ${playerRows[rowIndex].arrivalOrder}`);
      }
    }
   updateSitOffCalculation();
    updateProceedButton();
    saveDataToStorage(); // Auto-save
    checkForPlayerChangesAfterMatches();
   // Only update strip display if player is complete
    if (nameInput.value.trim() !== '' && playerRows[rowIndex].grade !== '' && playerRows[rowIndex].gender !== '') {
      setTimeout(() => updateStripDisplay(), 50);
    }
  });
  
  const genderSelect = tr.querySelector(`#gender-${rowIndex}`);
  genderSelect.addEventListener('change', (e) => {
    playerRows[rowIndex].gender = e.target.value;
    // Show delete button if player has name, grade, and gender
    const nameInput = tr.querySelector('.name-input');
    const deleteBtn = tr.querySelector(`[data-row="${rowIndex}"].delete-player-btn`);
    if (nameInput.value.trim() !== '' && playerRows[rowIndex].grade !== '' && playerRows[rowIndex].gender !== '') {
      deleteBtn.style.display = 'block';
      // Assign arrival order if this is the first time all fields are complete
      if (!playerRows[rowIndex].arrivalOrder) {
        playerRows[rowIndex].arrivalOrder = ++arrivalCounter;
        console.log(`Player ${nameInput.value.trim()} assigned arrival order: ${playerRows[rowIndex].arrivalOrder}`);
      }
    }
    updateSitOffCalculation();
    updateProceedButton();
    saveDataToStorage(); // Auto-save
    checkForPlayerChangesAfterMatches();
    // Only update strip display if player is complete
    if (nameInput.value.trim() !== '' && playerRows[rowIndex].grade !== '' && playerRows[rowIndex].gender !== '') {
      setTimeout(() => updateStripDisplay(), 50);
    }
  });
  
  const nhcCheckbox = tr.querySelector(`#nhc-${rowIndex}`);
  nhcCheckbox.addEventListener('change', (e) => {
    playerRows[rowIndex].nhc = e.target.checked;
    saveDataToStorage(); // Auto-save
checkForPlayerChangesAfterMatches();
  });
  
  

const plusMinusSelect = tr.querySelector(`#plusminus-${rowIndex}`);
plusMinusSelect.addEventListener('change', (e) => {
  playerRows[rowIndex].plusMinus = e.target.value;
  saveDataToStorage(); // Auto-save
  checkForPlayerChangesAfterMatches();
});

// Unavailable sets - now handled by modal
// The sets selection is managed through the modal dialog
// See the sets modal JavaScript section for implementation
}

function showSaveIndicator() {
  // Create or update save indicator
  let indicator = document.getElementById('saveIndicator');
  if (!indicator) {
    indicator = document.createElement('div');
    indicator.id = 'saveIndicator';
    indicator.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      background: #28a745;
      color: white;
      padding: 8px 16px;
      border-radius: 4px;
      font-size: 14px;
      z-index: 10000;
      transition: opacity 0.3s;
    `;
    document.body.appendChild(indicator);
  }
  
  indicator.textContent = 'Saved ‚úì';
  indicator.style.opacity = '1';
  
  setTimeout(() => {
    indicator.style.opacity = '0';
  }, 2000);
}

function checkForPlayerChangesAfterMatches() {
  // Only track changes if matches have been displayed
  const matchesSection = document.getElementById('matches');
  if (matchesSection.style.display === 'block') {
    hasPlayerChangesAfterMatches = true;
    showChangeWarning();
  }
}

function showChangeWarning() {
  // Show warning banner
  document.getElementById('changeWarningBanner').style.display = 'block';
  
  // Hide sections after player input
  document.getElementById('manualMatchSection').style.display = 'none';
  document.getElementById('matches').style.display = 'none';
}

function clearChangeWarning() {
  hasPlayerChangesAfterMatches = false;
  document.getElementById('changeWarningBanner').style.display = 'none';
}

// === REGEN MODAL LOGIC START ===
function showRegenerationModal(setNum, onRerunCurrent, onCancel) {
  const overlay = document.getElementById('regenModalOverlay');
  const setNumSpan = document.getElementById('regenSetNumber');
  const btnCancel = document.getElementById('regenCancelBtn');
  const btnRerun = document.getElementById('regenRerunBtn');

  // Update set number in header
  setNumSpan.textContent = setNum;
  document.getElementById('regenSetNumberBtn').textContent = setNum;

  // show the modal
  overlay.style.display = 'flex';

  // clear old handlers (in case we open it more than once)
  btnCancel.onclick = null;
  btnRerun.onclick = null;

  btnRerun.onclick = function() {
    overlay.style.display = 'none';
    if (typeof onRerunCurrent === 'function') onRerunCurrent();
  };

  btnCancel.onclick = function() {
    overlay.style.display = 'none';
    
    // Scroll to the set selector buttons
    const setSection = document.querySelector('.set-section');
    if (setSection) {
      setSection.scrollIntoView({ 
        behavior: 'smooth', 
        block: 'center' 
      });
    }
    
    if (typeof onCancel === 'function') onCancel();
  };
}
// === REGEN MODAL LOGIC END ===

function clearSavedData() {
  if (confirm('Are you sure you want to clear all saved data and refresh the screen? This cannot be undone.')) {
    localStorage.removeItem('tennisMatchMaker_autoSave');
    localStorage.removeItem('tennisMatchMaker_lastSave');
    
    // Clear check-in server if connected
    if (checkinWebSocket && checkinWebSocket.readyState === WebSocket.OPEN) {
      checkinWebSocket.send(JSON.stringify({ type: 'clear' }));
    }
    
    // Refresh the browser
    window.location.reload();
  }
}

// Logging function
function log(message) {
  console.log(message);
  debugLog.push(message);
}
// Smooth scroll function
function scrollToElement(elementId) {
  const element = document.getElementById(elementId);
  if (element) {
    element.scrollIntoView({ 
      behavior: 'smooth', 
      block: 'start' 
    });
  }
}

// Grade translation function - converts numeric grades to club format
function translateGrade(numericGrade) {
  switch(numericGrade) {
    case 5: return '2';
    case 4: return '2A';
    case 3: return '2B';
    case 2: return '3';
    case 1: return '3A';
    default: return numericGrade; // fallback for any unexpected values
  }
}

// Reverse grade translation function - converts club codes to numeric grades
function reverseTranslateGrade(clubCode) {
  switch(clubCode) {
    case "2": return 5;      // Strongest
    case "2A": return 4;
    case "2B": return 3;
    case "3": return 2;
    case "3A": return 1;     // Weakest
    default: return clubCode; // fallback for any unexpected values
  }
}

// Helper function to generate the JavaScript file content
function generateJSFileContent(membersArray) {
  let jsContent = '// Tennis Club Member Master List\n';
  jsContent += '// Generated on: ' + new Date().toLocaleString() + '\n';
  jsContent += '// Total Members: ' + membersArray.length + '\n\n';
  jsContent += 'const MEMBERS = [\n';
  
  membersArray.forEach((member, index) => {
    // Format as single line
   jsContent += `  {name: "${member.name}", grade: "${translateGrade(member.grade)}", gender: "${member.gender}", nhc: ${!!member.nhc}, plusMinus: ${member.plusMinus ? `"${member.plusMinus}"` : '""'}}`;
    
    // Add comma if not the last item
    if (index < membersArray.length - 1) {
      jsContent += ',';
    }
    jsContent += '\n';
  });
  
  jsContent += '];\n';
  return jsContent;
}

// Helper function to download the JavaScript file
function downloadJSFile(content) {
  // Create a blob with the JavaScript content
  const blob = new Blob([content], { type: 'text/javascript' });
  
  // Create a download link
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  
  // Create a readable date format like "9 Nov 25"
const now = new Date();
const day = now.getDate();
const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
const month = months[now.getMonth()];
const year = now.getFullYear().toString().slice(-2);
const dateStr = `${day} ${month} ${year}`;

link.download = `Member Master List update ${dateStr}.js`;
  
  // Trigger download
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  
  // Clean up the URL
  URL.revokeObjectURL(url);
}

// Initialize courts (37 courts: 1-27, H1-H10)
function initializeCourts() {
  const courtPool = document.getElementById('courtPool');
  courtPool.innerHTML = '';
  
  const courts = [];
  
  // Grass courts 1-27
  for (let i = 1; i <= 27; i++) {
    courts.push(i.toString());
  }
  
  // Hard courts H1-H10
  for (let i = 1; i <= 10; i++) {
    courts.push('H' + i);
  }
  
  courts.forEach(court => {
  const courtDiv = document.createElement('div');
  // Determine court type and add appropriate class
  const isHardCourt = court.toString().toUpperCase().startsWith('H');
  courtDiv.className = isHardCourt ? 'court-item hard-court' : 'court-item grass-court';
  courtDiv.textContent = court;
  courtDiv.draggable = true;
  courtDiv.dataset.court = court;
    
   courtDiv.addEventListener('dragstart', handleCourtDragStart);
courtDiv.addEventListener('dragend', handleCourtDragEnd);
courtDiv.addEventListener('click', () => moveCourtToSelected(court, courtDiv));

courtPool.appendChild(courtDiv);
  });
}

// Court drag and drop handlers
function handleCourtDragStart(e) {
  e.dataTransfer.setData('text/plain', e.target.dataset.court);
  e.target.classList.add('dragging');
}

function handleCourtDragEnd(e) {
  e.target.classList.remove('dragging');
}

// Available courts drag and drop
const availableCourtsDiv = document.getElementById('availableCourts');

availableCourtsDiv.addEventListener('dragover', (e) => {
  e.preventDefault();
  availableCourtsDiv.classList.add('drag-over');
});

availableCourtsDiv.addEventListener('dragleave', (e) => {
  availableCourtsDiv.classList.remove('drag-over');
});

availableCourtsDiv.addEventListener('drop', (e) => {
  e.preventDefault();
  availableCourtsDiv.classList.remove('drag-over');
  
  const court = e.dataTransfer.getData('text/plain');
  if (court && !availableCourts.includes(court)) {
    availableCourts.push(court);
    updateAvailableCourtsDisplay();
    
    // Remove from court pool
    const courtElement = document.querySelector(`[data-court="${court}"]`);
    if (courtElement && courtElement.parentElement.id === 'courtPool') {
      courtElement.remove();
    }
  }
});

// Function to generate and download updated Member Master List
function generateUpdatedMasterList() {
  try {
    // Start with existing members from the original file
    let updatedMembers = [...masterListData];
    
    // First, collect all players from all sets played today
const allPlayersFromSets = [];
Object.keys(allSetsData).forEach(setNum => {
  const setData = allSetsData[setNum];
  if (setData && setData.data) {
    // Add players from availableMen
    if (setData.data.availableMen) {
      setData.data.availableMen.forEach(p => {
        if (p.name && p.grade && !allPlayersFromSets.some(existing => existing.name === p.name)) {
          allPlayersFromSets.push({...p, gender: 'M'});
        }
      });
    }
    // Add players from availableWomen
    if (setData.data.availableWomen) {
      setData.data.availableWomen.forEach(p => {
        if (p.name && p.grade && !allPlayersFromSets.some(existing => existing.name === p.name)) {
          allPlayersFromSets.push({...p, gender: 'F'});
        }
      });
    }
  }
});

// Then add any current players not already in the list
const currentPlayersInTable = playerRows.filter(p => 
  p.name && p.name.trim() !== '' && 
  p.grade !== '' && 
  p.gender !== '' &&
  !allPlayersFromSets.some(existing => existing.name === p.name)
);

// Combine all players
const currentPlayers = [...allPlayersFromSets, ...currentPlayersInTable];
    
    let addedCount = 0;
    let updatedCount = 0;
    
    currentPlayers.forEach(currentPlayer => {
      // Check if this player exists in the original master list
const existingIndex = updatedMembers.findIndex(member => 
  member.name.toLowerCase() === currentPlayer.name.toLowerCase()
);

if (existingIndex >= 0) {
  // Player exists - check if any data has changed
  const existing = updatedMembers[existingIndex];
  
  // For NHC, use the original value from master list, not the temporary daily value
  const nhcValue = existing.nhc;  // Keep original NHC from master list
  
  const needsUpdate =
    existing.grade !== currentPlayer.grade ||
    existing.gender !== currentPlayer.gender ||
    // NHC comparison removed - we keep original
  
    (existing.plusMinus || '') !== (currentPlayer.plusMinus || '');

  if (needsUpdate) {
    // Update existing player (but preserve original NHC)
    updatedMembers[existingIndex] = {
      name: currentPlayer.name,
      grade: currentPlayer.grade,
      gender: currentPlayer.gender,
      nhc: nhcValue,  // Use original NHC value
  
      plusMinus: currentPlayer.plusMinus || ""
    };
    updatedCount++;
  }
} else {
  // New player - for truly new players, NHC should be false unless they manually set it
  updatedMembers.push({
    name: currentPlayer.name,
    grade: currentPlayer.grade,
    gender: currentPlayer.gender,
    nhc: false,  // New players start with NHC=false
   
    plusMinus: currentPlayer.plusMinus || ""
  });
  addedCount++;
}
    });
    
    // Sort the updated list alphabetically by name
    updatedMembers.sort((a, b) => a.name.localeCompare(b.name));
    
    // Generate the JavaScript file content
    const jsContent = generateJSFileContent(updatedMembers);
    
    // Create and download the file
    downloadJSFile(jsContent);
    
    // Show success message
    const message = `Member list downloaded successfully!\nAdded: ${addedCount} new players\nUpdated: ${updatedCount} existing players\nTotal players: ${updatedMembers.length}`;
    alert(message);
    
    log(`Master list generated: ${addedCount} added, ${updatedCount} updated, ${updatedMembers.length} total`);
    
  } catch (error) {
    alert(`Error generating master list: ${error.message}`);
    log(`Error generating master list: ${error.message}`);
  }
}

function updateAvailableCourtsDisplay() {
  const availableCourtsDiv = document.getElementById('availableCourts');
  
  if (availableCourts.length === 0) {
    availableCourtsDiv.innerHTML = '<em style="color: #666;">Click or Drag courts here in the order they will initially be used</em>';
    return;
  }
  
  availableCourtsDiv.innerHTML = '';
  
  availableCourts.forEach((court, index) => {
    const courtDiv = document.createElement('div');
const isHardCourt = court.toString().toUpperCase().startsWith('H');
courtDiv.className = isHardCourt ? 'court-item hard-court' : 'court-item grass-court';
    courtDiv.textContent = court;
    courtDiv.style.cursor = 'pointer';
    courtDiv.title = 'Click to remove from selection';
    
    // Allow removing courts by clicking
    courtDiv.addEventListener('click', () => {
      moveCourtBackToPool(court, index);
    });
    
    availableCourtsDiv.appendChild(courtDiv);
  });
}

function moveCourtBackToPool(court, index) {
  // Remove from available courts
  availableCourts.splice(index, 1);
  updateAvailableCourtsDisplay();
  
  // Rebuild entire court pool to show all unselected courts
  initializeCourts();
  
  // Remove selected courts from pool
  availableCourts.forEach(selectedCourt => {
    const courtElement = document.querySelector(`[data-court="${selectedCourt}"]`);
    if (courtElement && courtElement.parentElement.id === 'courtPool') {
      courtElement.remove();
    }
  });
  
  // Update sit-off calculation with new court count
  updateSitOffCalculation();
  updateProceedButton();
  saveDataToStorage();
checkForPlayerChangesAfterMatches(); // Track court changes
}
function addCourtToPool(court) {
  const courtPool = document.getElementById('courtPool');
  const newCourtDiv = document.createElement('div');
  const isHardCourt = court.toString().toUpperCase().startsWith('H');
  newCourtDiv.className = isHardCourt ? 'court-item hard-court' : 'court-item grass-court';
  newCourtDiv.textContent = court;
  newCourtDiv.draggable = true;
  newCourtDiv.dataset.court = court;
  newCourtDiv.style.cursor = 'pointer';
  newCourtDiv.title = 'Click to add to selection, or drag to specific position';
  
  // Add drag functionality
  newCourtDiv.addEventListener('dragstart', handleCourtDragStart);
  newCourtDiv.addEventListener('dragend', handleCourtDragEnd);

  // Add click functionality  
  newCourtDiv.addEventListener('click', () => {
    if (!availableCourts.includes(court)) {
      moveCourtToSelected(court, newCourtDiv);
    }
  });
  
  // Insert in correct position instead of just appending
  const existingCourts = Array.from(courtPool.children);
  let insertPosition = existingCourts.length; // Default to end
  
  for (let i = 0; i < existingCourts.length; i++) {
    const existingCourt = existingCourts[i].dataset.court;
    if (shouldCourtComeBefore(court, existingCourt)) {
      insertPosition = i;
      break;
    }
  }
  
  if (insertPosition >= existingCourts.length) {
    courtPool.appendChild(newCourtDiv);
  } else {
    courtPool.insertBefore(newCourtDiv, existingCourts[insertPosition]);
  }
}

// Helper function to determine court order
function shouldCourtComeBefore(court1, court2) {
  const isHard1 = court1.toString().toUpperCase().startsWith('H');
  const isHard2 = court2.toString().toUpperCase().startsWith('H');
  
  // Grass courts (1-27) come before hard courts (H1-H10)
  if (!isHard1 && isHard2) return true;
  if (isHard1 && !isHard2) return false;
  
  // Both are same type, sort numerically
  if (!isHard1 && !isHard2) {
    // Both grass courts - numerical sort
    return parseInt(court1) < parseInt(court2);
  } else {
    // Both hard courts - extract number after H and sort
    const num1 = parseInt(court1.substring(1));
    const num2 = parseInt(court2.substring(1));
    return num1 < num2;
  }
}
  

function moveCourtToSelected(court, courtElement) {
  // Only add if not already selected
  if (!availableCourts.includes(court)) {
    availableCourts.push(court);
    updateAvailableCourtsDisplay();
    updateSitOffCalculation();
    updateProceedButton();
    saveDataToStorage();
checkForPlayerChangesAfterMatches(); // Track court changes    
    // Remove from court pool
    courtElement.remove();
  }
}

// Clear courts button
document.getElementById('clearCourts').addEventListener('click', () => {
  availableCourts = [];
  updateAvailableCourtsDisplay();
  initializeCourts();
  updateSitOffCalculation();
  updateProceedButton();
  saveDataToStorage();
checkForPlayerChangesAfterMatches(); // Track court changes
});

// Auto-load member list on page initialization
function loadMemberListOnStartup() {
  try {
    // Check if MEMBERS is available
    if (typeof MEMBERS === 'undefined') {
      document.getElementById('memberLoadStatus').innerHTML = 
        '<div class="error">‚ùå Member Master List.js file not found. Please ensure the file is in the same folder as this HTML file.</div>';
      return;
    }
    
   // Load members from the JavaScript file and convert club codes to numeric
masterListData = MEMBERS.map(member => ({
  name: member.name,
  grade: reverseTranslateGrade(member.grade), // Convert club code to numeric
  gender: member.gender,
  nhc: member.nhc,
// nxd removed
  plusMinus: member.plusMinus, // Add the new plusMinus field
  originalGrade: member.grade // Keep original club code for display
}));


    
    document.getElementById('memberLoadStatus').innerHTML = 
      `<div class="success">‚úì Loaded ${masterListData.length} players from member list</div>`;
    
    // Show player selection section
    document.getElementById('playerSelectionSection').style.display = 'block';
    initializePlayerTable();
    
  } catch (error) {
    document.getElementById('memberLoadStatus').innerHTML = 
      `<div class="error">Error loading member list: ${error.message}</div>`;
  }
}

// Initialize player table
function initializePlayerTable() {
  playerRows = [];
  const tbody = document.getElementById('playerTableBody');
  tbody.innerHTML = '';
  
  // Add initial 10 rows
  for (let i = 0; i < 10; i++) {
    addPlayerRow();
  }
  
  updateSitOffCalculation();
}

function addPlayerRow() {
  const tbody = document.getElementById('playerTableBody');
  const rowIndex = playerRows.length;
  
 const row = {
    name: '',
    grade: '',
    gender: '',
    nhc: false,
   // nxd removed
    plusMinus: '',
    resting: false,
    pso: false,
    so: false,
    arrivalOrder: null,
    unavailableSets: { set1: false, set2: false, set3: false, set4: false, set5: false, set6: false }
  };
  playerRows.push(row);
  
  const tr = document.createElement('tr');
  tr.innerHTML = `
    <td style="position: relative;">
      <div style="display: flex; align-items: center; gap: 5px;">
        <input type="text" class="name-input" placeholder="Start typing name..." 
               data-row="${rowIndex}" autocomplete="off" style="flex: 1;">
        <button type="button" class="delete-player-btn" data-row="${rowIndex}" 
                style="background: #dc3545; color: white; border: none; border-radius: 3px; 
                       padding: 3px 6px; font-size: 12px; cursor: pointer; display: none;"
                title="Remove player">√ó</button>
      </div>
      <div class="autocomplete-suggestions" id="suggestions-${rowIndex}" style="display: none;"></div>
    </td>
    <td>
      <select class="grade-select" id="grade-${rowIndex}" data-row="${rowIndex}">
        <option value="">-</option>
        <option value="5">2</option>
        <option value="4">2A</option>
        <option value="3">2B</option>
        <option value="2">3</option>
        <option value="1">3A</option>
      </select>
    </td>
    <td>
      <select class="gender-select" id="gender-${rowIndex}" data-row="${rowIndex}">
        <option value="">-</option>
        <option value="M">M</option>
        <option value="F">F</option>
    </select>
    </td>

    <td>
      <button class="sets-button" id="sets-btn-${rowIndex}" data-row="${rowIndex}" 
              title="Click to select sets player is NOT available">
        None
      </button>
      <input type="hidden" id="unavailable-${rowIndex}" data-row="${rowIndex}">
    </td>

    <td class="checkbox-cell">
      <input type="checkbox" class="status-checkbox" id="nhc-${rowIndex}" data-row="${rowIndex}">
    </td>
    
    <td>
      <select class="grade-select" id="plusminus-${rowIndex}" data-row="${rowIndex}">
        <option value=""></option>
        <option value="+">+</option>
        <option value="-">-</option>
      </select>
    </td>
    <td class="checkbox-cell">
      <input type="checkbox" class="status-checkbox" id="resting-${rowIndex}" data-row="${rowIndex}">
    </td>
    <td class="checkbox-cell">
     <input type="checkbox" class="status-checkbox readonly" id="pso-${rowIndex}" data-row="${rowIndex}">
    </td>
    <td class="checkbox-cell">
      <input type="checkbox" class="status-checkbox" id="so-${rowIndex}" data-row="${rowIndex}">
    </td>
  `;
  
  tbody.appendChild(tr);
  
  // Add event listeners - CONSOLIDATED VERSION
  const nameInput = tr.querySelector('.name-input');
  
  // Single combined input event listener
  attachNameInputHandlers(tr, nameInput, rowIndex);

  const restingCheckbox = tr.querySelector(`#resting-${rowIndex}`);
  restingCheckbox.addEventListener('change', (e) => {
    playerRows[rowIndex].resting = e.target.checked;
    updateSitOffCalculation();
    updateProceedButton();
    saveDataToStorage(); // Auto-save
    checkForPlayerChangesAfterMatches(); // Track changes
  });
  
  const psoCheckbox = tr.querySelector(`#pso-${rowIndex}`);
  psoCheckbox.addEventListener('change', (e) => {
    playerRows[rowIndex].pso = e.target.checked;
    saveDataToStorage(); // Auto-save
    checkForPlayerChangesAfterMatches(); // Track changes
  });
  
  const soCheckbox = tr.querySelector(`#so-${rowIndex}`);
  soCheckbox.addEventListener('change', (e) => {
    playerRows[rowIndex].so = e.target.checked;
    updateSitOffCalculation();
    updateProceedButton();
    saveDataToStorage(); // Auto-save
checkForPlayerChangesAfterMatches();
  });

  const deleteBtn = tr.querySelector(`[data-row="${rowIndex}"].delete-player-btn`);
  deleteBtn.addEventListener('click', () => {
    document.querySelector(`[data-row="${rowIndex}"]`).value = '';
    document.getElementById(`grade-${rowIndex}`).value = '';
    document.getElementById(`gender-${rowIndex}`).value = '';
    document.getElementById(`nhc-${rowIndex}`).checked = false;
   
    document.getElementById(`plusminus-${rowIndex}`).value = '';
    document.getElementById(`resting-${rowIndex}`).checked = false;
    document.getElementById(`pso-${rowIndex}`).checked = false;
    document.getElementById(`so-${rowIndex}`).checked = false;
    
    setTimeout(() => {
      playerRows.splice(rowIndex, 1);
      while (playerRows.length < 10) {
        playerRows.push({
          name: '',
          grade: '',
          gender: '',
          nhc: false,
        // nxd removed
          plusMinus: '',
          resting: false,
          pso: false,
          so: false,
          arrivalOrder: null,
          unavailableSets: { set1: false, set2: false, set3: false, set4: false, set5: false, set6: false }
        });
      }
     refreshPlayerTable();
      updateSitOffCalculation();
      updateProceedButton();
      saveDataToStorage();
      checkForPlayerChangesAfterMatches();
    }, 100);
  });
  
  // FIXED: Add missing saveDataToStorage() calls
  const gradeSelect = tr.querySelector(`#grade-${rowIndex}`);
  gradeSelect.addEventListener('change', (e) => {
    playerRows[rowIndex].grade = e.target.value === '' ? '' : parseInt(e.target.value);
    // Show delete button if player has name, grade, and gender
    const nameInput = tr.querySelector('.name-input');
    const deleteBtn = tr.querySelector(`[data-row="${rowIndex}"].delete-player-btn`);
    if (nameInput.value.trim() !== '' && playerRows[rowIndex].grade !== '' && playerRows[rowIndex].gender !== '') {
      deleteBtn.style.display = 'block';
      // Assign arrival order if this is the first time all fields are complete
      if (!playerRows[rowIndex].arrivalOrder) {
        playerRows[rowIndex].arrivalOrder = ++arrivalCounter;
        console.log(`Player ${nameInput.value.trim()} assigned arrival order: ${playerRows[rowIndex].arrivalOrder}`);
      }
    }
    updateSitOffCalculation();
    updateProceedButton();
    saveDataToStorage(); // FIXED: Auto-save grade changes
    checkForPlayerChangesAfterMatches(); // Track changes

    // Only update strip display if player is complete
    if (nameInput.value.trim() !== '' && playerRows[rowIndex].grade !== '' && playerRows[rowIndex].gender !== '') {
      setTimeout(() => updateStripDisplay(), 50);
    }
  });

 const genderSelect = tr.querySelector(`#gender-${rowIndex}`);
  genderSelect.addEventListener('change', (e) => {
    playerRows[rowIndex].gender = e.target.value;
    // Show delete button if player has name, grade, and gender
    const nameInput = tr.querySelector('.name-input');
    const deleteBtn = tr.querySelector(`[data-row="${rowIndex}"].delete-player-btn`);
    if (nameInput.value.trim() !== '' && playerRows[rowIndex].grade !== '' && playerRows[rowIndex].gender !== '') {
      deleteBtn.style.display = 'block';
      // Assign arrival order if this is the first time all fields are complete
      if (!playerRows[rowIndex].arrivalOrder) {
        playerRows[rowIndex].arrivalOrder = ++arrivalCounter;
        console.log(`Player ${nameInput.value.trim()} assigned arrival order: ${playerRows[rowIndex].arrivalOrder}`);
      }
    }
   updateSitOffCalculation();
    updateProceedButton();
    saveDataToStorage(); // FIXED: Auto-save gender changes
    checkForPlayerChangesAfterMatches(); // Track changes
    // Only update strip display if player is complete
    if (nameInput.value.trim() !== '' && playerRows[rowIndex].grade !== '' && playerRows[rowIndex].gender !== '') {
      setTimeout(() => updateStripDisplay(), 50);
    }
  });

  const nhcCheckbox = tr.querySelector(`#nhc-${rowIndex}`);
  nhcCheckbox.addEventListener('change', (e) => {
    playerRows[rowIndex].nhc = e.target.checked;
    saveDataToStorage(); // Auto-save
    checkForPlayerChangesAfterMatches(); // Track changes
  });

  const plusMinusSelect = tr.querySelector(`#plusminus-${rowIndex}`);
  plusMinusSelect.addEventListener('change', (e) => {
    playerRows[rowIndex].plusMinus = e.target.value;
    saveDataToStorage(); // Auto-save
    checkForPlayerChangesAfterMatches(); // Track changes
  });

  // Unavailable sets - now handled by modal
  // The sets selection is managed through the modal dialog
  // See the sets modal JavaScript section for implementation
}

function handleNameInput(e, rowIndex) {

// Skip autocomplete for restored names
  if (e.target.dataset.skipAutocomplete === 'true') {
    return;
  }

  const input = e.target.value.toLowerCase();
  const suggestionsDiv = document.getElementById(`suggestions-${rowIndex}`);
  
  if (input.length === 0) {
    hideSuggestions(rowIndex);
    return;
  }
  
  // Get list of already used names (excluding current row)
  const usedNames = playerRows
    .map((p, index) => index !== rowIndex ? p.name : null)
    .filter(name => name && name.trim() !== '');
  
  // IMPROVED MATCHING: Handle both partial and full name searches
const matches = masterListData.filter(player => {
  if (usedNames.includes(player.name)) return false; // Exclude already used names
  
  const playerName = player.name.toLowerCase();
  const nameParts = playerName.split(' ');
  
  // If full name starts with input, it's a match
  if (playerName.startsWith(input)) return true;
  
  // Otherwise check if any name part starts with input
  return nameParts.some(part => part.startsWith(input));
}).sort((a, b) => a.name.localeCompare(b.name)) // Sort alphabetically by name
  .slice(0, 10); // Limit to 10 suggestions
  
  if (matches.length === 0) {
    hideSuggestions(rowIndex);
    return;
  }
  
  suggestionsDiv.innerHTML = '';
  matches.forEach((player, index) => {
    const suggestionDiv = document.createElement('div');
    suggestionDiv.className = 'autocomplete-suggestion';
    if (index === 0) suggestionDiv.classList.add('selected'); // Auto-select first item
    suggestionDiv.textContent = `${player.name} (${player.originalGrade || translateGrade(player.grade)})`;
 // Fire on mousedown so Windows users can click anywhere in the row
suggestionDiv.addEventListener('mousedown', (ev) => {
  ev.preventDefault();
  selectPlayer(rowIndex, player);
});

// Also handle click for keyboard selection (Enter key)
suggestionDiv.addEventListener('click', (ev) => {
  ev.preventDefault();
  selectPlayer(rowIndex, player);
});
    suggestionsDiv.appendChild(suggestionDiv);
  });
  
  suggestionsDiv.style.display = 'block';
}
function handleNameKeydown(e, rowIndex) {
  const suggestionsDiv = document.getElementById(`suggestions-${rowIndex}`);
  const isOpen = suggestionsDiv && suggestionsDiv.style.display === 'block';
  const suggestions = isOpen ? suggestionsDiv.querySelectorAll('.autocomplete-suggestion') : [];

  // If Enter is pressed while the list is closed or empty,
  // accept the typed text as a visitor/new member
  if (e.key === 'Enter') {
    if (!isOpen || suggestions.length === 0) {
      e.preventDefault();
      const name = e.target.value.trim();
      if (name) {
        // Persist the visitor name
        playerRows[rowIndex].name = name;
        saveDataToStorage();
        checkForPlayerChangesAfterMatches?.();
      }
      hideSuggestions(rowIndex);
      // Optional UX: jump to Grade field to keep the flow moving
      const gradeEl = document.getElementById(`grade-${rowIndex}`);
      if (gradeEl) gradeEl.focus();
      return;
    }
  }

  // If the list isn't open, ignore navigation keys
  if (!isOpen || suggestions.length === 0) return;

  let selectedIndex = -1;
  suggestions.forEach((s, i) => { if (s.classList.contains('selected')) selectedIndex = i; });

  if (e.key === 'ArrowDown') {
    e.preventDefault();
    if (selectedIndex >= 0) suggestions[selectedIndex].classList.remove('selected');
    selectedIndex = selectedIndex < suggestions.length - 1 ? selectedIndex + 1 : 0;
    suggestions[selectedIndex].classList.add('selected');
    suggestions[selectedIndex].scrollIntoView({ block: 'nearest' });
  } else if (e.key === 'ArrowUp') {
    e.preventDefault();
    if (selectedIndex >= 0) suggestions[selectedIndex].classList.remove('selected');
    selectedIndex = selectedIndex > 0 ? selectedIndex - 1 : suggestions.length - 1;
    suggestions[selectedIndex].classList.add('selected');
    suggestions[selectedIndex].scrollIntoView({ block: 'nearest' });
  } else if (e.key === 'Enter') {
    e.preventDefault();
    const targetSuggestion = selectedIndex >= 0 ? suggestions[selectedIndex] : suggestions[0];
    targetSuggestion?.click();
  }
}

function selectPlayer(rowIndex, player) {
  // Preserve existing arrivalOrder if it exists, otherwise assign a new one
  const existingArrivalOrder = playerRows[rowIndex].arrivalOrder;
  
  playerRows[rowIndex] = {
    name: player.name,
    grade: player.grade,
    gender: player.gender,
    nhc: player.nhc,
// nxd removed
    plusMinus: player.plusMinus || '',
    resting: playerRows[rowIndex].resting,
    pso: playerRows[rowIndex].pso,
    so: playerRows[rowIndex].so,
    arrivalOrder: existingArrivalOrder || ++arrivalCounter,
    unavailableSets: { set1: false, set2: false, set3: false, set4: false, set5: false, set6: false }
  };
  
  // Log if we assigned a new arrival order
  if (!existingArrivalOrder) {
    console.log(`Player ${player.name} assigned arrival order: ${playerRows[rowIndex].arrivalOrder}`);
  }
  
  // Update the UI
  document.querySelector(`[data-row="${rowIndex}"]`).value = player.name;
  document.getElementById(`grade-${rowIndex}`).value = player.grade;
  document.getElementById(`gender-${rowIndex}`).value = player.gender;
  document.getElementById(`nhc-${rowIndex}`).checked = player.nhc;

document.getElementById(`plusminus-${rowIndex}`).value = player.plusMinus || '';
  
  // Show the delete button
  document.querySelector(`[data-row="${rowIndex}"].delete-player-btn`).style.display = 'block';

  hideSuggestions(rowIndex);
  updateSitOffCalculation();
  updateProceedButton();
  saveDataToStorage();
  setTimeout(() => updateStripDisplay(), 50);

  // Notify check-in server so iPads know this player is taken
  if (checkinServerConnected) {
    checkinWebSocket.send(JSON.stringify({
      type: 'checkin',
      player: playerRows[rowIndex]
    }));
  }

  // Auto-focus next empty name field
  setTimeout(() => {
    for (let i = rowIndex + 1; i < playerRows.length; i++) {
      if (!playerRows[i].name || playerRows[i].name.trim() === '') {
        const nextInput = document.querySelector(`[data-row="${i}"]`);
        if (nextInput) {
          nextInput.focus();
          break;
        }
      }
    }
  }, 100);
}

function getPlayerPlusMinus(playerName, data) {
  // Only use playerRows (current session data) - the player input table is the source of truth
  const playerRowData = playerRows.find(p => p.name === playerName);
  if (playerRowData) {
    return playerRowData.plusMinus || '';
  }
  
  return '';
}

function clearPlayerRow(rowIndex) {
// Clear the player data
playerRows[rowIndex] = {
  name: '',
  grade: '',
  gender: '',
  nhc: false,
// nxd removed
  plusMinus: '', // Add the new plusMinus field
  resting: false,
  pso: false,
  so: false
};
// Clear the UI
  document.querySelector(`[data-row="${rowIndex}"]`).value = '';
  document.getElementById(`grade-${rowIndex}`).value = '';
  document.getElementById(`gender-${rowIndex}`).value = '';
  document.getElementById(`nhc-${rowIndex}`).checked = false;

document.getElementById(`plusminus-${rowIndex}`).value = '';
  document.getElementById(`resting-${rowIndex}`).checked = false;
  document.getElementById(`pso-${rowIndex}`).checked = false;
  document.getElementById(`so-${rowIndex}`).checked = false;
  
  // Hide the delete button
  document.querySelector(`[data-row="${rowIndex}"].delete-player-btn`).style.display = 'none';
  
  // Update calculations
  updateSitOffCalculation();
  updateProceedButton();
checkForPlayerChangesAfterMatches();
}

function attachNameInputHandlers(tr, nameInput, rowIndex) {
  nameInput.addEventListener('input', (e) => {
    // keep the autocomplete working
    handleNameInput(e, rowIndex);

    // keep your data in sync with what you type
    playerRows[rowIndex].name = e.target.value;

    // show/hide the delete button
    const deleteBtn = tr.querySelector(`[data-row="${rowIndex}"].delete-player-btn`);
    const hasAll = e.target.value.trim() !== '' &&
                   playerRows[rowIndex].grade !== '' &&
                   playerRows[rowIndex].gender !== '';
    deleteBtn.style.display = hasAll ? 'block' : 'none';
    
    // Assign arrival order if this is the first time all fields are complete
    if (hasAll && !playerRows[rowIndex].arrivalOrder) {
      playerRows[rowIndex].arrivalOrder = ++arrivalCounter;
      console.log(`Player ${e.target.value.trim()} assigned arrival order: ${playerRows[rowIndex].arrivalOrder}`);
    }

   // update counts, buttons, save, and show the warning banner
    updateSitOffCalculation();
    updateProceedButton();
    saveDataToStorage();
    checkForPlayerChangesAfterMatches();
    // Only update strip display if player is complete
    if (e.target.value.trim() !== '' && playerRows[rowIndex].grade !== '' && playerRows[rowIndex].gender !== '') {
      setTimeout(() => updateStripDisplay(), 50);
    }
  });

  // keep Enter/arrow key behavior and tidy up the suggestions box
  nameInput.addEventListener('keydown', (e) => handleNameKeydown(e, rowIndex));
  nameInput.addEventListener('blur', () => setTimeout(() => hideSuggestions(rowIndex), 150));
}

function hideSuggestions(rowIndex) {
  const suggestionsDiv = document.getElementById(`suggestions-${rowIndex}`);
  if (!suggestionsDiv) return;
  suggestionsDiv.style.display = 'none';
  suggestionsDiv.innerHTML = ''; // clear stale items so Enter can't select them
}


function updateSitOffCalculation() {
  const activePlayers = playerRows.filter(p => p.name && p.name.trim() !== '' && p.grade !== '' && p.gender !== '' && !p.resting && !p.so);
  const soPlayers = playerRows.filter(p => p.name && p.name.trim() !== '' && p.grade !== '' && p.gender !== '' && !p.resting && p.so);
  const totalActivePlayers = activePlayers.length;
  
  // Calculate total available players (including those selected to sit off)
  const totalAvailablePlayers = playerRows.filter(p => p.name && p.name.trim() !== '' && p.grade !== '' && p.gender !== '' && !p.resting).length;
  
  // Calculate court capacity
  const maxCourtCapacity = availableCourts.length * 4;
  
  // Calculate sit-offs needed for divisibility (groups of 4) - use TOTAL available, not just active
  const divisibilitySitOffs = totalAvailablePlayers % 4;
  
  // Calculate sit-offs needed due to court capacity - use TOTAL available
  const capacitySitOffs = Math.max(0, totalAvailablePlayers - maxCourtCapacity);
  
  // Total sit-offs needed is the larger of the two requirements
  const totalNeededToSitOff = Math.max(divisibilitySitOffs, capacitySitOffs);
  
  const alreadySelectedToSitOff = soPlayers.length;
  const remainingToSelect = Math.max(0, totalNeededToSitOff - alreadySelectedToSitOff);
  
  const sitOffElement = document.getElementById('sitOffCount');
  const calculatorElement = document.getElementById('sitOffCalculator');
  
  // Count grass and hard courts
const grassCourts = availableCourts.filter(court => !court.toString().toUpperCase().startsWith('H')).length;
const hardCourts = availableCourts.filter(court => court.toString().toUpperCase().startsWith('H')).length;
const totalCourts = availableCourts.length;
const courtsNeeded = Math.floor(totalActivePlayers / 4);

// Count active players by gender
const activeMen = activePlayers.filter(p => p.gender === 'M').length;
const activeWomen = activePlayers.filter(p => p.gender === 'F').length;

// Update the display text with detailed court and player information
let displayText = `Grass courts available: ${grassCourts}, hard courts available: ${hardCourts}, total courts needed: ${courtsNeeded}, players to sit off: ${remainingToSelect}<br>`;
displayText += `Total Men: ${activeMen}, Total Women: ${activeWomen}, Total Players: ${totalActivePlayers}`;

sitOffElement.innerHTML = displayText;
  
  // Update styling based on remaining count
  calculatorElement.className = 'sit-off-calculator';
  if (totalNeededToSitOff === 0) {
    calculatorElement.classList.add('sit-off-good');
  } else if (remainingToSelect === 0) {
    calculatorElement.classList.add('sit-off-good');
  } else {
    // Keep default styling when players still need to be selected
  }
}

function autoSelectSitOffPlayers() {
  const currentSetNum = parseInt(document.getElementById('setNumberSelector').value);
  const activePlayers = playerRows.filter(p => p.name && p.name.trim() !== '' && p.grade !== '' && p.gender !== '' && !p.resting);
  
  // Calculate court capacity
  const maxCourtCapacity = availableCourts.length * 4;

  // Calculate sit-offs needed for divisibility (groups of 4)
  const divisibilitySitOffs = activePlayers.length % 4;

  // Calculate sit-offs needed due to court capacity
  const capacitySitOffs = Math.max(0, activePlayers.length - maxCourtCapacity);

  // Total sit-offs needed is the larger of the two requirements
  const totalNeededToSitOff = Math.max(divisibilitySitOffs, capacitySitOffs);
  
  if (totalNeededToSitOff === 0) return; // No sit-offs needed
  
  // Clear any existing SO selections (but not PSO)
  playerRows.forEach((player, index) => {
    if (!player.pso) {
      player.so = false;
      const soCheckbox = document.getElementById(`so-${index}`);
      if (soCheckbox) soCheckbox.checked = false;
    }
  });
  
  let eligiblePlayers = [];
  
  if (currentSetNum === 1) {
   // Set 1: All non-PSO active players are eligible, sorted by arrival order
    eligiblePlayers = activePlayers
      .filter(player => !player.pso)
      .sort((a, b) => {
        // Use arrivalOrder if available, otherwise use 0 (very old)
        const aOrder = a.arrivalOrder ? a.arrivalOrder : 0;
        const bOrder = b.arrivalOrder ? b.arrivalOrder : 0;
        return aOrder - bOrder; // Sort by arrival order (earliest first)
      })
      .slice(-totalNeededToSitOff); // Take the last ones (latest arrivals)
  } else {
    // Set 2+: Calculate participation for each player, preserving original arrival order
    const playerSetCounts = activePlayers
      .filter(player => !player.pso)
      .map(player => {
        let setsPlayed = 0;
        for (let setNum = 1; setNum < currentSetNum; setNum++) {
          if (!allSetsData[setNum] || !allSetsData[setNum].matches) continue;
          
          const playedInSet = allSetsData[setNum].matches.some(match => 
            match.team1.some(p => p.name === player.name) || 
            match.team2.some(p => p.name === player.name)
          );
          
          if (playedInSet) setsPlayed++;
        }
        return { player, setsPlayed };
      });
    
    // Try each participation level from highest to lowest
    const maxSetsPlayed = Math.max(...playerSetCounts.map(p => p.setsPlayed));
    
    for (let setsPlayed = maxSetsPlayed; setsPlayed >= 0 && eligiblePlayers.length < totalNeededToSitOff; setsPlayed--) {
      // Get players at this level, maintaining original arrival order
      const playersAtThisLevel = playerSetCounts
        .filter(p => p.setsPlayed === setsPlayed)
        .map(p => p.player)
        .sort((a, b) => {
          // Use arrivalOrder if available, otherwise use 0 (very old)
          const aOrder = a.arrivalOrder ? a.arrivalOrder : 0;
          const bOrder = b.arrivalOrder ? b.arrivalOrder : 0;
          return aOrder - bOrder; // Sort by arrival order (earliest first)
        });
      
      // Select from bottom of this group (latest arrivals)
      const needed = totalNeededToSitOff - eligiblePlayers.length;
      const toAdd = playersAtThisLevel.slice(-needed);
      eligiblePlayers = eligiblePlayers.concat(toAdd);
      
      if (eligiblePlayers.length >= totalNeededToSitOff) {
        log(`Selected from players with ${setsPlayed} sets played`);
        break;
      }
    }
  }
  
  // Apply the selections
  eligiblePlayers.forEach(selectedPlayer => {
    const playerIndex = playerRows.findIndex(p => p.name === selectedPlayer.name);
    if (playerIndex >= 0) {
      playerRows[playerIndex].so = true;
      const soCheckbox = document.getElementById(`so-${playerIndex}`);
      if (soCheckbox) soCheckbox.checked = true;
    }
  });
  
  // Update UI
  updateSitOffCalculation();
  updateProceedButton();
  saveDataToStorage();
  
  log(`Auto-selected ${eligiblePlayers.length} players to sit off for Set ${currentSetNum}: ${eligiblePlayers.map(p => p.name).join(', ')}`);
}

function updateProceedButton() {
  const activePlayers = playerRows.filter(p => p.name && p.name.trim() !== '' && p.grade !== '' && p.gender !== '' && !p.resting);
  const soPlayers = playerRows.filter(p => p.name && p.name.trim() !== '' && p.gender !== '' && !p.resting && p.so);
  const proceedBtn = document.getElementById('proceedToMatches');

  if (activePlayers.length >= 4 && availableCourts.length > 0) {
    const totalActivePlayers = activePlayers.length;

    // Calculate court capacity (same logic as updateSitOffCalculation)
    const maxCourtCapacity = availableCourts.length * 4;
    const divisibilitySitOffs = totalActivePlayers % 4;
    const capacitySitOffs = Math.max(0, totalActivePlayers - maxCourtCapacity);
    const sitOffNeeded = Math.max(divisibilitySitOffs, capacitySitOffs);

    const sitOffSelected = soPlayers.length;

    if (sitOffNeeded === 0 && sitOffSelected === 0) {
      // No sit-offs needed, none selected - perfect
      proceedBtn.disabled = false;
      proceedBtn.textContent = 'Proceed to Match Generation';
      proceedBtn.dataset.action = 'proceed';
    } else if (sitOffNeeded > 0 && sitOffSelected === sitOffNeeded) {
      // Sit-offs needed and correct number selected
      proceedBtn.disabled = false;
      proceedBtn.textContent = 'Proceed to Match Generation';
      proceedBtn.dataset.action = 'proceed';
    } else if (sitOffNeeded > 0 && sitOffSelected < sitOffNeeded) {
      // Need more selections - show suggest button
      proceedBtn.disabled = false;
      proceedBtn.textContent = 'Suggest names to sit off';
      proceedBtn.dataset.action = 'suggest';
    } else if (sitOffNeeded > 0 && sitOffSelected > sitOffNeeded) {
      // Too many selected
      const excess = sitOffSelected - sitOffNeeded;
      proceedBtn.disabled = false;  // Make it clickable
      proceedBtn.textContent = `Remove ${excess} sit-off selections`;
      proceedBtn.dataset.action = 'clear-excess'; 
    } else if (sitOffNeeded === 0 && sitOffSelected > 0) {
      // No sit-offs needed but some selected
      proceedBtn.disabled = false;
      proceedBtn.textContent = `Remove ${sitOffSelected} sit-off selections (none needed)`;
      proceedBtn.dataset.action = 'clear-so';  // New action type
    }
  } else {
    // OUTER-ELSE (restored): Not enough players or no courts ‚Äî keep button disabled
    proceedBtn.disabled = true;
    proceedBtn.textContent = 'Proceed to Match Generation';
    proceedBtn.dataset.action = 'disabled';
  }
}

// Add more rows button
document.getElementById('addMoreRows').addEventListener('click', () => {
  for (let i = 0; i < 10; i++) {
    addPlayerRow();
  }
});

// Open Strip View button
document.getElementById('openStripView').addEventListener('click', () => {
  openStripDisplay();
});

// Sort players alphabetically button
document.getElementById('sortByFirstNameBtn').addEventListener('click', () => {
  sortByFirstName();
});

document.getElementById('sortByArrivalBtn').addEventListener('click', () => {
  sortByArrivalOrder();
});

function sortByFirstName() {
  // Get only the players with complete data (name, grade, gender)
  const playersWithData = playerRows
    .filter(p => p.name && p.name.trim() !== '' && p.grade !== '' && p.gender !== '');
  
  if (playersWithData.length === 0) {
    alert('No players to sort. Please add some players first.');
    return;
  }
  
  // Sort by first name
  playersWithData.sort((a, b) => {
    const aFirstName = a.name.trim().split(' ')[0].toLowerCase();
    const bFirstName = b.name.trim().split(' ')[0].toLowerCase();
    return aFirstName.localeCompare(bFirstName);
  });
  
  console.log(`Sorted ${playersWithData.length} players alphabetically by first name`);
  
  // Create a new playerRows array preserving empty rows
  const newPlayerRows = [];
  
  // Place sorted players back
  playersWithData.forEach(player => {
    newPlayerRows.push(player);
  });
  
  // Add empty rows to maintain at least 10 rows total
  while (newPlayerRows.length < 10) {
    newPlayerRows.push({
      name: '', 
      grade: '', 
      gender: '', 
      nhc: false, 
   // nxd removed
      plusMinus: '',
      resting: false, 
      pso: false, 
      so: false,
      arrivalOrder: null
    });
  }
  
  playerRows = newPlayerRows;
  
  // Refresh the table display
  refreshPlayerTable();
  updateSitOffCalculation();
  updateProceedButton();
  saveDataToStorage();
}

function sortByArrivalOrder() {
  // Get only the players with complete data (name, grade, gender)
  const playersWithData = playerRows
    .filter(p => p.name && p.name.trim() !== '' && p.grade !== '' && p.gender !== '');
  
  if (playersWithData.length === 0) {
    alert('No players to sort. Please add some players first.');
    return;
  }
  
  // Sort by arrival order
  playersWithData.sort((a, b) => {
    const aOrder = a.arrivalOrder ? a.arrivalOrder : 99999;
    const bOrder = b.arrivalOrder ? b.arrivalOrder : 99999;
    return aOrder - bOrder;
  });
  
  console.log(`Sorted ${playersWithData.length} players by arrival order`);
  
  // Create a new playerRows array preserving empty rows
  const newPlayerRows = [];
  
  // Place sorted players back
  playersWithData.forEach(player => {
    newPlayerRows.push(player);
  });
  
  // Add empty rows to maintain at least 10 rows total
  while (newPlayerRows.length < 10) {
    newPlayerRows.push({
      name: '', 
      grade: '', 
      gender: '', 
      nhc: false, 
   // nxd removed
      plusMinus: '',
      resting: false, 
      pso: false, 
      so: false,
      arrivalOrder: null
    });
  }
  
  playerRows = newPlayerRows;
  
  // Refresh the table display
  refreshPlayerTable();
  updateSitOffCalculation();
  updateProceedButton();
  saveDataToStorage();
}
// Update Master List button
document.getElementById('updateMasterList').addEventListener('click', generateUpdatedMasterList);

// Set number change handler
document.getElementById('setNumberSelector').addEventListener('change', function() {
  const newSetNumber = parseInt(this.value);
  const previousSetNumber = newSetNumber - 1;
  
  // Reset format to Same-Sex when changing sets
document.getElementById('formatSelector').value = 'Same-Sex';
// Update format buttons to reflect the change
document.querySelectorAll('.format-btn').forEach(btn => {
  btn.classList.remove('active');
  if (btn.dataset.format === 'Same-Sex') {
    btn.classList.add('active');
  }
});

// CLEAR MANUAL MATCHES when changing sets
manualMatches = [];
updateManualMatchDisplay();

// Reset manual match interface state
selectedManualPlayers = [];
selectedCourt = null;
manualTeam1 = [];
manualTeam2 = [];
updateTeamDisplay();
updateAddMatchButton();
  
  // If moving to set 2 or higher, move SO players to PSO
  if (newSetNumber > 1 && allSetsData[previousSetNumber]) {
    const previousSatOffPlayers = allSetsData[previousSetNumber].satOffPlayers || [];
    
    // Update player data: move SO to PSO for previously sat-off players
    playerRows.forEach((player, index) => {
      if (previousSatOffPlayers.includes(player.name)) {
        // Move from SO to PSO
        player.so = false;
        player.pso = true;
        
        // Update the UI checkboxes
        const soCheckbox = document.getElementById(`so-${index}`);
        const psoCheckbox = document.getElementById(`pso-${index}`);
        
        if (soCheckbox) soCheckbox.checked = false;
        if (psoCheckbox) psoCheckbox.checked = true;
      }
    });
    
    console.log(`Moved ${previousSatOffPlayers.length} players from SO to PSO for Set ${newSetNumber}`);

// NEW: Set NHC=true for players who played on hard courts in previous set
    if (allSetsData[previousSetNumber].matches) {
      allSetsData[previousSetNumber].matches.forEach(match => {
        const isHardCourt = match.court && match.court.toString().toUpperCase().startsWith('H');
        
        if (isHardCourt) {
          [...match.team1, ...match.team2].forEach(player => {
            const playerRowIndex = playerRows.findIndex(p => p.name === player.name);
            if (playerRowIndex >= 0 && !playerRows[playerRowIndex].nhc) {
              playerRows[playerRowIndex].nhc = true;
              
              // Update the UI checkbox
              const nhcCheckbox = document.getElementById(`nhc-${playerRowIndex}`);
              if (nhcCheckbox) nhcCheckbox.checked = true;
              
              console.log(`Set NHC=true for ${player.name} (played on hard court ${match.court} in Set ${previousSetNumber})`);
            }
          });
        }
      });
    }
  }
  
  // Reset current set SO selections and validation
  playerRows.forEach((player, index) => {
    if (!player.pso) { // Don't reset PSO players
      player.so = false;
      const soCheckbox = document.getElementById(`so-${index}`);
      if (soCheckbox) soCheckbox.checked = false;
    }
  });
  
  // Update calculations and button state
  updateSitOffCalculation();
  updateProceedButton();
  
  // Hide any open sections
  document.getElementById('manualMatchSection').style.display = 'none';
  document.getElementById('matches').style.display = 'none';
  document.getElementById('generateMatches').textContent = `Generate Remaining Matches for Set ${newSetNumber}`;
});

// Proceed to matches button - improved with conditional logic
document.getElementById('proceedToMatches').addEventListener('click', (e) => {
  const action = e.target.dataset.action;
  
  if (action === 'proceed') {
    processPlayersAndProceed();
    // Scroll to manual match section after a brief delay
    setTimeout(() => {
      scrollToElement('manualMatchSection');
    }, 100);
  } else if (action === 'suggest') {
    autoSelectSitOffPlayers();
  } else if (action === 'clear-so') {
    // NEW: Clear all SO selections when none needed
    playerRows.forEach((player, index) => {
      if (player.so) {
        player.so = false;
        const soCheckbox = document.getElementById(`so-${index}`);
        if (soCheckbox) soCheckbox.checked = false;
      }
    });
    updateSitOffCalculation();
    updateProceedButton();
    saveDataToStorage();
  } else if (action === 'clear-excess') {
    // NEW: Clear excess SO selections
    const activePlayers = playerRows.filter(p => p.name && p.name.trim() !== '' && p.grade !== '' && p.gender !== '' && !p.resting);
    const maxCourtCapacity = availableCourts.length * 4;
    const divisibilitySitOffs = activePlayers.length % 4;
    const capacitySitOffs = Math.max(0, activePlayers.length - maxCourtCapacity);
    const sitOffNeeded = Math.max(divisibilitySitOffs, capacitySitOffs);
    
    let soCount = 0;
    playerRows.forEach((player, index) => {
      if (player.so) {
        soCount++;
        if (soCount > sitOffNeeded) {
          player.so = false;
          const soCheckbox = document.getElementById(`so-${index}`);
          if (soCheckbox) soCheckbox.checked = false;
        }
      }
    });
    updateSitOffCalculation();
    updateProceedButton();
    saveDataToStorage();
  }
  // Do nothing if action is 'disabled' or undefined
});

function processPlayersAndProceed() {
  clearChangeWarning(); // Clear any change warnings

  const currentSetNum = parseInt(document.getElementById('setNumberSelector').value);
  const setHasMatches =
    allSetsData[currentSetNum] &&
    allSetsData[currentSetNum].matches &&
    allSetsData[currentSetNum].matches.length > 0;

  // this is your existing main work, moved into a helper so the modal can call it
  function continueProcessing() {
    // ADDED: Store existing manual matches before processing
    const preservedManualMatches = [...manualMatches];

    // ADDED: Sort back to arrival order for match generation
    const playersWithArrival = playerRows.filter(p =>
      p.name && p.name.trim() !== '' &&
      p.grade !== '' &&
      p.gender !== '' &&
      p.arrivalOrder
    );

    if (playersWithArrival.length > 0) {
      // Sort by arrival order for consistent match generation
      playersWithArrival.sort((a, b) => a.arrivalOrder - b.arrivalOrder);

      // Update playerRows with arrival-sorted players first
      const playersWithoutArrival = playerRows.filter(p => !p.arrivalOrder);
      playerRows = [...playersWithArrival, ...playersWithoutArrival];
    }

    // Create data structure similar to original format
    const activePlayers = playerRows.filter(p =>
      p.name && p.name.trim() !== '' &&
      p.grade !== '' &&
      p.gender !== '' &&
      !p.resting &&
      !p.so
    );

    const availableMen = activePlayers.filter(p => p.gender === 'M');
    const availableWomen = activePlayers.filter(p => p.gender === 'F');

    // Create courts data structure with mixing for Set 2+
    const courts = availableCourts.map((court, index) => ({
      priority: index + 1,
      court: court
    }));

    const setNumber = parseInt(document.getElementById('setNumberSelector').value);
    const finalCourts = mixCourts(courts, setNumber);

    currentData = {
      setFormatPreference: document.getElementById('formatSelector').value,
      availableMen: availableMen,
      availableWomen: availableWomen,
      courts: finalCourts
    };

    console.log('Processed data:', currentData);

    // Show manual match setup
    setupManualMatchInterface(currentData);

    // ADDED: Restore valid manual matches
    restoreValidManualMatches(preservedManualMatches, activePlayers);

    // Keep the save
    saveDataToStorage();

    // Instead of showing manual match section, automatically generate matches
    setTimeout(() => {
      processMatchesWithManualSetup();
      // Then scroll to the results after matches are generated
      setTimeout(() => {
        scrollToElement('matches');
      }, 500);
    }, 100);
  }

// NEW: use modal instead of browser confirm (except for set 6)
  if (setHasMatches && currentSetNum < 6) {
    showRegenerationModal(
      currentSetNum,
      function rerunCurrent() {
        // Re-run this set
        continueProcessing();
      },
      function cancelAll() {
        // Cancel: do nothing
      }
    );
    return; // stop here; modal callbacks will continue
  }

  // normal path: either no prior matches, or it's set 6
  continueProcessing();
}

function restoreValidManualMatches(preservedMatches, activePlayers) {
  if (!preservedMatches || preservedMatches.length === 0) return;
  
  const activePlayerNames = activePlayers.map(p => p.name);
  const validManualMatches = [];
  
  // Check each preserved manual match for validity
  preservedMatches.forEach(match => {
    // Check if all players in the match are still active (not sitting off or resting)
    const allPlayersStillActive = [...match.team1, ...match.team2].every(player => 
      activePlayerNames.includes(player.name)
    );
    
    // Check if the court is still available
    const courtStillAvailable = availableCourts.includes(match.court);
    
    if (allPlayersStillActive && courtStillAvailable) {
      validManualMatches.push(match);
      
      // Mark players as excluded in the interface
      [...match.team1, ...match.team2].forEach(player => {
        const playerElement = document.querySelector(`[data-player-name="${player.name}"]`);
        if (playerElement) {
          playerElement.classList.add('excluded');
        }
      });
      
      // Mark court as excluded
      const courtElement = document.querySelector(`[data-court="${match.court}"]`);
      if (courtElement) {
        courtElement.classList.add('excluded');
      }
    } else {
      // Log why the match was not restored
      if (!allPlayersStillActive) {
        console.log(`Manual match on Court ${match.court} not restored: one or more players are now sitting off or resting`);
      }
      if (!courtStillAvailable) {
        console.log(`Manual match on Court ${match.court} not restored: court no longer available`);
      }
    }
  });
  
  // Update the global manual matches array
  manualMatches = validManualMatches;
  
  // Update the display
  updateManualMatchDisplay();
  
  if (validManualMatches.length > 0) {
    console.log(`Restored ${validManualMatches.length} valid manual matches`);
    
    // Show a brief notification
    const notification = document.createElement('div');
    notification.style.cssText = `
      position: fixed;
      top: 50px;
      right: 20px;
      background: #28a745;
      color: white;
      padding: 12px 20px;
      border-radius: 5px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      z-index: 10000;
      font-weight: bold;
    `;
    notification.textContent = `‚úì Restored ${validManualMatches.length} manual match${validManualMatches.length > 1 ? 'es' : ''}`;
    document.body.appendChild(notification);
    
    setTimeout(() => {
      notification.style.opacity = '0';
      notification.style.transition = 'opacity 0.5s';
      setTimeout(() => notification.remove(), 500);
    }, 3000);
  }
}
 
// Manual match setup functions
function setupManualMatchInterface(data) {
  const playerGrid = document.getElementById('manualPlayerGrid');
  const courtGrid = document.getElementById('courtGrid');
  
  // Clear previous setup
  playerGrid.innerHTML = '';
  courtGrid.innerHTML = '';
  manualMatches = [];
  updateManualMatchDisplay();
  
  // Populate available players
  const allPlayers = [];
  data.availableMen.forEach(p => allPlayers.push({...p, gender: 'M'}));
  data.availableWomen.forEach(p => allPlayers.push({...p, gender: 'F'}));
  
  allPlayers.sort((a, b) => {
    if (b.grade !== a.grade) return b.grade - a.grade;
    return a.name.localeCompare(b.name);
  });
  
  allPlayers.forEach(player => {
    const playerDiv = document.createElement('div');
    playerDiv.className = 'manual-player-item';
    playerDiv.innerHTML = `${player.name} (${translateGrade(player.grade)})`;
    playerDiv.dataset.playerName = player.name;
    playerDiv.dataset.playerGrade = player.grade;
    playerDiv.dataset.playerGender = player.gender;
    
    playerDiv.addEventListener('click', () => selectPlayerForManualMatch(playerDiv, player));
    playerGrid.appendChild(playerDiv);
  });
  
 // Populate available courts
data.courts.forEach(courtData => {
  const courtDiv = document.createElement('div');
  courtDiv.className = 'court-option';
  courtDiv.innerHTML = `Court ${courtData.court}`;
  courtDiv.dataset.court = courtData.court;
  
  courtDiv.addEventListener('click', () => selectCourtForManualMatch(courtDiv, courtData.court));
  courtGrid.appendChild(courtDiv);
});
}

function selectPlayerForManualMatch(element, player) {
  if (element.classList.contains('excluded')) return;
  
  if (element.classList.contains('selected')) {
    // Deselect player
    element.classList.remove('selected');
    selectedManualPlayers = selectedManualPlayers.filter(p => p.name !== player.name);
    removePlayerFromTeams(player.name);
  } else {
    // Select player (max 4)
    if (selectedManualPlayers.length >= 4) {
      alert('Maximum 4 players can be selected for a match');
      return;
    }
    
    element.classList.add('selected');
    selectedManualPlayers.push(player);
    addPlayerToTeam(player);
  }
  
  updateTeamDisplay();
  updateAddMatchButton();
}

function addPlayerToTeam(player) {
  if (manualTeam1.length < 2) {
    manualTeam1.push(player);
  } else {
    manualTeam2.push(player);
  }
}

function removePlayerFromTeams(playerName) {
  manualTeam1 = manualTeam1.filter(p => p.name !== playerName);
  manualTeam2 = manualTeam2.filter(p => p.name !== playerName);
}

function updateTeamDisplay() {
  const team1Div = document.getElementById('team1Players');
  const team2Div = document.getElementById('team2Players');
  
  team1Div.innerHTML = manualTeam1.map(p => 
`<div class="team-player">${p.name} (${translateGrade(p.grade)}, ${p.gender})</div>`
  ).join('');
  
  team2Div.innerHTML = manualTeam2.map(p => 
    `<div class="team-player">${p.name} (${translateGrade(p.grade)}, ${p.gender})</div>`
  ).join('');
  
  // Update team slot styling
  document.getElementById('team1Slot').classList.toggle('has-players', manualTeam1.length > 0);
  document.getElementById('team2Slot').classList.toggle('has-players', manualTeam2.length > 0);
}

function selectCourtForManualMatch(element, court) {
  if (element.classList.contains('excluded')) return;
  
  // Clear previous selection
  document.querySelectorAll('.court-option').forEach(el => el.classList.remove('selected'));
  
  // Select new court
  element.classList.add('selected');
  selectedCourt = court;
  updateAddMatchButton();
}

function updateAddMatchButton() {
  const addBtn = document.getElementById('addManualMatch');
  const canAdd = selectedManualPlayers.length === 4 && 
                 manualTeam1.length === 2 && 
                 manualTeam2.length === 2 && 
                 selectedCourt !== null;
  
  addBtn.disabled = !canAdd;
  
  if (canAdd) {
    addBtn.textContent = `Add Match: Court ${selectedCourt}`;
  } else {
    addBtn.textContent = 'Add Manual Match';
  }
}

function addManualMatch() {
  if (selectedManualPlayers.length !== 4 || !selectedCourt) return;
  
  // Determine match format
  const team1Men = manualTeam1.filter(p => p.gender === 'M').length;
  const team1Women = manualTeam1.filter(p => p.gender === 'F').length;
  const team2Men = manualTeam2.filter(p => p.gender === 'M').length;
  const team2Women = manualTeam2.filter(p => p.gender === 'F').length;
  
  let format;
  if (team1Men === 1 && team1Women === 1 && team2Men === 1 && team2Women === 1) {
    format = "Mixed Doubles";
  } else if (team1Men === 2 && team2Men === 2) {
    format = "Same-Sex Doubles (Men)";
  } else if (team1Women === 2 && team2Women === 2) {
    format = "Same-Sex Doubles (Women)";
  } else {
    format = "Mixed Gender";
  }
  
  const manualMatch = {
    court: selectedCourt,
    team1: [...manualTeam1],
    team2: [...manualTeam2],
    format: format,
    note: "Manual Setup",
    isManual: true
  };
  
  manualMatches.push(manualMatch);
  
  // Mark players as excluded
  selectedManualPlayers.forEach(player => {
    const playerElement = document.querySelector(`[data-player-name="${player.name}"]`);
    if (playerElement) {
      playerElement.classList.remove('selected');
      playerElement.classList.add('excluded');
    }
  });
  
  // Mark court as excluded
  const courtElement = document.querySelector(`[data-court="${selectedCourt}"]`);
  if (courtElement) {
    courtElement.classList.remove('selected');
    courtElement.classList.add('excluded');
  }
  
  // Clear selection
  selectedManualPlayers = [];
  selectedCourt = null;
  manualTeam1 = [];
  manualTeam2 = [];
  
  updateTeamDisplay();
  updateAddMatchButton();
  updateManualMatchDisplay();
saveDataToStorage();
  
  console.log(`Manual match added: Court ${manualMatch.court} - ${format}`);
}

function updateManualMatchDisplay() {
  const listDiv = document.getElementById('manualMatchesList');
  
  if (manualMatches.length === 0) {
    listDiv.innerHTML = '<p style="color: #666; font-style: italic;">No manual matches set up yet.</p>';
    return;
  }
  
  let html = '<h4>Manual Matches:</h4>';
  
  manualMatches.forEach((match, index) => {
  const team1Str = match.team1.map(p => `${p.name} (${translateGrade(p.grade)})`).join(', ');
  const team2Str = match.team2.map(p => `${p.name} (${translateGrade(p.grade)})`).join(', ');
    
    html += `
      <div class="manual-match-item">
        <div class="manual-match-details">
          <div class="manual-match-court">Court ${match.court}</div>
          <div class="manual-match-teams">${team1Str} vs ${team2Str}</div>
          <div style="font-size: 12px; color: #666;">${match.format}</div>
        </div>
        <button class="danger" onclick="removeManualMatch(${index})">Remove</button>
      </div>
    `;
  });
  
  listDiv.innerHTML = html;
}

function removeManualMatch(index) {
  const removedMatch = manualMatches[index];
  
  // Restore players as available
  [...removedMatch.team1, ...removedMatch.team2].forEach(player => {
    const playerElement = document.querySelector(`[data-player-name="${player.name}"]`);
    if (playerElement) {
      playerElement.classList.remove('excluded');
    }
  });
  
  // Restore court as available
  const courtElement = document.querySelector(`[data-court="${removedMatch.court}"]`);
  if (courtElement) {
    courtElement.classList.remove('excluded');
  }
  
  // FIND AND UNLOCK the corresponding match in currentMatches
  if (currentMatches) {
    const matchIndex = currentMatches.findIndex(m => 
      m.court === removedMatch.court &&
      m.team1.length === removedMatch.team1.length &&
      m.team1.every((p, i) => p.name === removedMatch.team1[i].name)
    );
    
    if (matchIndex !== -1) {
      currentMatches[matchIndex].isManual = false;
    }
  }
  
  manualMatches.splice(index, 1);
  updateManualMatchDisplay();
  
  // Refresh the display to show it's no longer protected
  if (currentMatches && currentMatches.length > 0) {
    refreshDisplay();
  }
  
  console.log(`Manual match removed: Court ${removedMatch.court}`);
}

function clearManualSetup() {
  // Clear all selections
  document.querySelectorAll('.manual-player-item').forEach(el => {
    el.classList.remove('selected', 'excluded');
  });
  document.querySelectorAll('.court-option').forEach(el => {
    el.classList.remove('selected', 'excluded');
  });
  
  selectedManualPlayers = [];
  selectedCourt = null;
  manualTeam1 = [];
  manualTeam2 = [];
  
  updateTeamDisplay();
  updateAddMatchButton();
}

// Event handlers for manual match setup
document.getElementById('toggleManualSetup').addEventListener('click', function() {
  const panel = document.getElementById('manualSetupPanel');
  const isVisible = panel.style.display !== 'none';
  
  panel.style.display = isVisible ? 'none' : 'block';
  this.textContent = isVisible ? 'Setup Manual Match' : 'Hide Manual Setup';
});

document.getElementById('addManualMatch').addEventListener('click', addManualMatch);
document.getElementById('clearManualSetup').addEventListener('click', clearManualSetup);

// Generate matches button
document.getElementById('generateMatches').addEventListener('click', () => {
  processMatchesWithManualSetup();
  // Scroll to results section after a brief delay
  setTimeout(() => {
    scrollToElement('matches');
  }, 500); // Slightly longer delay to allow for match generation
});

function processMatchesWithManualSetup() {
  // FIXED: Use live playerRows data instead of stale currentData
  const activePlayers = playerRows.filter(p => 
    p.name && p.name.trim() !== '' && 
    p.grade !== '' && 
    p.gender !== '' && 
    !p.resting && 
    !p.so
  );
  
  const availableMen = activePlayers.filter(p => p.gender === 'M');
  const availableWomen = activePlayers.filter(p => p.gender === 'F');
  
  // Remove manual match players from available pools
  const excludedPlayers = [];
  const excludedCourts = [];
  
  manualMatches.forEach(match => {
    match.team1.forEach(p => excludedPlayers.push(p.name));
    match.team2.forEach(p => excludedPlayers.push(p.name));
    excludedCourts.push(match.court);
  });
  
  // Filter out excluded players - NOW using fresh data from playerRows
  const adjustedData = {
    ...currentData,
    availableMen: availableMen.filter(p => !excludedPlayers.includes(p.name)),
    availableWomen: availableWomen.filter(p => !excludedPlayers.includes(p.name)),
    courts: currentData.courts.filter(c => !excludedCourts.includes(c.court))
  };

  
  console.log(`Excluded ${excludedPlayers.length} players and ${excludedCourts.length} courts for manual matches`);
  
  const totalRemainingPlayers = adjustedData.availableMen.length + adjustedData.availableWomen.length;
  const remainder = totalRemainingPlayers % 4;
  
  if (remainder === 0) {
 
 const result = generateMatches(adjustedData);
// Keep the original complete player lists, but add the sorted versions
currentData.sortedMen = result.sortedData.sortedMen;
currentData.sortedWomen = result.sortedData.sortedWomen;
// Combine manual matches with newly generated matches

const combinedMatches = [...manualMatches, ...result.matches];
currentMatches = combinedMatches;
displayResults(currentData, combinedMatches);
} else {
  alert(`Cannot proceed: ${remainder} players remaining after manual matches. Need multiple of 4.`);
}
}

// Match generation functions (from original code)
// Original processMatches function (for when no manual matches)

function generateMatches(dataToUse) {
  log("=== MAIN MATCH PROCESSING STARTED ===");
  log("Current set number: " + document.getElementById('setNumberSelector').value);
  log("Format preference: " + dataToUse.setFormatPreference);
  log("Total players: " + (dataToUse.availableMen.length + dataToUse.availableWomen.length));
  log("Available courts: " + dataToUse.courts.length);
  
// Check for Perfect 16 first
  if (detectPerfect16Scenario()) {
    const perfect16Matches = generatePerfect16Matches(parseInt(document.getElementById('setNumberSelector').value));
    if (perfect16Matches) {
      // Apply court preferences to Perfect 16 matches
      const courtOptimizedMatches = processCourtPreferences(dataToUse, perfect16Matches);
      currentMatches = courtOptimizedMatches;
      displayResults(dataToUse, courtOptimizedMatches);
      return;
    } else {
const currentSetNum = parseInt(document.getElementById('setNumberSelector').value);
    if (currentSetNum === 6) {
        log("=== EXITING PERFECT 16 MODE - SWITCHING TO NORMAL ALGORITHMS ===");
    }
      log("Perfect 16 failed, falling back to normal algorithm");
    }
  }
  
  log("=== STARTING MATCH FORMATION ===");
  
log(">>> Phase 1: Sorting and mixing players");
const sortedData = sortPlayers(dataToUse);
log("<<< Phase 1 complete: Players sorted and mixed");

log(">>> Phase 2: Forming initial matches");
  const matches = formMatchesStrict(sortedData);
  log("<<< Phase 2 complete: " + matches.length + " matches created");
  
  log(">>> Phase 3: Balancing all matches");
const partiallyBalanced = matches.map(match => balanceTeamsIfNeeded(match));
const balancedMatches = balanceIndividualMatches(sortedData, partiallyBalanced);
log("<<< Phase 3 complete: All matches balanced");
 
log(">>> Phase 4: Competitiveness optimization");
  const competitiveMatches = fixUncompetitiveMatches(sortedData, balancedMatches);
  log("<<< Phase 4 complete");
  
  log(">>> Phase 5: Auto-fixing repeat partnerships");
  const optimizedMatches = autoFixRepeatPartnerships(sortedData, competitiveMatches);
  log("<<< Phase 5 complete");
  
  log(">>> Phase 6: Auto-fixing repeat opponents");
  const opponentOptimizedMatches = autoFixRepeatOpponents(sortedData, optimizedMatches);
  log("<<< Phase 6 complete");

  log(">>> Phase 7: Auto-fixing plus/minus imbalances");
  const plusMinusOptimizedMatches = autoFixPlusMinusImbalances(sortedData, opponentOptimizedMatches);
  log("<<< Phase 7 complete");

  log(">>> Phase 8: Processing court preferences");
  const courtOptimizedMatches = processCourtPreferences(sortedData, plusMinusOptimizedMatches);
  log("<<< Phase 8 complete");
  
  
  log("=== MAIN MATCH PROCESSING COMPLETE ===");

 // Merge manual matches back in at their original positions
const matchesWithManualFlags = courtOptimizedMatches.map(match => {
  const manualMatch = manualMatches.find(m => 
    m.court === match.court &&
    m.team1.length === match.team1.length &&
    m.team1.every((p, i) => p.name === match.team1[i].name)
  );
  return manualMatch ? { ...match, isManual: true } : match;
});
return { sortedData, matches: matchesWithManualFlags };
}

// New function for processing with adjusted data (after manual matches)


function mixCourts(courts, setNumber) {
  if (!courts || courts.length === 0 || setNumber === 1) {
    return courts; // Set 1: use original order exactly as selected
  }
  
  // Separate grass courts from hard courts
  const grassCourts = courts.filter(c => !c.court.toString().toUpperCase().startsWith('H'));
  const hardCourts = courts.filter(c => c.court.toString().toUpperCase().startsWith('H'));
  
  // Only shuffle grass courts if we have more than 1
  if (grassCourts.length <= 1) {
    return courts; // No mixing needed
  }
  
  // Shuffle grass courts randomly
  const shuffledGrassCourts = [...grassCourts];
  for (let i = shuffledGrassCourts.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [shuffledGrassCourts[i], shuffledGrassCourts[j]] = [shuffledGrassCourts[j], shuffledGrassCourts[i]];
  }
  
  log(`Court mixing: Randomly shuffled ${grassCourts.length} grass courts for Set ${setNumber}`);
  log(`Original grass order: ${grassCourts.map(c => c.court).join(', ')}`);
  log(`Shuffled grass order: ${shuffledGrassCourts.map(c => c.court).join(', ')}`);
  
  // Recombine: shuffled grass courts first, then hard courts as backup
  const mixedCourts = [...shuffledGrassCourts, ...hardCourts];
  
  // Restore priority numbering
  return mixedCourts.map((court, index) => ({
    priority: index + 1,
    court: court.court
  }));
}

function sortPlayers(data) {
  // Simple grade-only sort (preserves input order within grade)
  const gradeOnlySort = (a, b) => {
    return b.grade - a.grade; // Just sort by grade, maintains input order within grade
  };

  // Custom sort function that considers both grade and +/-
  const gradeAndPlusMinusSort = (a, b) => {
    // First sort by grade (highest first)
    if (b.grade !== a.grade) {
      return b.grade - a.grade;
    }
    
    // Within same grade, sort by +/- 
    const aValue = a.plusMinus === '+' ? 1 : (a.plusMinus === '-' ? -1 : 0);
    const bValue = b.plusMinus === '+' ? 1 : (b.plusMinus === '-' ? -1 : 0);
    
    return bValue - aValue; // Higher value first
  };

  // Get set number and format
  const setNumber = parseInt(document.getElementById('setNumberSelector').value);
  const currentFormat = document.getElementById('formatSelector').value;
  
  // Check if this is the first mixed doubles set
  let isFirstMixedSet = false;
  if (currentFormat === "Mixed" && setNumber > 1) {
    isFirstMixedSet = true;
    for (let s = 1; s < setNumber; s++) {
      if (allSetsData[s] && allSetsData[s].data && 
          allSetsData[s].data.setFormatPreference === "Mixed") {
        isFirstMixedSet = false;
        break;
      }
    }
  }

  // Choose which sorting to use based on set number
  let sortedMen, sortedWomen;

  // All sets: Sort by grade AND +/-
  sortedMen = data.availableMen.slice().sort(gradeAndPlusMinusSort);
  sortedWomen = data.availableWomen.slice().sort(gradeAndPlusMinusSort);
  log("Set " + setNumber + ": Sorting by grade and +/-");

  /// === Mixing step ===
  let mixedMen, mixedWomen;
  
  if (setNumber === 1 || setNumber === 4 || isFirstMixedSet) {
    // Sets 1, 4, and first mixed doubles: Use +/- sorted order (no A/B mixing)
    mixedMen = sortedMen.slice();
    mixedWomen = sortedWomen.slice();
    if (isFirstMixedSet) {
      log("First Mixed Doubles Set: Using +/- sorting without A/B mixing");
    } else {
      log("Set " + setNumber + ": Using +/- sorting without A/B mixing");
    }
  } else if (MIXING_MODE === "ab-smart") {
    // Set 3+: Apply A/B mixing within each grade
    mixedMen = [];
    mixedWomen = [];
    
    // Mix men by grade
    for (let grade = 5; grade >= 1; grade--) {
      const menAtGrade = sortedMen.filter(p => p.grade === grade);
      if (menAtGrade.length > 0) {
        const mixedGrade = mixABSmart(menAtGrade, setNumber);
        mixedMen.push(...mixedGrade);
      }
    }
    
    // Mix women by grade  
    for (let grade = 5; grade >= 1; grade--) {
      const womenAtGrade = sortedWomen.filter(p => p.grade === grade);
      if (womenAtGrade.length > 0) {
        const mixedGrade = mixABSmart(womenAtGrade, setNumber);
        mixedWomen.push(...mixedGrade);
      }
    }
    
    log("Applied A/B Smart Mixing WITHIN GRADES for Set " + setNumber);
  } else {
    // Torus drift fallback (only used if MIXING_MODE = "torus")
    const drift = Math.max(0, setNumber - 1);
    function rotatePlayersTorus(arr, drift) {
      const n = arr.length; if (n <= 1) return arr.slice();
      const k = ((drift % n) + n) % n;
      return arr.slice(k).concat(arr.slice(0, k));
    }
    mixedMen = rotatePlayersTorus(sortedMen.slice(), drift);
    mixedWomen = rotatePlayersTorus(sortedWomen.slice(), drift);
    log("Applied Torus Drift rotation (drift = " + drift + ") for Set " + setNumber);
  }

  // Logging after mixing
  log("=== SORTED PLAYERS (after mixing) ===");
  
  // Detailed logging for each set to see sorting effects
  log(`=== DETAILED SET ${setNumber} PLAYER ORDER ===`);

  // Log men by grade
  for (let grade = 5; grade >= 1; grade--) {
    const menAtGrade = mixedMen.filter(p => p.grade === grade);
    if (menAtGrade.length > 0) {
      log(`Grade ${translateGrade(grade)} MEN (${menAtGrade.length} total):`);
      menAtGrade.forEach((p, index) => {
        const plusMinus = p.plusMinus || '';
        log(`  ${index + 1}. ${p.name} ${plusMinus ? '(' + plusMinus + ')' : ''}`);
      });
    }
  }

  log("---");

  // Log women by grade  
  for (let grade = 5; grade >= 1; grade--) {
    const womenAtGrade = mixedWomen.filter(p => p.grade === grade);
    if (womenAtGrade.length > 0) {
      log(`Grade ${translateGrade(grade)} WOMEN (${womenAtGrade.length} total):`);
      womenAtGrade.forEach((p, index) => {
        const plusMinus = p.plusMinus || '';
        log(`  ${index + 1}. ${p.name} ${plusMinus ? '(' + plusMinus + ')' : ''}`);
      });
    }
  }
  log("=== END DETAILED PLAYER ORDER ===");
  
  // Original summary logging
  for (let grade = 5; grade >= 1; grade--) {
    const menCount = mixedMen.filter(p => p.grade === grade).length;
    const womenCount = mixedWomen.filter(p => p.grade === grade).length;
    if (menCount > 0 || womenCount > 0) {
      log("Grade " + translateGrade(grade) + ": " + menCount + " men, " + womenCount + " women");
    }
  }

  // Return with mixed lists
  return { ...data, sortedMen: mixedMen, sortedWomen: mixedWomen };
}

function formMatchesStrict(data) {
  log("=== STRICT MATCH FORMATION ===");
  
  if (data.setFormatPreference === "Mixed") {
    return formMixedDoublesMatches(data);
  } else {
    return formSameSexDoublesMatches(data);
  }
}

function formMixedDoublesMatches(data) {
  log("Using Mixed Doubles Logic");
  
  const matches = [];
  const assigned = new Set();
  let courtIndex = 0;

  const createMatch = (team1, team2, format, note) => {
    if (courtIndex >= data.courts.length) {
      log("ERROR: No more courts available");
      return null;
    }

    const t1Men = team1.filter(p => data.sortedMen.find(m => m.name === p.name)).length;
    const t1Women = team1.filter(p => data.sortedWomen.find(w => w.name === p.name)).length;
    const t2Men = team2.filter(p => data.sortedMen.find(m => m.name === p.name)).length;
    const t2Women = team2.filter(p => data.sortedWomen.find(w => w.name === p.name)).length;

    if ((t1Men === 2 && t1Women === 0 && t2Men === 0 && t2Women === 2) ||
        (t1Men === 0 && t1Women === 2 && t2Men === 2 && t2Women === 0)) {
      log("ERROR: Attempted prohibited 2M vs 2W match");
      return null;
    }

    const court = data.courts[courtIndex].court;
    courtIndex++;

    team1.forEach(p => assigned.add(p.name));
    team2.forEach(p => assigned.add(p.name));

    log("Created match on Court " + court + ": " + 
        team1.map(p => p.name + "(" + p.grade + ")").join(",") + " vs " +
        team2.map(p => p.name + "(" + p.grade + ")").join(",") + " - " + format);

    return { court, team1, team2, format, note };
  };

  for (let targetGrade = 5; targetGrade >= 1; targetGrade--) {
    log("=== PROCESSING GRADE " + targetGrade + " ===");
    
    // ENHANCED: Check for cross-grade balancing opportunity first
const unassignedMen = data.sortedMen.filter(p => p.grade === targetGrade && !assigned.has(p.name));
const unassignedWomen = data.sortedWomen.filter(p => p.grade === targetGrade && !assigned.has(p.name));
const lowerMen = data.sortedMen.filter(p => p.grade === (targetGrade - 1) && !assigned.has(p.name));
const lowerWomen = data.sortedWomen.filter(p => p.grade === (targetGrade - 1) && !assigned.has(p.name));

// If we have exactly 1M+1W of current grade and 1M+1W of lower grade, create balanced match
if (unassignedMen.length === 1 && unassignedWomen.length === 1 && 
    lowerMen.length >= 1 && lowerWomen.length >= 1) {
  const match = createMatch(
    [unassignedMen[0], lowerWomen[0]],
    [lowerMen[0], unassignedWomen[0]],
    "Mixed Doubles",
    "Cross-grade balanced"
  );
  if (match) {
    matches.push(match);
    continue; // Process next grade
  }
}

// Normal in-grade processing
while (true) {
  const currentMen = data.sortedMen.filter(p => p.grade === targetGrade && !assigned.has(p.name));
  const currentWomen = data.sortedWomen.filter(p => p.grade === targetGrade && !assigned.has(p.name));
  
  if (currentMen.length >= 2 && currentWomen.length >= 2) {
    const match = createMatch(
      [currentMen[0], currentWomen[0]],
      [currentMen[1], currentWomen[1]],
      "Mixed Doubles",
      "In-grade"
    );
    if (match) matches.push(match);
  } else {
    break;
  }
}

    log("MANDATORY COMPLETION: All Grade " + targetGrade + " players must be assigned");
    
    let attempts = 0;
    while (attempts < 100) {
      attempts++;
      
      const remainingMen = data.sortedMen.filter(p => p.grade === targetGrade && !assigned.has(p.name));
      const remainingWomen = data.sortedWomen.filter(p => p.grade === targetGrade && !assigned.has(p.name));
      
      if (remainingMen.length === 0 && remainingWomen.length === 0) {
        log("‚úì SUCCESS: ALL Grade " + targetGrade + " players assigned");
        break;
      }

      const lowerMen = data.sortedMen
  .filter(p => p.grade < targetGrade && !assigned.has(p.name))
  .sort((a, b) => b.grade - a.grade); // Sort by grade, highest first

const lowerWomen = data.sortedWomen
  .filter(p => p.grade < targetGrade && !assigned.has(p.name))
  .sort((a, b) => b.grade - a.grade); // Sort by grade, highest first

      log("Attempt " + attempts + ": Grade " + targetGrade + " remaining: " + 
          remainingMen.length + "M + " + remainingWomen.length + "F");
      log("Available lower: " + lowerMen.length + "M + " + lowerWomen.length + "F");

      let matchCreated = false;

      if (remainingMen.length >= 4) {
        const match = createMatch(
          [remainingMen[0], remainingMen[1]],
          [remainingMen[2], remainingMen[3]],
          "Same-Sex Doubles (Men)",
          "Mandatory completion"
        );
        if (match) { matches.push(match); matchCreated = true; }
      }
      else if (remainingWomen.length >= 4) {
        const match = createMatch(
          [remainingWomen[0], remainingWomen[1]],
          [remainingWomen[2], remainingWomen[3]],
          "Same-Sex Doubles (Women)",
          "Mandatory completion"
        );
        if (match) { matches.push(match); matchCreated = true; }
      }
      else if (remainingMen.length === 3 && remainingWomen.length >= 1) {
        const match = createMatch(
          [remainingMen[0], remainingWomen[0]],
          [remainingMen[1], remainingMen[2]],
          "Mixed Gender",
          "Mandatory completion 3M+1W"
        );
        if (match) { matches.push(match); matchCreated = true; }
      }
      else if (remainingWomen.length === 3 && remainingMen.length >= 1) {
        const match = createMatch(
          [remainingMen[0], remainingWomen[0]],
          [remainingWomen[1], remainingWomen[2]],
          "Mixed Gender",
          "Mandatory completion 1M+3W"
        );
        if (match) { matches.push(match); matchCreated = true; }
      }
       else if (remainingMen.length >= 2 && lowerWomen.length >= 2) {
        const match = createMatch(
          [remainingMen[0], lowerWomen[0]],
          [remainingMen[1], lowerWomen[1]],
          "Mixed Doubles",
          "Cross-grade completion"
        );
        if (match) { matches.push(match); matchCreated = true; }
      }
      else if (remainingMen.length === 3 && lowerMen.length >= 2) {
        const match = createMatch(
          [remainingMen[0], lowerMen[0]],
          [remainingMen[1], lowerMen[1]],
          "Same-Sex Doubles (Men)",
          "Cross-grade 3M: prefer same-sex with lower-grade men"
        );
        if (match) { matches.push(match); matchCreated = true; }
      }
      else if (remainingMen.length >= 2 && lowerMen.length >= 2) {
        const match = createMatch(
          [remainingMen[0], lowerMen[0]],
          [remainingMen[1], lowerMen[1]],
          "Same-Sex Doubles (Men)",
          "Cross-grade 2M: prefer same-sex with lower-grade men"
        );
        if (match) { matches.push(match); matchCreated = true; }
      }
     
      else if (remainingWomen.length >= 2 && lowerMen.length >= 2) {
        const match = createMatch(
          [lowerMen[0], remainingWomen[0]],
          [lowerMen[1], remainingWomen[1]],
          "Mixed Doubles",
          "Cross-grade completion"
        );
        if (match) { matches.push(match); matchCreated = true; }
      }
      else if (remainingMen.length >= 1 && lowerMen.length >= 3) {
        const match = createMatch(
          [remainingMen[0], lowerMen[0]],
          [lowerMen[1], lowerMen[2]],
          "Same-Sex Doubles (Men)",
          "Cross-grade completion"
        );
        if (match) { matches.push(match); matchCreated = true; }
      }
      else if (remainingWomen.length >= 1 && lowerWomen.length >= 1 && lowerMen.length >= 2) {
        const match = createMatch(
          [lowerMen[0], remainingWomen[0]],
          [lowerMen[1], lowerWomen[0]],
          "Mixed Doubles",
          "Cross-grade completion"
        );
        if (match) { matches.push(match); matchCreated = true; }
      }
      else if (remainingWomen.length >= 1 && lowerWomen.length >= 3) {
        const match = createMatch(
          [remainingWomen[0], lowerWomen[0]],
          [lowerWomen[1], lowerWomen[2]],
          "Same-Sex Doubles (Women)",
          "Cross-grade completion"
        );
        if (match) { matches.push(match); matchCreated = true; }
      }
      else if (remainingMen.length >= 1 && lowerMen.length >= 1 && lowerWomen.length >= 2) {
        const match = createMatch(
          [remainingMen[0], lowerWomen[0]],
          [lowerMen[0], lowerWomen[1]],
          "Mixed Doubles",
          "Cross-grade completion"
        );
        if (match) { matches.push(match); matchCreated = true; }
      }
      

      if (!matchCreated) {
        log("‚ùå CRITICAL ERROR: Cannot complete Grade " + targetGrade);
        log("Remaining target players: " + 
            remainingMen.map(p => p.name).join(",") + " | " + 
            remainingWomen.map(p => p.name).join(","));
        log("Available lower players: " + lowerMen.length + "M + " + lowerWomen.length + "F");
        break;
      }
    }
  }

  log("=== FINAL CLEANUP PHASE ===");
  let cleanupAttempts = 0;
  while (cleanupAttempts < 20) {
    cleanupAttempts++;
    
    const allUnassignedMen = data.sortedMen.filter(p => !assigned.has(p.name));
    const allUnassignedWomen = data.sortedWomen.filter(p => !assigned.has(p.name));
    
    if (allUnassignedMen.length === 0 && allUnassignedWomen.length === 0) {
      log("‚úì CLEANUP SUCCESS: All players assigned");
      break;
    }
    
    log("Cleanup attempt " + cleanupAttempts + ": " + allUnassignedMen.length + "M + " + allUnassignedWomen.length + "W remaining");
    
    let cleanupMatchCreated = false;
    
    if (allUnassignedMen.length >= 4) {
      const match = createMatch(
        [allUnassignedMen[0], allUnassignedMen[1]],
        [allUnassignedMen[2], allUnassignedMen[3]],
        "Same-Sex Doubles (Men)",
        "Final cleanup"
      );
      if (match) { matches.push(match); cleanupMatchCreated = true; }
    }
    else if (allUnassignedWomen.length >= 4) {
      const match = createMatch(
        [allUnassignedWomen[0], allUnassignedWomen[1]],
        [allUnassignedWomen[2], allUnassignedWomen[3]],
        "Same-Sex Doubles (Women)",
        "Final cleanup"
      );
      if (match) { matches.push(match); cleanupMatchCreated = true; }
    }
    else if (allUnassignedMen.length >= 2 && allUnassignedWomen.length >= 2) {
      const match = createMatch(
        [allUnassignedMen[0], allUnassignedWomen[0]],
        [allUnassignedMen[1], allUnassignedWomen[1]],
        "Mixed Doubles",
        "Final cleanup"
      );
      if (match) { matches.push(match); cleanupMatchCreated = true; }
    }
    else if (allUnassignedMen.length === 3 && allUnassignedWomen.length === 1) {
      const match = createMatch(
        [allUnassignedMen[0], allUnassignedWomen[0]],
        [allUnassignedMen[1], allUnassignedMen[2]],
        "Mixed Gender",
        "Final cleanup 3M+1W"
      );
      if (match) { matches.push(match); cleanupMatchCreated = true; }
    }
    else if (allUnassignedWomen.length === 3 && allUnassignedMen.length === 1) {
      const match = createMatch(
        [allUnassignedMen[0], allUnassignedWomen[0]],
        [allUnassignedWomen[1], allUnassignedWomen[2]],
        "Mixed Gender",
        "Final cleanup 1M+3W"
      );
      if (match) { matches.push(match); cleanupMatchCreated = true; }
    }
    
    if (!cleanupMatchCreated) {
      log("‚ùå CLEANUP FAILED: Cannot form matches from remaining players");
      break;
    }
  }

  const finalUnassignedMen = data.sortedMen.filter(p => !assigned.has(p.name));
  const finalUnassignedWomen = data.sortedWomen.filter(p => !assigned.has(p.name));
  
  log("=== FINAL STATUS ===");
  log("Total matches created: " + matches.length);
  log("Unassigned players: " + (finalUnassignedMen.length + finalUnassignedWomen.length));
  
  if (finalUnassignedMen.length > 0 || finalUnassignedWomen.length > 0) {
    log("‚ùå ERROR: Players remain unassigned!");
    log("Unassigned men: " + finalUnassignedMen.map(p => p.name + "(" + p.grade + ")").join(", "));
    log("Unassigned women: " + finalUnassignedWomen.map(p => p.name + "(" + p.grade + ")").join(", "));
  }

  return matches;
}

function formSameSexDoublesMatches(data) {
  log("Using Same-Sex Doubles Logic");
  
  const matches = [];
  const assigned = new Set();
  let courtIndex = 0;

  const createMatch = (team1, team2, format, note) => {
    if (courtIndex >= data.courts.length) return null;

    const court = data.courts[courtIndex].court;
    courtIndex++;

    team1.forEach(p => assigned.add(p.name));
    team2.forEach(p => assigned.add(p.name));

    log("Created match on Court " + court + ": " + 
        team1.map(p => p.name + "(" + p.grade + ")").join(",") + " vs " +
        team2.map(p => p.name + "(" + p.grade + ")").join(","));

    return { court, team1, team2, format, note };
  };

  for (let targetGrade = 5; targetGrade >= 1; targetGrade--) {
    log("=== PROCESSING GRADE " + targetGrade + " ===");
    
    while (true) {
      const menThisGrade = data.sortedMen.filter(p => p.grade === targetGrade && !assigned.has(p.name));
      if (menThisGrade.length >= 4) {
        const match = createMatch(
          [menThisGrade[0], menThisGrade[1]],
          [menThisGrade[2], menThisGrade[3]],
          "Same-Sex Doubles (Men)", "In-grade"
        );
        if (match) matches.push(match);
      } else break;
    }
    
    while (true) {
      const womenThisGrade = data.sortedWomen.filter(p => p.grade === targetGrade && !assigned.has(p.name));
      if (womenThisGrade.length >= 4) {
        const match = createMatch(
          [womenThisGrade[0], womenThisGrade[1]],
          [womenThisGrade[2], womenThisGrade[3]],
          "Same-Sex Doubles (Women)", "In-grade"
        );
        if (match) matches.push(match);
      } else break;
    }
    
    let attempts = 0;
    while (attempts < 20) {
      attempts++;
      
      const remainingMen = data.sortedMen.filter(p => p.grade === targetGrade && !assigned.has(p.name));
      const remainingWomen = data.sortedWomen.filter(p => p.grade === targetGrade && !assigned.has(p.name));
      
      if (remainingMen.length === 0 && remainingWomen.length === 0) {
        log("‚úì SUCCESS: ALL Grade " + targetGrade + " players assigned");
        break;
      }

const lowerMen = data.sortedMen
  .filter(p => p.grade < targetGrade && !assigned.has(p.name))
  .sort((a, b) => b.grade - a.grade); // Sort by grade, highest first
      
const lowerWomen = data.sortedWomen
  .filter(p => p.grade < targetGrade && !assigned.has(p.name))
  .sort((a, b) => b.grade - a.grade); // Sort by grade, highest first

      let matchCreated = false;

      // Prefer, in order (same-sex): 3+1 (when exactly 3 leftovers), then 2+2, then 1+3.
// Mixed-gender cross-grade is considered only after same-sex options.

// ===== NEW: 3+5 SAME-SEX (MEN) ‚Äî create two balanced matches
const nextGradeMen = lowerMen.filter(p => p.grade === targetGrade - 1);
if (!matchCreated && remainingMen.length === 3 && nextGradeMen.length >= 5) {
  // Match 1: (2 + 2A) vs (2 + 2A)
  const match1 = createMatch(
    [remainingMen[0], lowerMen[0]],
    [remainingMen[1], lowerMen[1]],
    "Same-Sex Doubles (Men)",
    "Cross-grade 3+5 pattern (Match 1 of 2)"
  );
  if (match1) {
    matches.push(match1);
    
    // Match 2: (2 + 2A) vs (2A + 2A)
    const match2 = createMatch(
      [remainingMen[2], lowerMen[2]],
      [lowerMen[3], lowerMen[4]],
      "Same-Sex Doubles (Men)",
      "Cross-grade 3+5 pattern (Match 2 of 2)"
    );
    if (match2) {
      matches.push(match2);
      matchCreated = true;
    }
  }
}

// ===== ORIGINAL 3+1 SAME-SEX (MEN) ‚Äî fallback when fewer than 5 lower players
else if (!matchCreated && remainingMen.length === 3 && lowerMen.length >= 1) {
  const match = createMatch(
    [remainingMen[0], remainingMen[1]],
    [remainingMen[2], lowerMen[0]],
    "Same-Sex Doubles (Men)",
    "Cross-grade 3+1 (preferred for exactly 3 leftovers)"
  );
  if (match) { matches.push(match); matchCreated = true; }
}

// ===== NEW: 3+5 SAME-SEX (WOMEN) ‚Äî create two balanced matches
const nextGradeWomen = lowerWomen.filter(p => p.grade === targetGrade - 1);
if (!matchCreated && remainingWomen.length === 3 && nextGradeWomen.length >= 5) {
  // Match 1: (2 + 2A) vs (2 + 2A)
  const match1 = createMatch(
    [remainingWomen[0], lowerWomen[0]],
    [remainingWomen[1], lowerWomen[1]],
    "Same-Sex Doubles (Women)",
    "Cross-grade 3+5 pattern (Match 1 of 2)"
  );
  if (match1) {
    matches.push(match1);
    
    // Match 2: (2 + 2A) vs (2A + 2A)
    const match2 = createMatch(
      [remainingWomen[2], lowerWomen[2]],
      [lowerWomen[3], lowerWomen[4]],
      "Same-Sex Doubles (Women)",
      "Cross-grade 3+5 pattern (Match 2 of 2)"
    );
    if (match2) {
      matches.push(match2);
      matchCreated = true;
    }
  }
}

// ===== ORIGINAL 3+1 SAME-SEX (WOMEN) ‚Äî fallback when fewer than 5 lower players
else if (!matchCreated && remainingWomen.length === 3 && lowerWomen.length >= 1) {
  const match = createMatch(
    [remainingWomen[0], remainingWomen[1]],
    [remainingWomen[2], lowerWomen[0]],
    "Same-Sex Doubles (Women)",
    "Cross-grade 3+1 (preferred for exactly 3 leftovers)"
  );
  if (match) { matches.push(match); matchCreated = true; }
}

// ===== 2+2 SAME-SEX (MEN) ‚Äî 5+4 vs 5+4 (preferred when >=2 leftovers)
else if (!matchCreated && remainingMen.length >= 2 && lowerMen.length >= 2) {
  const match = createMatch(
    [remainingMen[0], lowerMen[0]],
    [remainingMen[1], lowerMen[1]],
    "Same-Sex Doubles (Men)",
    "Cross-grade 2+2 (preferred after 3+1)"
  );
  if (match) { matches.push(match); matchCreated = true; }
}

// ===== 2+2 SAME-SEX (WOMEN)
else if (!matchCreated && remainingWomen.length >= 2 && lowerWomen.length >= 2) {
  const match = createMatch(
    [remainingWomen[0], lowerWomen[0]],
    [remainingWomen[1], lowerWomen[1]],
    "Same-Sex Doubles (Women)",
    "Cross-grade 2+2 (preferred after 3+1)"
  );
  if (match) { matches.push(match); matchCreated = true; }
}

// ===== Mixed-gender completions (only if policy allows), after same-sex options
else if (!matchCreated && remainingMen.length === 3 && remainingWomen.length === 1) {
  const match = createMatch(
    [remainingMen[0], remainingWomen[0]],
    [remainingMen[1], remainingMen[2]],
    "Mixed Gender",
    "3M+1W completion"
  );
  if (match) { matches.push(match); matchCreated = true; }
}
else if (!matchCreated && remainingWomen.length === 3 && remainingMen.length === 1) {
  const match = createMatch(
    [remainingMen[0], remainingWomen[0]],
    [remainingWomen[1], remainingWomen[2]],
    "Mixed Gender",
    "1M+3W completion"
  );
  if (match) { matches.push(match); matchCreated = true; }
}

// ===== Cross-grade Mixed Doubles (after same-sex options, if permitted)
else if (!matchCreated && remainingMen.length >= 2 && lowerWomen.length >= 2) {
  const match = createMatch(
    [remainingMen[0], lowerWomen[0]],
    [remainingMen[1], lowerWomen[1]],
    "Mixed Doubles",
    "Cross-grade mixed completion"
  );
  if (match) { matches.push(match); matchCreated = true; }
}
else if (!matchCreated && remainingWomen.length >= 2 && lowerMen.length >= 2) {
  const match = createMatch(
    [lowerMen[0], remainingWomen[0]],
    [lowerMen[1], remainingWomen[1]],
    "Mixed Doubles",
    "Cross-grade mixed completion"
  );
  if (match) { matches.push(match); matchCreated = true; }
}

// ===== 1+3 SAME-SEX (MEN) ‚Äî last resort for a single leftover
else if (!matchCreated && remainingMen.length >= 1 && lowerMen.length >= 3) {
  const match = createMatch(
    [remainingMen[0], lowerMen[0]],
    [lowerMen[1], lowerMen[2]],
    "Same-Sex Doubles (Men)",
    "Cross-grade 1+3 fallback (last resort)"
  );
  if (match) { matches.push(match); matchCreated = true; }
}

// ===== 1+3 SAME-SEX (WOMEN) ‚Äî last resort
else if (!matchCreated && remainingWomen.length >= 1 && lowerWomen.length >= 3) {
  const match = createMatch(
    [remainingWomen[0], lowerWomen[0]],
    [lowerWomen[1], lowerWomen[2]],
    "Same-Sex Doubles (Women)",
    "Cross-grade 1+3 fallback (last resort)"
  );
  if (match) { matches.push(match); matchCreated = true; }
}

      
      if (!matchCreated) {
        log("Cannot complete Grade " + targetGrade + " - remaining: " + 
            remainingMen.length + "M + " + remainingWomen.length + "F");
        break;
      }
    }
  }

  log("=== FINAL CLEANUP PHASE ===");
  let cleanupAttempts = 0;
  while (cleanupAttempts < 20) {
    cleanupAttempts++;
    
    const allUnassignedMen = data.sortedMen.filter(p => !assigned.has(p.name));
    const allUnassignedWomen = data.sortedWomen.filter(p => !assigned.has(p.name));
    
    if (allUnassignedMen.length === 0 && allUnassignedWomen.length === 0) {
      log("‚úì CLEANUP SUCCESS: All players assigned");
      break;
    }
    
    log("Cleanup attempt " + cleanupAttempts + ": " + allUnassignedMen.length + "M + " + allUnassignedWomen.length + "W remaining");
    
    let cleanupMatchCreated = false;
    
    if (allUnassignedMen.length >= 4) {
      const match = createMatch(
        [allUnassignedMen[0], allUnassignedMen[1]],
        [allUnassignedMen[2], allUnassignedMen[3]],
        "Same-Sex Doubles (Men)",
        "Final cleanup"
      );
      if (match) { matches.push(match); cleanupMatchCreated = true; }
    }
    else if (allUnassignedWomen.length >= 4) {
      const match = createMatch(
        [allUnassignedWomen[0], allUnassignedWomen[1]],
        [allUnassignedWomen[2], allUnassignedWomen[3]],
        "Same-Sex Doubles (Women)",
        "Final cleanup"
      );
      if (match) { matches.push(match); cleanupMatchCreated = true; }
    }
    else if (allUnassignedMen.length >= 2 && allUnassignedWomen.length >= 2) {
      const match = createMatch(
        [allUnassignedMen[0], allUnassignedWomen[0]],
        [allUnassignedMen[1], allUnassignedWomen[1]],
        "Mixed Doubles",
        "Final cleanup"
      );
      if (match) { matches.push(match); cleanupMatchCreated = true; }
    }
    else if (allUnassignedMen.length === 3 && allUnassignedWomen.length === 1) {
      const match = createMatch(
        [allUnassignedMen[0], allUnassignedWomen[0]],
        [allUnassignedMen[1], allUnassignedMen[2]],
        "Mixed Gender",
        "Final cleanup 3M+1W"
      );
      if (match) { matches.push(match); cleanupMatchCreated = true; }
    }
    else if (allUnassignedWomen.length === 3 && allUnassignedMen.length === 1) {
      const match = createMatch(
        [allUnassignedMen[0], allUnassignedWomen[0]],
        [allUnassignedWomen[1], allUnassignedWomen[2]],
        "Mixed Gender",
        "Final cleanup 1M+3W"
      );
      if (match) { matches.push(match); cleanupMatchCreated = true; }
    }
    
    if (!cleanupMatchCreated) {
      log("‚ùå CLEANUP FAILED: Cannot form matches from remaining players");
      break;
    }
  }

  log("=== FINAL STATUS ===");
  log("Total matches created: " + matches.length);
  return matches;
}

function balanceTeamsIfNeeded(match) {
  // Only balance same-sex matches (the problematic ones)
  if (match.format !== "Same-Sex Doubles (Men)" && match.format !== "Same-Sex Doubles (Women)") {
    return match;
  }
  
  const team1Grades = match.team1.map(p => p.grade);
  const team2Grades = match.team2.map(p => p.grade);
  
  // Check for "2 strong vs 2 weak" pattern (grades 4-5 vs grades 1-3)
  const team1Strong = team1Grades.filter(g => g >= 4).length;
  const team2Strong = team2Grades.filter(g => g >= 4).length;
  
  // If one team has 2 strong and other has 0 strong, swap one player
  if (team1Strong === 2 && team2Strong === 0) {
    // Swap the weaker player from team1 with stronger player from team2
    const weakerInTeam1 = team1Grades[0] < team1Grades[1] ? 0 : 1;
    const strongerInTeam2 = team2Grades[0] > team2Grades[1] ? 0 : 1;
    
    const tempPlayer = match.team1[weakerInTeam1];
    match.team1[weakerInTeam1] = match.team2[strongerInTeam2];
    match.team2[strongerInTeam2] = tempPlayer;
    
    log("‚öñÔ∏è Balanced teams: Swapped " + tempPlayer.name + " ‚Üî " + match.team1[weakerInTeam1].name);
  }
  else if (team1Strong === 0 && team2Strong === 2) {
    // Swap the weaker player from team2 with stronger player from team1
    const weakerInTeam2 = team2Grades[0] < team2Grades[1] ? 0 : 1;
    const strongerInTeam1 = team1Grades[0] > team1Grades[1] ? 0 : 1;
    
    const tempPlayer = match.team2[weakerInTeam2];
    match.team2[weakerInTeam2] = match.team1[strongerInTeam1];
    match.team1[strongerInTeam1] = tempPlayer;
    
    log("‚öñÔ∏è Balanced teams: Swapped " + tempPlayer.name + " ‚Üî " + match.team2[weakerInTeam2].name);
  }
  
  return match;
}

function processCourtPreferences(data, matches) {
  log("=== COURT PREFERENCES ===");
  
  const isHardCourt = (court) => court && court.toString().toUpperCase().startsWith('H');
  const isGrassCourt = (court) => {
    const courtStr = court && court.toString().toUpperCase();
    return courtStr && (courtStr.startsWith('G') || (!courtStr.startsWith('H') && /^\d+$/.test(courtStr)));
  };
  
 const hasNHCPlayer = (match) => {
  const allPlayers = [...match.team1, ...match.team2];
  return allPlayers.some(player => {
    const menPlayer = data.sortedMen ? data.sortedMen.find(p => p.name === player.name) : null;
    const womenPlayer = data.sortedWomen ? data.sortedWomen.find(p => p.name === player.name) : null;
    
    // If not found in sorted arrays, check available arrays
    const menPlayerAvailable = !menPlayer && data.availableMen ? data.availableMen.find(p => p.name === player.name) : null;
    const womenPlayerAvailable = !womenPlayer && data.availableWomen ? data.availableWomen.find(p => p.name === player.name) : null;
    
    const foundPlayer = menPlayer || womenPlayer || menPlayerAvailable || womenPlayerAvailable;
    return foundPlayer && foundPlayer.nhc;
  });
};
  
  const nhcOnHard = [];
  const nonNhcOnGrass = [];
  
  matches.forEach((match, index) => {
    if (isHardCourt(match.court) && hasNHCPlayer(match)) {
      nhcOnHard.push({index, match});
    } else if (isGrassCourt(match.court) && !hasNHCPlayer(match)) {
      nonNhcOnGrass.push({index, match});
    }
  });
  
  const swaps = Math.min(nhcOnHard.length, nonNhcOnGrass.length);
  for (let i = 0; i < swaps; i++) {
    const tempCourt = nhcOnHard[i].match.court;
    matches[nhcOnHard[i].index].court = nonNhcOnGrass[i].match.court;
    matches[nonNhcOnGrass[i].index].court = tempCourt;
    log("Court swap: " + tempCourt + " ‚Üî " + nonNhcOnGrass[i].match.court);
  }
  
  return matches;
}

// Helper function to check if specific partnerships are repeats
function checkSpecificPartnershipsAreRepeats(partnerships, currentSetNum) {
  // partnerships is an array of [{player1: "name1", player2: "name2"}, ...]
  let repeatCount = 0;
  
  for (let partnership of partnerships) {
    const pairKey = [partnership.player1, partnership.player2].sort().join("-");
    
    // Check if this partnership existed in any previous set
    for (let setNum = 1; setNum < currentSetNum; setNum++) {
      if (!allSetsData[setNum] || !allSetsData[setNum].matches) continue;
      
      let found = false;
      for (let match of allSetsData[setNum].matches) {
        // Check team 1
        if (match.team1.length === 2) {
          const historicPair = [match.team1[0].name, match.team1[1].name].sort().join("-");
          if (historicPair === pairKey) {
            repeatCount++;
            found = true;
            break;
          }
        }
        // Check team 2
        if (match.team2.length === 2) {
          const historicPair = [match.team2[0].name, match.team2[1].name].sort().join("-");
          if (historicPair === pairKey) {
            repeatCount++;
            found = true;
            break;
          }
        }
      }
      if (found) break; // Already found this partnership as a repeat
    }
  }
  
  return repeatCount;
}

function checkForRepeatPartnerships(currentSetNumber, currentMatches, silent = false) {
  if (currentSetNumber <= 1) return [];
  
  const repeatPartners = [];
  
  // Get all partnerships from current set
  const currentPartnerships = [];
  currentMatches.forEach((match, matchIndex) => {
    // Team 1 partnership
    if (match.team1.length === 2) {
      currentPartnerships.push({
        matchIndex: matchIndex,
        team: 1,
        players: [match.team1[0].name, match.team1[1].name].sort()
      });
    }
    // Team 2 partnership
    if (match.team2.length === 2) {
      currentPartnerships.push({
        matchIndex: matchIndex,
        team: 2,
        players: [match.team2[0].name, match.team2[1].name].sort()
      });
    }
  });
  
  // Check against all previous sets
  for (let setNum = 1; setNum < currentSetNumber; setNum++) {
    if (!allSetsData[setNum] || !allSetsData[setNum].matches) continue;
    
    const previousMatches = allSetsData[setNum].matches;
    const previousPartnerships = [];
    
    previousMatches.forEach(match => {
      if (match.team1.length === 2) {
        previousPartnerships.push([match.team1[0].name, match.team1[1].name].sort());
      }
      if (match.team2.length === 2) {
        previousPartnerships.push([match.team2[0].name, match.team2[1].name].sort());
      }
    });
    
    // Compare current partnerships with previous ones
    currentPartnerships.forEach(current => {
      previousPartnerships.forEach(previous => {
        if (current.players[0] === previous[0] && current.players[1] === previous[1]) {
          repeatPartners.push({
            matchIndex: current.matchIndex,
            team: current.team,
            players: current.players,
            previousSet: setNum
          });
          if (!silent) {
  log("Repeat partnership found: " + current.players.join(" & ") + " (previously in Set " + setNum + ")");
}
        }
      });
    });
  }

if (repeatPartners.length > 0) {
  if (!silent) {
  log(`Found ${repeatPartners.length} repeat partnerships in initial check`);
}
}
  
  return repeatPartners;
}
function checkForRepeatOpponents(currentSetNumber, currentMatches) {
// üëÄ Track opponent pairs we've already considered in this run
const seenPairs = new Set();


  if (currentSetNumber <= 1) return [];
  
  const repeatOpponents = [];

// temporarily turn off this logging:
// log("Checking for repeat opponents across previous " + Math.min(2, currentSetNumber - 1) + " sets");
  
  // Check previous 2 sets (or fewer if not available)
  const setsToCheck = [];
  for (let setNum = Math.max(1, currentSetNumber - 2); setNum < currentSetNumber; setNum++) {
    if (allSetsData[setNum] && allSetsData[setNum].matches) {
      setsToCheck.push({setNum, matches: allSetsData[setNum].matches});
    }
  }
  
  if (setsToCheck.length === 0) return [];
  
  // For each current match, check if any players were opponents in previous 2 sets
  currentMatches.forEach((currentMatch, currentMatchIndex) => {
    const currentPlayers = [...currentMatch.team1, ...currentMatch.team2];
    
    // Check each pair of players in current match (they are opponents)
    for (let i = 0; i < currentPlayers.length; i++) {
      for (let j = i + 1; j < currentPlayers.length; j++) {
        const player1 = currentPlayers[i];
        const player2 = currentPlayers[j];

    // create a stable key so A vs B = B vs A
    const pairKey = (player1.name < player2.name)
                  ? `${player1.name}‚Äî${player2.name}`
                  : `${player2.name}‚Äî${player1.name}`;

    if (seenPairs.has(pairKey)) {
      continue;           // already handled this pair, skip
    }
    seenPairs.add(pairKey);

        
        // Skip if they're on the same team (partners, not opponents)
        const player1Team = currentMatch.team1.some(p => p.name === player1.name) ? 1 : 2;
        const player2Team = currentMatch.team1.some(p => p.name === player2.name) ? 1 : 2;
        if (player1Team === player2Team) continue;
        
        // Check if these two were opponents in any of the previous sets
        setsToCheck.forEach(({setNum, matches}) => {
          matches.forEach(previousMatch => {
            const prevPlayer1Team = previousMatch.team1.some(p => p.name === player1.name) ? 1 : 
                                   previousMatch.team2.some(p => p.name === player1.name) ? 2 : 0;
            const prevPlayer2Team = previousMatch.team1.some(p => p.name === player2.name) ? 1 : 
                                   previousMatch.team2.some(p => p.name === player2.name) ? 2 : 0;
            
            // If both players were in previous match and on different teams (opponents)
            if (prevPlayer1Team !== 0 && prevPlayer2Team !== 0 && prevPlayer1Team !== prevPlayer2Team) {
              repeatOpponents.push({
                matchIndex: currentMatchIndex,
                player1: player1.name,
                player2: player2.name
              });
              
// Temporarily turn off this log
// log("Repeat opponents found: " + player1.name + " vs " + player2.name + " (previously opponents in Set " + setNum + " - checking last 2 sets)");
            }
          });
        });
      }
    }
  });
  
  return repeatOpponents;
}

function autoFixRepeatPartnerships(data, matches) {
  const currentSetNum = parseInt(document.getElementById('setNumberSelector').value);
  if (currentSetNum <= 1) return matches;
  
  log("=== AUTO-FIXING REPEAT PARTNERSHIPS ===");
  
  // Create a working copy of matches
  const workingMatches = JSON.parse(JSON.stringify(matches));
  
  // Get repeat partnerships
  const repeatPartners = checkForRepeatPartnerships(currentSetNum, workingMatches);
  
log(`Initial check found ${repeatPartners.length} repeat partnerships`);
  
if (repeatPartners.length === 0) {
    log("No repeat partnerships found - no auto-fixes needed");
    return workingMatches;
  }
  
log("Found " + repeatPartners.length + " repeat partnerships to attempt fixing");

// Check if we should skip Phase 2 due to too many repeat partnerships
const repeatLimit = 20;
log("Repeat partnership limit set to: " + repeatLimit);
if (repeatPartners.length > repeatLimit) {
  log("=== REPEAT PARTNERSHIP THRESHOLD EXCEEDED ===");
  log("Found " + repeatPartners.length + " repeat partnerships (>" + repeatLimit + ")");
  log("Skipping Phase 2 inter-match fixes to prevent memory issues");
  log("Phase 1 intra-match fixes will still be attempted");
  log("Remaining repeat partnerships must be resolved manually by operator");
}

// PHASE 1: Try simple intra-match swaps first
log("=== PHASE 1: INTRA-MATCH FIXES ===");
  
repeatPartners.forEach((repeat, repeatIndex) => {
  const matchIndex = repeat.matchIndex;
  const teamNum = parseInt(repeat.team);
  const match = workingMatches[matchIndex];
  const currentTeam = teamNum === 1 ? match.team1 : match.team2;
  const opposingTeam = teamNum === 1 ? match.team2 : match.team1;
  
  log("Attempting intra-match fix for: " + repeat.players.join(" & ") + " (Match " + matchIndex + ", Team " + teamNum + ")");
  
  let fixedInMatch = false;
  
  // Handle Same-Sex matches (original logic)
  if (match.format.includes("Same-Sex")) {
    const beforeCount = checkForRepeatPartnerships(currentSetNum, workingMatches, true).length;
    
    // Try swapping each player in the problematic team with each player in opposing team
    for (let currentPlayerIndex = 0; currentPlayerIndex < currentTeam.length && !fixedInMatch; currentPlayerIndex++) {
      for (let opponentIndex = 0; opponentIndex < opposingTeam.length && !fixedInMatch; opponentIndex++) {
        
        const currentPlayer = currentTeam[currentPlayerIndex];
        const opponentPlayer = opposingTeam[opponentIndex];
        
        // For same-sex matches, players should be same gender, so swap should be safe
        if (getPlayerGender(currentPlayer.name, data) !== getPlayerGender(opponentPlayer.name, data)) {
          continue; // Skip if different genders (shouldn't happen in same-sex match)
        }
        
       // Create a test copy to check the effect of the swap
        const testMatches = JSON.parse(JSON.stringify(workingMatches));
        const testMatch = testMatches[matchIndex];
        const testCurrentTeam = teamNum === 1 ? testMatch.team1 : testMatch.team2;
        const testOpposingTeam = teamNum === 1 ? testMatch.team2 : testMatch.team1;
        
        // Perform the test swap on the copy
        const tempPlayer = testCurrentTeam[currentPlayerIndex];
        testCurrentTeam[currentPlayerIndex] = testOpposingTeam[opponentIndex];
        testOpposingTeam[opponentIndex] = tempPlayer;
        
        // Check the specific partnerships that would be created
        const newPartnerships = [];
        if (testCurrentTeam.length === 2) {
          newPartnerships.push({
            player1: testCurrentTeam[0].name,
            player2: testCurrentTeam[1].name
          });
        }
        if (testOpposingTeam.length === 2) {
          newPartnerships.push({
            player1: testOpposingTeam[0].name,
            player2: testOpposingTeam[1].name
          });
        }
        
        // Check the original partnerships before swap
        const originalPartnerships = [];
        if (currentTeam.length === 2) {
          originalPartnerships.push({
            player1: currentTeam[0].name,
            player2: currentTeam[1].name
          });
        }
        if (opposingTeam.length === 2) {
          originalPartnerships.push({
            player1: opposingTeam[0].name,
            player2: opposingTeam[1].name
          });
        }
        
        const beforeCount = checkSpecificPartnershipsAreRepeats(originalPartnerships, currentSetNum);
        const afterCount = checkSpecificPartnershipsAreRepeats(newPartnerships, currentSetNum);
        
        if (afterCount < beforeCount) {
          // Success! Apply the swap to the real working matches
          currentTeam[currentPlayerIndex] = opponentPlayer;
          opposingTeam[opponentIndex] = currentPlayer;
          
          log("‚úÖ Intra-match fix (Same-Sex): Swapped " + currentPlayer.name + " ‚Üî " + opponentPlayer.name);
          log("  Repeat partnerships reduced from " + beforeCount + " to " + afterCount);
          fixedInMatch = true;
          break;
        }
        // No need to revert since we only tested on a copy
      }
    }
  }
  
  // NEW: Handle Mixed Doubles matches
  else if (match.format === "Mixed Doubles") {
    const beforeCount = checkForRepeatPartnerships(currentSetNum, workingMatches, true).length;
    
    // In Mixed Doubles, we can swap the two men or the two women within the match
    // Get all players from both teams
    const allPlayers = [...match.team1, ...match.team2];
    const menInMatch = allPlayers.filter(p => getPlayerGender(p.name, data) === 'M');
    const womenInMatch = allPlayers.filter(p => getPlayerGender(p.name, data) === 'F');
    
    // Try swapping the two men
    if (menInMatch.length === 2 && !fixedInMatch) {
      // Create a test copy to check the effect of the swap
      const testMatches = JSON.parse(JSON.stringify(workingMatches));
      const testMatch = testMatches[matchIndex];
      
      // Find positions of the two men in the test match
      let man1Team = null, man1Index = null, man2Team = null, man2Index = null;
      
      // Check team 1
      testMatch.team1.forEach((player, index) => {
        if (player.name === menInMatch[0].name) { man1Team = testMatch.team1; man1Index = index; }
        if (player.name === menInMatch[1].name) { man2Team = testMatch.team1; man2Index = index; }
      });
      
      // Check team 2
      testMatch.team2.forEach((player, index) => {
        if (player.name === menInMatch[0].name) { man1Team = testMatch.team2; man1Index = index; }
        if (player.name === menInMatch[1].name) { man2Team = testMatch.team2; man2Index = index; }
      });
      
      // Perform the swap
      if (man1Team && man2Team && man1Index !== null && man2Index !== null) {
        const tempPlayer = man1Team[man1Index];
        man1Team[man1Index] = man2Team[man2Index];
        man2Team[man2Index] = tempPlayer;
        
        const afterCount = checkForRepeatPartnerships(currentSetNum, testMatches).length;
        
        if (afterCount < beforeCount) {
          // Success! Apply the swap to the real working matches
          // Find the same positions in the real match
          let realMan1Team = null, realMan1Index = null, realMan2Team = null, realMan2Index = null;
          
          // Check team 1
          match.team1.forEach((player, index) => {
            if (player.name === menInMatch[0].name) { realMan1Team = match.team1; realMan1Index = index; }
            if (player.name === menInMatch[1].name) { realMan2Team = match.team1; realMan2Index = index; }
          });
          
          // Check team 2
          match.team2.forEach((player, index) => {
            if (player.name === menInMatch[0].name) { realMan1Team = match.team2; realMan1Index = index; }
            if (player.name === menInMatch[1].name) { realMan2Team = match.team2; realMan2Index = index; }
          });
          
          // Apply the swap
          const realTempPlayer = realMan1Team[realMan1Index];
          realMan1Team[realMan1Index] = realMan2Team[realMan2Index];
          realMan2Team[realMan2Index] = realTempPlayer;
          
          log("‚úÖ Intra-match fix (Mixed Doubles - Men): Swapped " + menInMatch[0].name + " ‚Üî " + menInMatch[1].name);
          log("  Repeat partnerships reduced from " + beforeCount + " to " + afterCount);
          fixedInMatch = true;
        }
      }
    }
    
    // Try swapping the two women (if men swap didn't work)
    if (womenInMatch.length === 2 && !fixedInMatch) {
      // Create a test copy to check the effect of the swap
      const testMatches = JSON.parse(JSON.stringify(workingMatches));
      const testMatch = testMatches[matchIndex];
      
      // Find positions of the two women in the test match
      let woman1Team = null, woman1Index = null, woman2Team = null, woman2Index = null;
      
      // Check team 1
      testMatch.team1.forEach((player, index) => {
        if (player.name === womenInMatch[0].name) { woman1Team = testMatch.team1; woman1Index = index; }
        if (player.name === womenInMatch[1].name) { woman2Team = testMatch.team1; woman2Index = index; }
      });
      
      // Check team 2
      testMatch.team2.forEach((player, index) => {
        if (player.name === womenInMatch[0].name) { woman1Team = testMatch.team2; woman1Index = index; }
        if (player.name === womenInMatch[1].name) { woman2Team = testMatch.team2; woman2Index = index; }
      });
      
      // Perform the swap
      if (woman1Team && woman2Team && woman1Index !== null && woman2Index !== null) {
        const tempPlayer = woman1Team[woman1Index];
        woman1Team[woman1Index] = woman2Team[woman2Index];
        woman2Team[woman2Index] = tempPlayer;
        
        const afterCount = checkForRepeatPartnerships(currentSetNum, testMatches).length;
        
        if (afterCount < beforeCount) {
          // Success! Apply the swap to the real working matches
          // Find the same positions in the real match
          let realWoman1Team = null, realWoman1Index = null, realWoman2Team = null, realWoman2Index = null;
          
          // Check team 1
          match.team1.forEach((player, index) => {
            if (player.name === womenInMatch[0].name) { realWoman1Team = match.team1; realWoman1Index = index; }
            if (player.name === womenInMatch[1].name) { realWoman2Team = match.team1; realWoman2Index = index; }
          });
          
          // Check team 2
          match.team2.forEach((player, index) => {
            if (player.name === womenInMatch[0].name) { realWoman1Team = match.team2; realWoman1Index = index; }
            if (player.name === womenInMatch[1].name) { realWoman2Team = match.team2; realWoman2Index = index; }
          });
          
          // Apply the swap
          const realTempPlayer = realWoman1Team[realWoman1Index];
          realWoman1Team[realWoman1Index] = realWoman2Team[realWoman2Index];
          realWoman2Team[realWoman2Index] = realTempPlayer;
          
          log("‚úÖ Intra-match fix (Mixed Doubles - Women): Swapped " + womenInMatch[0].name + " ‚Üî " + womenInMatch[1].name);
          log("  Repeat partnerships reduced from " + beforeCount + " to " + afterCount);
          fixedInMatch = true;
        }
      }
    }
  }
  
  if (!fixedInMatch) {
    log("‚ùå Could not fix intra-match: " + repeat.players.join(" & "));
  }
});
  
  // Check if Phase 1 solved everything
  const remainingRepeats = checkForRepeatPartnerships(currentSetNum, workingMatches);
  if (remainingRepeats.length === 0) {
    log("üéâ Phase 1 resolved all repeat partnerships!");
    return workingMatches;
  }
  
 // PHASE 2: Complex inter-match swaps (original logic)
if (repeatPartners.length <= repeatLimit) {
  log("=== PHASE 2: INTER-MATCH FIXES ===");
  log("Remaining repeats after Phase 1: " + remainingRepeats.length);
  
  // Get set format preference for prioritizing swap types
  const setFormatPreference = data.setFormatPreference;
  
  // Process remaining repeat partnerships with original complex logic
  remainingRepeats.forEach((repeat, repeatIndex) => {
    const matchIndex = repeat.matchIndex;
    const teamNum = parseInt(repeat.team);
    const match = workingMatches[matchIndex];
    const currentTeam = teamNum === 1 ? match.team1 : match.team2;
    const opposingTeam = teamNum === 1 ? match.team2 : match.team1;
    
    log("Attempting inter-match fix for: " + repeat.players.join(" & ") + " (Match " + matchIndex + ", Team " + teamNum + ")");
    
    let fixedInMatch = false;
    
    // Define swap priority based on set format preference
    const swapStrategies = [];
    
    if (setFormatPreference === "Same-Sex") {
      swapStrategies.push(
        { name: "Same grade, same gender", criteria: (p1, p2) => p1.grade === p2.grade && getPlayerGender(p1.name, data) === getPlayerGender(p2.name, data) },
      //  { name: "Adjacent grade, same gender", criteria: (p1, p2) => Math.abs(p1.grade - p2.grade) === 1 && getPlayerGender(p1.name, data) === getPlayerGender(p2.name, data) },
      //  { name: "Same grade, cross gender", criteria: (p1, p2) => p1.grade === p2.grade && getPlayerGender(p1.name, data) !== getPlayerGender(p2.name, data) }
      );
    } else { // Mixed format preference
      swapStrategies.push(
        { name: "Same grade, cross gender", criteria: (p1, p2) => p1.grade === p2.grade && getPlayerGender(p1.name, data) !== getPlayerGender(p2.name, data) },
       // { name: "Adjacent grade, cross gender", criteria: (p1, p2) => Math.abs(p1.grade - p2.grade) === 1 && getPlayerGender(p1.name, data) !== getPlayerGender(p2.name, data) },
       // { name: "Same grade, same gender", criteria: (p1, p2) => p1.grade === p2.grade && getPlayerGender(p1.name, data) === getPlayerGender(p2.name, data) }
      );
    }
    
    // Try swaps with other matches
    for (let strategy of swapStrategies) {
      if (fixedInMatch) break;
      
      log("  Trying inter-match strategy: " + strategy.name);
      
      for (let otherMatchIndex = 0; otherMatchIndex < workingMatches.length && !fixedInMatch; otherMatchIndex++) {
        if (otherMatchIndex === matchIndex) continue;
        
        const otherMatch = workingMatches[otherMatchIndex];
        
        // Try swapping with players from both teams of other matches
        for (let otherTeamNum = 1; otherTeamNum <= 2 && !fixedInMatch; otherTeamNum++) {
          const otherTeam = otherTeamNum === 1 ? otherMatch.team1 : otherMatch.team2;
          
          // Try swapping each player from current team with each player from other team
          for (let currentPlayerIndex = 0; currentPlayerIndex < currentTeam.length && !fixedInMatch; currentPlayerIndex++) {
            for (let otherPlayerIndex = 0; otherPlayerIndex < otherTeam.length && !fixedInMatch; otherPlayerIndex++) {
              
              const currentPlayer = currentTeam[currentPlayerIndex];
              const otherPlayer = otherTeam[otherPlayerIndex];
              
              // Check if this swap meets the current strategy criteria
              if (!strategy.criteria(currentPlayer, otherPlayer)) continue;
              
              // For adjacent grade swaps, ensure balanced teams in both matches
            //  if (strategy.name.includes("Adjacent grade")) {
            //    if (!wouldCreateBalancedTeams(workingMatches, matchIndex, currentPlayerIndex, teamNum, otherPlayerIndex, otherTeamNum, otherMatchIndex)) {
             //     continue;
            //    }
            //  }
              
              // Test the swap
// Check original partnerships that would be affected
const originalPartnerships = [];
if (currentTeam.length === 2) {
  originalPartnerships.push({
    player1: currentTeam[0].name,
    player2: currentTeam[1].name
  });
}
if (otherTeam.length === 2) {
  originalPartnerships.push({
    player1: otherTeam[0].name,
    player2: otherTeam[1].name
  });
}
const beforeCount = checkSpecificPartnershipsAreRepeats(originalPartnerships, currentSetNum);

// Perform the test swap
currentTeam[currentPlayerIndex] = otherPlayer;
otherTeam[otherPlayerIndex] = currentPlayer;

// Check new partnerships after swap
const newPartnerships = [];
if (currentTeam.length === 2) {
  newPartnerships.push({
    player1: currentTeam[0].name,
    player2: currentTeam[1].name
  });
}
if (otherTeam.length === 2) {
  newPartnerships.push({
    player1: otherTeam[0].name,
    player2: otherTeam[1].name
  });
}
const afterCount = checkSpecificPartnershipsAreRepeats(newPartnerships, currentSetNum);
              
              if (afterCount < beforeCount) {
                // Success! The swap reduced conflicts
                log("‚úì Inter-match fix (" + strategy.name + "): Swapped " + currentPlayer.name + " ‚Üî " + otherPlayer.name);
                log("  Repeat partnerships reduced from " + beforeCount + " to " + afterCount);
                fixedInMatch = true;
                break;
              } else {
                // Revert the swap - it didn't help
                currentTeam[currentPlayerIndex] = currentPlayer;
                otherTeam[otherPlayerIndex] = otherPlayer;
              }
            }
          }
        }
      }
    }
    
    if (!fixedInMatch) {
      log("‚ùå Could not auto-fix: " + repeat.players.join(" & ") + " - leaving for manual adjustment");
    }
  });
  
 const finalRepeats = checkForRepeatPartnerships(currentSetNum, workingMatches);
  if (finalRepeats.length > 0) {
    log("‚ö† Could not resolve all repeat partnerships. Remaining: " + finalRepeats.length);
    finalRepeats.forEach(rp => {
      log("  - " + rp.players.join(" & ") + " (previously in Set " + rp.previousSet + ")");
    });
  } else {
    log("üéâ Successfully resolved all repeat partnerships!");
  }
} else {
  log("=== PHASE 2 SKIPPED DUE TO THRESHOLD ===");
  log("Phase 1 intra-match fixes completed only");
  log("Operator must manually resolve remaining repeat partnerships");
}

return workingMatches;
}

function tryIntraMatchOpponentToPartnerSwap(data, matches) {
  const currentSetNum = parseInt(document.getElementById('setNumberSelector').value);
  if (currentSetNum <= 1) return matches;
  
  log("=== ATTEMPTING INTRA-MATCH OPPONENT-TO-PARTNER SWAPS ===");
  
  const workingMatches = JSON.parse(JSON.stringify(matches));
  const repeatOpponents = checkForRepeatOpponents(currentSetNum, workingMatches);
  
  if (repeatOpponents.length === 0) return workingMatches;
  
  const processedPairs = new Set();
  
  repeatOpponents.forEach(repeat => {
    const pairKey = repeat.player1 < repeat.player2 ? 
      `${repeat.player1}-${repeat.player2}` : `${repeat.player2}-${repeat.player1}`;
    
    if (processedPairs.has(pairKey)) return;
    processedPairs.add(pairKey);
    
    const match = workingMatches[repeat.matchIndex];
    
    // Find positions
    let player1Team = null, player1Index = null;
    let player2Team = null, player2Index = null;
    
    match.team1.forEach((p, idx) => {
      if (p.name === repeat.player1) { player1Team = 1; player1Index = idx; }
      if (p.name === repeat.player2) { player2Team = 1; player2Index = idx; }
    });
    match.team2.forEach((p, idx) => {
      if (p.name === repeat.player1) { player1Team = 2; player1Index = idx; }
      if (p.name === repeat.player2) { player2Team = 2; player2Index = idx; }
    });
    
    if (player1Team === player2Team) return;
    
    const player2PartnerIndex = player2Index === 0 ? 1 : 0;
    const team1 = player1Team === 1 ? match.team1 : match.team2;
    const team2 = player2Team === 1 ? match.team1 : match.team2;
    
    if (team2.length !== 2) return;
    
    log(`Trying intra-match swap in Match ${repeat.matchIndex}: ${repeat.player1} ‚Üî ${team2[player2PartnerIndex].name}`);
    
    // Test the swap
    const testMatches = JSON.parse(JSON.stringify(workingMatches));
    const testMatch = testMatches[repeat.matchIndex];
    const testTeam1 = player1Team === 1 ? testMatch.team1 : testMatch.team2;
    const testTeam2 = player2Team === 1 ? testMatch.team1 : testMatch.team2;
    
    const temp = testTeam1[player1Index];
    testTeam1[player1Index] = testTeam2[player2PartnerIndex];
    testTeam2[player2PartnerIndex] = temp;

    // Check if swap would create prohibited 2M vs 2F
    const team1Men = testTeam1.filter(p => getPlayerGender(p.name, data) === 'M').length;
    const team2Men = testTeam2.filter(p => getPlayerGender(p.name, data) === 'M').length;
    if ((team1Men === 2 && team2Men === 0) || (team1Men === 0 && team2Men === 2)) {
      log(`  ‚úó Swap would create prohibited 2M vs 2F match - rejected`);
      return; // Skip this repeat opponent pair
    }

    // >>> ADDED (competitiveness gate) >>>
    // Reuse existing grade logic in this file; reverseTranslateGrade is defined above. 
    const asNum = (pl) => (typeof pl.grade === 'number' ? pl.grade : reverseTranslateGrade(pl.grade));
    const teamSum = (arr) => arr.reduce((s, pl) => s + asNum(pl), 0);

    // Old vs new gap for THIS match
    const oldGap = Math.abs(teamSum(team1) - teamSum(team2));
    const newGap = Math.abs(teamSum(testTeam1) - teamSum(testTeam2));

    // If your final balancer flags gap >= 2 as uncompetitive, keep that same threshold here. 
    // Also, if your file exposes isUncompetitive(match), use it too for identical behavior.
    if ((typeof isUncompetitive === 'function' && isUncompetitive(testMatch)) || newGap > oldGap || newGap >= 2) {
      log('  ‚úó Swap rejected: reduces competitiveness (gap would worsen or hit balancing threshold)');
      return; // Skip this repeat opponent pair
    }
    // <<< ADDED <<<

    const partnershipsBefore = checkForRepeatPartnerships(currentSetNum, workingMatches).length;
    const partnershipsAfter  = checkForRepeatPartnerships(currentSetNum, testMatches).length;
    
    if (partnershipsAfter <= partnershipsBefore) {
      // Apply the swap
      const actualTemp = team1[player1Index];
      team1[player1Index] = team2[player2PartnerIndex];
      team2[player2PartnerIndex] = actualTemp;
      log(`  ‚úì Successful swap! ${repeat.player1} and ${repeat.player2} are now partners`);
    }
  });
  
  return workingMatches;
}


function autoFixRepeatOpponents(data, matches) {
// Global (this pass) cache of bad swaps so we never retry them on other pairs in the same run
const triedSwapsAllPairs = new Set();
// Players who have already been swapped successfully this pass
const swappedThisPass = new Set();


  const currentSetNum = parseInt(document.getElementById('setNumberSelector').value);
  if (currentSetNum <= 1) return matches;
  
  log("=== AUTO-FIXING REPEAT OPPONENTS ===");

// Create a working copy of matches
const workingMatches = JSON.parse(JSON.stringify(matches));
  
  // Get repeat opponents
  const repeatOpponents = checkForRepeatOpponents(currentSetNum, workingMatches);
  
  if (repeatOpponents.length === 0) {
    log("No repeat opponents found - no auto-fixes needed");
    return workingMatches;
  }
  
  log("Found " + repeatOpponents.length + " repeat opponent instances to attempt fixing");
  
  // Process each repeat opponent instance
  repeatOpponents.forEach((repeat, repeatIndex) => {

// üîÅ Cache of swaps we already tried (for THIS repeat pair only)
const triedSwaps = new Set();

// Make a stable key for a swap attempt (same players, same two matches)
const makeSwapKey = (nameA, nameB, idxA, idxB) => {
  // sort names so A‚ÜîB and B‚ÜîA are treated as the same
  const left  = nameA < nameB ? nameA : nameB;
  const right = nameA < nameB ? nameB : nameA;
  const m1 = Math.min(idxA, idxB);
  const m2 = Math.max(idxA, idxB);
  return `${left}‚Üî${right}@${m1}-${m2}`;
};


    log(`\n--- Attempting to fix repeat opponent: ${repeat.player1} vs ${repeat.player2} (Match ${repeat.matchIndex}) ---`);
    
    let fixedOpponent = false;
    let attemptCount = 0;
    
   // Single pass over all unique candidate swaps for this repeat opponent instance
for (let attempt = 1; attempt <= 1 && !fixedOpponent; attempt++) {
  attemptCount = 1;
  log(`  Attempt 1 for ${repeat.player1} vs ${repeat.player2}`);

      
      // For each of the two players in the repeat opponent pair
      const playersToTry = [repeat.player1, repeat.player2];
      
      for (let playerToSwap of playersToTry) {

// right after defining playersToTry
log(`  ‚Ü≥ Trying candidates for ${playerToSwap}`);

        if (fixedOpponent) break;
        
        // Find this player's current position in workingMatches
        let playerMatchIndex = null;
        let playerTeamNum = null;
        let playerPositionIndex = null;
        
        // Search for the player in all matches
        for (let matchIdx = 0; matchIdx < workingMatches.length; matchIdx++) {
          const match = workingMatches[matchIdx];
          
          // Check team 1
          for (let pos = 0; pos < match.team1.length; pos++) {
            if (match.team1[pos].name === playerToSwap) {
              playerMatchIndex = matchIdx;
              playerTeamNum = 1;
              playerPositionIndex = pos;
              break;
            }
          }
          
          // Check team 2 if not found in team 1
          if (playerMatchIndex === null) {
            for (let pos = 0; pos < match.team2.length; pos++) {
              if (match.team2[pos].name === playerToSwap) {
                playerMatchIndex = matchIdx;
                playerTeamNum = 2;
                playerPositionIndex = pos;
                break;
              }
            }
          }
          
          if (playerMatchIndex !== null) break;
        }
        
        if (playerMatchIndex === null) {
          log(`    ‚ùå Could not find player ${playerToSwap} in any match`);
          continue;
        }
        
        const currentMatch = workingMatches[playerMatchIndex];
        const currentTeam = playerTeamNum === 1 ? currentMatch.team1 : currentMatch.team2;
        const currentPlayer = currentTeam[playerPositionIndex];
        const currentPlayerGender = getPlayerGender(currentPlayer.name, data);
        const currentPlayerGrade = currentPlayer.grade;
        
        // Look for swap candidates in other matches
        for (let otherMatchIndex = 0; otherMatchIndex < workingMatches.length && !fixedOpponent; otherMatchIndex++) {
          if (otherMatchIndex === playerMatchIndex) continue;
          
          const otherMatch = workingMatches[otherMatchIndex];
          
          // Check both teams in the other match
          for (let otherTeamNum = 1; otherTeamNum <= 2 && !fixedOpponent; otherTeamNum++) {
            const otherTeam = otherTeamNum === 1 ? otherMatch.team1 : otherMatch.team2;
            
            for (let otherPlayerIndex = 0; otherPlayerIndex < otherTeam.length && !fixedOpponent; otherPlayerIndex++) {
              const otherPlayer = otherTeam[otherPlayerIndex];
              const otherPlayerGender = getPlayerGender(otherPlayer.name, data);
              const otherPlayerGrade = otherPlayer.grade;
              
              // Check if this is a valid swap candidate (same gender and grade)
              if (currentPlayerGender !== otherPlayerGender || currentPlayerGrade !== otherPlayerGrade) {
                continue;
              }
              
// Skip players we‚Äôve already moved successfully in this pass to avoid thrashing
if (swappedThisPass.has(currentPlayer.name) || swappedThisPass.has(otherPlayer.name)) {
  continue;
}


// ‚õî Skip if we've already tried this exact swap
const swapKey = makeSwapKey(
  currentPlayer.name,
  otherPlayer.name,
  playerMatchIndex,
  otherMatchIndex
);

// ‚õî Skip if we've already tried this exact swap (either for this pair or any earlier pair in this pass)
if (triedSwaps.has(swapKey) || triedSwapsAllPairs.has(swapKey)) {
  log(`      ‚Ü©Ô∏è Skipping previously tried swap (global): ${currentPlayer.name} ‚Üî ${otherPlayer.name}`);
  continue;
}
// (still inside the nested loops)
log(`    Considering (pre-balance): ${currentPlayer.name} ‚Üî ${otherPlayer.name}`);

// Quick gate: if this inter-match swap would make either match unbalanced, skip early
if (!wouldCreateBalancedTeams(
      workingMatches,
      playerMatchIndex,
      playerPositionIndex,
      playerTeamNum,
      otherPlayerIndex,
      otherTeamNum,
      otherMatchIndex
)) {
  triedSwaps.add(swapKey);
  triedSwapsAllPairs.add(swapKey);
  // log(`      ‚è≠Ô∏è Skipping unbalanced result: ${currentPlayer.name} ‚Üî ${otherPlayer.name}`);
  continue;
}

log(`    Testing swap: ${currentPlayer.name} ‚Üî ${otherPlayer.name} (both ${currentPlayerGender}, grade ${currentPlayerGrade})`);


              
              // Store the exact positions and player data for the swap
              const swapData = {
                player1: {
                  matchIndex: playerMatchIndex,
                  teamNum: playerTeamNum,
                  positionIndex: playerPositionIndex,
                  playerData: JSON.parse(JSON.stringify(currentPlayer))
                },
                player2: {
                  matchIndex: otherMatchIndex,
                  teamNum: otherTeamNum,
                  positionIndex: otherPlayerIndex,
                  playerData: JSON.parse(JSON.stringify(otherPlayer))
                }
              };
              
              // Create test matches to check the effect of the swap
              const testMatches = JSON.parse(JSON.stringify(workingMatches));
              
              // Apply test swap using exact positions
              const testMatch1 = testMatches[swapData.player1.matchIndex];
              const testMatch2 = testMatches[swapData.player2.matchIndex];
              const testTeam1 = swapData.player1.teamNum === 1 ? testMatch1.team1 : testMatch1.team2;
              const testTeam2 = swapData.player2.teamNum === 1 ? testMatch2.team1 : testMatch2.team2;
              
              // Perform the actual swap in test
              testTeam1[swapData.player1.positionIndex] = swapData.player2.playerData;
              testTeam2[swapData.player2.positionIndex] = swapData.player1.playerData;
              
              // Check if this swap creates any new repeat partnerships
              const repeatPartnersBefore = checkForRepeatPartnerships(currentSetNum, workingMatches, true);
const repeatPartnersAfter = checkForRepeatPartnerships(currentSetNum, testMatches, true);
              
              const partnershipDiff = repeatPartnersAfter.length - repeatPartnersBefore.length;
              
              if (partnershipDiff > 0) {
                log(`      ‚ùå Swap would create ${partnershipDiff} new repeat partnership(s) - rejected`);
                triedSwaps.add(swapKey);
                triedSwapsAllPairs.add(swapKey);
                continue;
              }
              
              // Check if this swap reduces repeat opponents
              const repeatOpponentsBefore = checkForRepeatOpponents(currentSetNum, workingMatches);
              const repeatOpponentsAfter = checkForRepeatOpponents(currentSetNum, testMatches);
              
              const opponentDiff = repeatOpponentsAfter.length - repeatOpponentsBefore.length;
              
              if (opponentDiff < 0) {
                // Success! Apply the swap to workingMatches using exact same approach
                const realMatch1 = workingMatches[swapData.player1.matchIndex];
                const realMatch2 = workingMatches[swapData.player2.matchIndex];
                const realTeam1 = swapData.player1.teamNum === 1 ? realMatch1.team1 : realMatch1.team2;
                const realTeam2 = swapData.player2.teamNum === 1 ? realMatch2.team1 : realMatch2.team2;
                
                // Perform the exact same swap
                realTeam1[swapData.player1.positionIndex] = swapData.player2.playerData;
                realTeam2[swapData.player2.positionIndex] = swapData.player1.playerData;
                
                log(`      ‚úÖ Successful swap: ${swapData.player1.playerData.name} ‚Üî ${swapData.player2.playerData.name}`);
                log(`         Opponents: ${opponentDiff}, Partnerships: ${partnershipDiff === 0 ? 'unchanged' : partnershipDiff}`);
                swappedThisPass.add(swapData.player1.playerData.name);
                swappedThisPass.add(swapData.player2.playerData.name);
                
                fixedOpponent = true;
                break;
              } else {
                log(`      ‚ùå Swap did not reduce repeat opponents - rejected`);
                triedSwaps.add(swapKey);
                triedSwapsAllPairs.add(swapKey);
              }
            }
          }
        }
      }
    }
    
    if (!fixedOpponent) {
      log(`  ‚ùå Could not fix repeat opponent after ${attemptCount} attempts: ${repeat.player1} vs ${repeat.player2}`);
    }
  });

// TRY INTRA-MATCH SWAPS FOR ANY REMAINING REPEAT OPPONENTS
const finalMatches = tryIntraMatchOpponentToPartnerSwap(data, workingMatches);
return finalMatches;
  
  const finalRepeatOpponents = checkForRepeatOpponents(currentSetNum, workingMatches);
  if (finalRepeatOpponents.length > 0) {
    log(`‚ö†Ô∏è Could not resolve all repeat opponents. Remaining: ${finalRepeatOpponents.length}`);
  } else {
    log("üéâ Successfully resolved all repeat opponents!");
  }

log(`‚ÑπÔ∏è Global tried-swaps this pass: ${triedSwapsAllPairs.size}`);

  
  return workingMatches;
}

function wouldCreateBalancedTeams(matches, match1Index, player1Index, team1Num, player2Index, team2Num, match2Index = null) {
  // If match2Index is null, we're swapping within the same match
  const match2Index_actual = match2Index !== null ? match2Index : match1Index;
  
  const match1 = matches[match1Index];
  const match2 = matches[match2Index_actual];
  
  const team1 = team1Num === 1 ? match1.team1 : match1.team2;
  const team2 = team2Num === 1 ? match2.team1 : match2.team2;
  
  const player1 = team1[player1Index];
  const player2 = team2[player2Index];
  
  // If swapping within same match, be more permissive (usually safe)
  if (match2Index === null) {
    return true;
  }
  
  // For inter-match swaps, check what the final team compositions would be
  const team1OtherPlayer = team1[1 - player1Index]; // The other player in team1
  const team2OtherPlayer = team2[1 - player2Index]; // The other player in team2
  
  // Calculate what the teams would look like after the swap
  const newTeam1 = [team1OtherPlayer, player2];
  const newTeam2 = [team2OtherPlayer, player1];
  
  // Get the opposing teams in each match
  const match1OpposingTeam = team1Num === 1 ? match1.team2 : match1.team1;
  const match2OpposingTeam = team2Num === 1 ? match2.team2 : match2.team1;
  
  // Check if both final matches would be balanced
  const match1Balanced = isMatchupBalanced(newTeam1, match1OpposingTeam);
  const match2Balanced = isMatchupBalanced(newTeam2, match2OpposingTeam);
  
  return match1Balanced && match2Balanced;
}

function fixUncompetitiveMatches(data, matches) {
  log("=== FINAL COMPETITIVENESS OPTIMIZATION ===");
  
  // Step 1: Identify uncompetitive matches
  const uncompetitiveMatches = [];
  matches.forEach((match, index) => {
    if (isUncompetitive(match)) {
      uncompetitiveMatches.push({index, match});
    }
  });
  
  log(`Found ${uncompetitiveMatches.length} uncompetitive matches`);
  
  if (uncompetitiveMatches.length <= 1) {
    log("‚â§1 uncompetitive match found - leaving for operator to handle");
    return matches;
  }
  
  // Step 2: Process pairs of uncompetitive matches
  const pairsToProcess = Math.floor(uncompetitiveMatches.length / 2);
  log(`Processing ${pairsToProcess} pairs of uncompetitive matches`);
  
  for (let pairIndex = 0; pairIndex < pairsToProcess; pairIndex++) {
    const matchA = uncompetitiveMatches[pairIndex * 2];
    const matchB = uncompetitiveMatches[pairIndex * 2 + 1];
    
    log(`\n--- Processing pair ${pairIndex + 1}: Match ${matchA.index} & Match ${matchB.index} ---`);
    
    // Try the swap
    if (attemptCompetitivenessSwap(data, matches, matchA.index, matchB.index)) {
      log(`‚úì Successful competitiveness swap between matches ${matchA.index} & ${matchB.index}`);
    } else {
      log(`‚ùå No beneficial swap found between matches ${matchA.index} & ${matchB.index}`);
    }
  }
  
  // Report final status
  const finalUncompetitive = matches.filter(match => isUncompetitive(match)).length;
  log(`\n=== COMPETITIVENESS OPTIMIZATION COMPLETE ===`);
  log(`Uncompetitive matches reduced from ${uncompetitiveMatches.length} to ${finalUncompetitive}`);
  
  return matches;
}

function autoFixPlusMinusImbalances(data, matches) {
  const currentSetNum = parseInt(document.getElementById('setNumberSelector').value);
  
  log("=== AUTO-FIXING PLUS/MINUS IMBALANCES ===");
  
  // Create a working copy of matches
  const workingMatches = JSON.parse(JSON.stringify(matches));
  
  // STEP 1: Redistribute +/- across matches (within grade and gender)
  // Move '-' players down and '+' players up
  log("--- Step 1: Redistributing +/- players across matches ---");
const swappedPlayers = new Set();

  for (let grade = 5; grade >= 1; grade--) {
    for (let gender of ['M', 'F']) {
      
      // Build list of all players at this grade/gender with their positions
      const playersAtGradeGender = [];
      workingMatches.forEach((match, matchIndex) => {
        [...match.team1, ...match.team2].forEach((player) => {
          if (player.grade === grade && getPlayerGender(player.name, data) === gender) {
            const team1Index = match.team1.findIndex(p => p.name === player.name);
            const teamNum = team1Index !== -1 ? 1 : 2;
            const positionIndex = teamNum === 1 ? team1Index : match.team2.findIndex(p => p.name === player.name);
            
            playersAtGradeGender.push({
              name: player.name,
              plusMinus: player.plusMinus || '',
              matchIndex,
              teamNum,
              positionIndex
            });
          }
        });
      });
      
      if (playersAtGradeGender.length < 2) continue;
      
      // Find '-' players in higher (earlier) matches
      const minusHighUp = playersAtGradeGender
        .filter(p => p.plusMinus === '-')
        .sort((a, b) => a.matchIndex - b.matchIndex);
      
      // Find '+' or blank players in lower (later) matches
      const plusOrBlankLowDown = playersAtGradeGender
        .filter(p => p.plusMinus === '+' || p.plusMinus === '')
        .sort((a, b) => b.matchIndex - a.matchIndex);
      
      // Try swapping
      for (let minusPlayer of minusHighUp) {
        // Skip if this player was already swapped
        if (swappedPlayers.has(minusPlayer.name)) continue;
        
        for (let plusPlayer of plusOrBlankLowDown) {
          // Skip if this player was already swapped
          if (swappedPlayers.has(plusPlayer.name)) continue;
          
          // Only swap if minus is in an earlier match than plus
          if (minusPlayer.matchIndex >= plusPlayer.matchIndex) continue;
          
                   
          // Test the swap
          const testMatches = JSON.parse(JSON.stringify(workingMatches));
          const testTeam1 = minusPlayer.teamNum === 1 ? testMatches[minusPlayer.matchIndex].team1 : testMatches[minusPlayer.matchIndex].team2;
          const testTeam2 = plusPlayer.teamNum === 1 ? testMatches[plusPlayer.matchIndex].team1 : testMatches[plusPlayer.matchIndex].team2;
          
          const temp = testTeam1[minusPlayer.positionIndex];
          testTeam1[minusPlayer.positionIndex] = testTeam2[plusPlayer.positionIndex];
          testTeam2[plusPlayer.positionIndex] = temp;
          
          // Check for new repeat partnerships
          const repeatPartnersBefore = checkForRepeatPartnerships(currentSetNum, workingMatches, true);
          const repeatPartnersAfter = checkForRepeatPartnerships(currentSetNum, testMatches, true);
          
          // Check for new repeat opponents
          const repeatOpponentsBefore = checkForRepeatOpponents(currentSetNum, workingMatches);
          const repeatOpponentsAfter = checkForRepeatOpponents(currentSetNum, testMatches);
          
          if (repeatPartnersAfter.length <= repeatPartnersBefore.length && 
              repeatOpponentsAfter.length <= repeatOpponentsBefore.length) {
            // Accept the swap in real matches
            const realTeam1 = minusPlayer.teamNum === 1 ? workingMatches[minusPlayer.matchIndex].team1 : workingMatches[minusPlayer.matchIndex].team2;
            const realTeam2 = plusPlayer.teamNum === 1 ? workingMatches[plusPlayer.matchIndex].team1 : workingMatches[plusPlayer.matchIndex].team2;
            
            const tempReal = realTeam1[minusPlayer.positionIndex];
            realTeam1[minusPlayer.positionIndex] = realTeam2[plusPlayer.positionIndex];
            realTeam2[plusPlayer.positionIndex] = tempReal;
            
           log(`‚úì Redistributed (Grade ${grade}, ${gender}): ${minusPlayer.name} (-) in Match ${minusPlayer.matchIndex} ‚Üî ${plusPlayer.name} (${plusPlayer.plusMinus || 'blank'}) in Match ${plusPlayer.matchIndex}`);
            
            // Mark both players as swapped so we don't use stale positions
            swappedPlayers.add(minusPlayer.name);
            swappedPlayers.add(plusPlayer.name);
            break; // Move to next minus player
          }
        }
      }
   }
  }
  
  // STEP 1b: Also move blanks down when there are '+' players below
  log("--- Step 1b: Moving blanks down when '+' players are below ---");
  
  for (let grade = 5; grade >= 1; grade--) {
    for (let gender of ['M', 'F']) {
      
      // Rebuild list of all players at this grade/gender with current positions
      const playersAtGradeGender = [];
      workingMatches.forEach((match, matchIndex) => {
        [...match.team1, ...match.team2].forEach((player) => {
          if (player.grade === grade && getPlayerGender(player.name, data) === gender) {
            const team1Index = match.team1.findIndex(p => p.name === player.name);
            const teamNum = team1Index !== -1 ? 1 : 2;
            const positionIndex = teamNum === 1 ? team1Index : match.team2.findIndex(p => p.name === player.name);
            
            playersAtGradeGender.push({
              name: player.name,
              plusMinus: player.plusMinus || '',
              matchIndex,
              teamNum,
              positionIndex
            });
          }
        });
      });
      
      if (playersAtGradeGender.length < 2) continue;
      
      // Find blank players in higher (earlier) matches
      const blanksHighUp = playersAtGradeGender
        .filter(p => p.plusMinus === '')
        .sort((a, b) => a.matchIndex - b.matchIndex);
      
      // Find '+' players in lower (later) matches
      const plusLowDown = playersAtGradeGender
        .filter(p => p.plusMinus === '+')
        .sort((a, b) => b.matchIndex - a.matchIndex);
      
      // Try swapping
      for (let blankPlayer of blanksHighUp) {
        // Skip if this player was already swapped
        if (swappedPlayers.has(blankPlayer.name)) continue;
        
        for (let plusPlayer of plusLowDown) {
          // Skip if this player was already swapped
          if (swappedPlayers.has(plusPlayer.name)) continue;
          
          // Only swap if blank is in an earlier match than plus
          if (blankPlayer.matchIndex >= plusPlayer.matchIndex) continue;
          
          // Test the swap
          const testMatches = JSON.parse(JSON.stringify(workingMatches));
          const testTeam1 = blankPlayer.teamNum === 1 ? testMatches[blankPlayer.matchIndex].team1 : testMatches[blankPlayer.matchIndex].team2;
          const testTeam2 = plusPlayer.teamNum === 1 ? testMatches[plusPlayer.matchIndex].team1 : testMatches[plusPlayer.matchIndex].team2;
          
          const temp = testTeam1[blankPlayer.positionIndex];
          testTeam1[blankPlayer.positionIndex] = testTeam2[plusPlayer.positionIndex];
          testTeam2[plusPlayer.positionIndex] = temp;
          
          // Check for new repeat partnerships
          const repeatPartnersBefore = checkForRepeatPartnerships(currentSetNum, workingMatches, true);
          const repeatPartnersAfter = checkForRepeatPartnerships(currentSetNum, testMatches, true);
          
          // Check for new repeat opponents
          const repeatOpponentsBefore = checkForRepeatOpponents(currentSetNum, workingMatches);
          const repeatOpponentsAfter = checkForRepeatOpponents(currentSetNum, testMatches);
          
          if (repeatPartnersAfter.length <= repeatPartnersBefore.length && 
              repeatOpponentsAfter.length <= repeatOpponentsBefore.length) {
            // Accept the swap in real matches
            const realTeam1 = blankPlayer.teamNum === 1 ? workingMatches[blankPlayer.matchIndex].team1 : workingMatches[blankPlayer.matchIndex].team2;
            const realTeam2 = plusPlayer.teamNum === 1 ? workingMatches[plusPlayer.matchIndex].team1 : workingMatches[plusPlayer.matchIndex].team2;
            
            const tempReal = realTeam1[blankPlayer.positionIndex];
            realTeam1[blankPlayer.positionIndex] = realTeam2[plusPlayer.positionIndex];
            realTeam2[plusPlayer.positionIndex] = tempReal;
            
            log(`‚úì Redistributed (Grade ${grade}, ${gender}): ${blankPlayer.name} (blank) in Match ${blankPlayer.matchIndex} ‚Üî ${plusPlayer.name} (+) in Match ${plusPlayer.matchIndex}`);
            
            // Mark both players as swapped
            swappedPlayers.add(blankPlayer.name);
            swappedPlayers.add(plusPlayer.name);
            break; // Move to next blank player
          }
        }
      }
    }
  }
  
  // STEP 2: Balance +/- within individual matches (all same grade)
  log("--- Step 2: Balancing +/- within individual matches ---");
  
  workingMatches.forEach((match, matchIndex) => {
    const allPlayers = [...match.team1, ...match.team2];
    
    // Check if all 4 players are same grade
    const grades = [...new Set(allPlayers.map(p => p.grade))];
    if (grades.length !== 1) return;
    
    // Count +/- on each team
    const team1Plus = match.team1.filter(p => p.plusMinus === '+').length;
    const team1Minus = match.team1.filter(p => p.plusMinus === '-').length;
    const team2Plus = match.team2.filter(p => p.plusMinus === '+').length;
    const team2Minus = match.team2.filter(p => p.plusMinus === '-').length;
    
    // Check for imbalanced patterns:
    // Pattern A: One team has 2+, the other has 0+ (2+ vs blanks/minuses)
    // Pattern B: One team has 2-, the other has 0- (2- vs blanks/pluses)
    
    let needsFix = false;
    let heavyTeam, lightTeam, heavyTeamNum, swapType;
    
    // Check Pattern A: 2+ on one side, 0+ on the other
    if (team1Plus === 2 && team2Plus === 0) {
      needsFix = true;
      heavyTeam = match.team1;
      lightTeam = match.team2;
      heavyTeamNum = 1;
      swapType = '+';
    } else if (team2Plus === 2 && team1Plus === 0) {
      needsFix = true;
      heavyTeam = match.team2;
      lightTeam = match.team1;
      heavyTeamNum = 2;
      swapType = '+';
    }
    // Check Pattern B: 2- on one side, 0- on the other
    else if (team1Minus === 2 && team2Minus === 0) {
      needsFix = true;
      heavyTeam = match.team1;
      lightTeam = match.team2;
      heavyTeamNum = 1;
      swapType = '-';
    } else if (team2Minus === 2 && team1Minus === 0) {
      needsFix = true;
      heavyTeam = match.team2;
      lightTeam = match.team1;
      heavyTeamNum = 2;
      swapType = '-';
    }
    
    if (!needsFix) return;
    
    log(`Match ${matchIndex}: Found imbalanced +/- pattern (2${swapType} vs 0${swapType}), attempting fix...`);
    
    // Try swapping one player with the swapType from heavyTeam 
    // with one player without it from lightTeam (same gender only)
    for (let hi = 0; hi < heavyTeam.length; hi++) {
      // Only consider players that have the swapType designation
      if (heavyTeam[hi].plusMinus !== swapType) continue;
      
      for (let li = 0; li < lightTeam.length; li++) {
        // Only consider players that DON'T have the swapType designation
        if (lightTeam[li].plusMinus === swapType) continue;
        
        const heavyPlayer = heavyTeam[hi];
        const lightPlayer = lightTeam[li];
        
        // Must be same gender
        if (getPlayerGender(heavyPlayer.name, data) !== getPlayerGender(lightPlayer.name, data)) continue;
        
        // Test the swap
        const testMatches = JSON.parse(JSON.stringify(workingMatches));
        const testHeavyTeam = heavyTeamNum === 1 ? testMatches[matchIndex].team1 : testMatches[matchIndex].team2;
        const testLightTeam = heavyTeamNum === 1 ? testMatches[matchIndex].team2 : testMatches[matchIndex].team1;
        
        const temp = testHeavyTeam[hi];
        testHeavyTeam[hi] = testLightTeam[li];
        testLightTeam[li] = temp;
        
        // Check for new repeat partnerships
        const repeatPartnersBefore = checkForRepeatPartnerships(currentSetNum, workingMatches, true);
        const repeatPartnersAfter = checkForRepeatPartnerships(currentSetNum, testMatches, true);
        
        // Check for new repeat opponents
        const repeatOpponentsBefore = checkForRepeatOpponents(currentSetNum, workingMatches);
        const repeatOpponentsAfter = checkForRepeatOpponents(currentSetNum, testMatches);
        
        if (repeatPartnersAfter.length <= repeatPartnersBefore.length && 
            repeatOpponentsAfter.length <= repeatOpponentsBefore.length) {
          // Accept the swap
          const temp2 = heavyTeam[hi];
          heavyTeam[hi] = lightTeam[li];
          lightTeam[li] = temp2;
          
          log(`‚úì Match ${matchIndex}: Swapped ${heavyPlayer.name} (${swapType}) ‚Üî ${lightPlayer.name} (${lightPlayer.plusMinus || 'blank'})`);
          return; // Fixed, move to next match
        }
      }
    }
    
   log(`‚ùå Match ${matchIndex}: Could not fix +/- imbalance without creating repeat partnership or opponent`);
  });
  
  log("=== PLUS/MINUS BALANCING COMPLETE ===");
  return workingMatches;
}


function balanceIndividualMatches(data, matches) {
  log("=== FINAL INDIVIDUAL MATCH BALANCING ===");
  
  let totalImprovedMatches = 0;
  
  matches.forEach((match, matchIndex) => {
    // Check if match needs balancing (‚â•2 point gap)
    const team1Total = match.team1.reduce((sum, p) => sum + p.grade, 0);
    const team2Total = match.team2.reduce((sum, p) => sum + p.grade, 0);
    const currentGap = Math.abs(team1Total - team2Total);
    
    if (currentGap < 2) return; // Skip well-balanced matches
    
    log(`Match ${matchIndex} needs balancing: ${team1Total} vs ${team2Total} (gap=${currentGap})`);
    
    // Test all 3 possible swaps
    let bestSwap = null;
    let bestGap = currentGap;
    
    for (let t1Player = 0; t1Player < 2; t1Player++) {
      for (let t2Player = 0; t2Player < 2; t2Player++) {
        if (t1Player === 1 && t2Player === 1) continue; // Skip redundant swap
        
        // Test this swap
        const testMatch = JSON.parse(JSON.stringify(match));
        const tempPlayer = testMatch.team1[t1Player];
        testMatch.team1[t1Player] = testMatch.team2[t2Player];
        testMatch.team2[t2Player] = tempPlayer;
        
        // Check if creates 2M vs 2F
        if (creates2Mvs2F(testMatch, data)) continue;
        
        // Calculate new balance
        const newTeam1Total = testMatch.team1.reduce((sum, p) => sum + p.grade, 0);
        const newTeam2Total = testMatch.team2.reduce((sum, p) => sum + p.grade, 0);
        const newGap = Math.abs(newTeam1Total - newTeam2Total);
        
        // Keep if it's the best improvement so far
        if (newGap < bestGap) {
          bestGap = newGap;
          bestSwap = { t1Player, t2Player };
        }
      }
    }
    
    // Apply the best swap if found
    if (bestSwap) {
      const tempPlayer = match.team1[bestSwap.t1Player];
      match.team1[bestSwap.t1Player] = match.team2[bestSwap.t2Player];
      match.team2[bestSwap.t2Player] = tempPlayer;
      
      updateMatchFormat(match);
      log(`  ‚úì Swapped players: Gap reduced from ${currentGap} to ${bestGap}`);
      totalImprovedMatches++;
    } else {
      log(`  No valid improvement found for match ${matchIndex}`);
    }
  });
  
  log(`=== INDIVIDUAL MATCH BALANCING COMPLETE: ${totalImprovedMatches} matches improved ===`);
  return matches;
}

function isUncompetitive(match) {
  const team1Grades = match.team1.map(p => p.grade).sort((a,b) => b-a); // [high, low]
  const team2Grades = match.team2.map(p => p.grade).sort((a,b) => b-a); // [high, low]
  
  // Calculate intra-team gaps
  const team1Gap = team1Grades[0] - team1Grades[1];
  const team2Gap = team2Grades[0] - team2Grades[1];
  
  // Uncompetitive if ANY partnership has 2+ grade gap
  const isUncomp = team1Gap >= 2 || team2Gap >= 2;
  
  if (isUncomp) {
    log(`Uncompetitive match: [${team1Grades.join(',')}] vs [${team2Grades.join(',')}] - gaps: ${team1Gap}, ${team2Gap}`);
  }
  
  return isUncomp;
}

function attemptCompetitivenessSwap(data, matches, matchAIndex, matchBIndex) {
  const matchA = matches[matchAIndex];
  const matchB = matches[matchBIndex];
  
  // Get all players from both matches with their current positions
  const playersA = [
    ...matchA.team1.map((p, i) => ({...p, match: matchAIndex, team: 1, position: i})),
    ...matchA.team2.map((p, i) => ({...p, match: matchAIndex, team: 2, position: i}))
  ];
  
  const playersB = [
    ...matchB.team1.map((p, i) => ({...p, match: matchBIndex, team: 1, position: i})),
    ...matchB.team2.map((p, i) => ({...p, match: matchBIndex, team: 2, position: i}))
  ];
  
  // Sort players by grade
  playersA.sort((a, b) => a.grade - b.grade); // weakest first
  playersB.sort((a, b) => b.grade - a.grade); // strongest first
  
  // Get the 2 weakest from A and 2 strongest from B
  const weakestFromA = playersA.slice(0, 2);
  const strongestFromB = playersB.slice(0, 2);
  
  log(`Swapping (no competitiveness check needed):`);
  log(`  Weakest from Match ${matchAIndex}: ${weakestFromA.map(p => `${p.name}(${p.grade})`).join(', ')}`);
  log(`  Strongest from Match ${matchBIndex}: ${strongestFromB.map(p => `${p.name}(${p.grade})`).join(', ')}`);
  
  // Create test versions of the matches
  const testMatchA = JSON.parse(JSON.stringify(matchA));
  const testMatchB = JSON.parse(JSON.stringify(matchB));
  
  // Perform direct 1-for-1 swaps
  // Swap weakest player 1 from A with strongest player 1 from B
  const weakPlayer1 = weakestFromA[0];
  const strongPlayer1 = strongestFromB[0];
  
  const weakTeam1 = weakPlayer1.team === 1 ? testMatchA.team1 : testMatchA.team2;
  const strongTeam1 = strongPlayer1.team === 1 ? testMatchB.team1 : testMatchB.team2;
  
  const temp1 = {...weakTeam1[weakPlayer1.position]};
  weakTeam1[weakPlayer1.position] = {...strongTeam1[strongPlayer1.position]};
  strongTeam1[strongPlayer1.position] = temp1;
  
  // Swap weakest player 2 from A with strongest player 2 from B
  const weakPlayer2 = weakestFromA[1];
  const strongPlayer2 = strongestFromB[1];
  
  const weakTeam2 = weakPlayer2.team === 1 ? testMatchA.team1 : testMatchA.team2;
  const strongTeam2 = strongPlayer2.team === 1 ? testMatchB.team1 : testMatchB.team2;
  
  const temp2 = {...weakTeam2[weakPlayer2.position]};
  weakTeam2[weakPlayer2.position] = {...strongTeam2[strongPlayer2.position]};
  strongTeam2[strongPlayer2.position] = temp2;
  
  // Only check if the swap creates the forbidden 2M vs 2F pattern
  if (creates2Mvs2F(testMatchA, data) || creates2Mvs2F(testMatchB, data)) {
    log(`  ‚ùå Swap would create 2M vs 2F - rejected`);
    return false;
  }
  
  // Accept the swap
  matches[matchAIndex] = testMatchA;
  matches[matchBIndex] = testMatchB;
  
  // Update match formats
  updateMatchFormat(matches[matchAIndex]);
  updateMatchFormat(matches[matchBIndex]);
  
  log(`  ‚úì Swap completed`);
  return true;
}

function creates2Mvs2F(match, data) {
  const team1Men = match.team1.filter(p => getPlayerGender(p.name, data) === 'M').length;
  const team1Women = match.team1.filter(p => getPlayerGender(p.name, data) === 'F').length;
  const team2Men = match.team2.filter(p => getPlayerGender(p.name, data) === 'M').length;
  const team2Women = match.team2.filter(p => getPlayerGender(p.name, data) === 'F').length;
  
  // Check for 2M vs 2F pattern
  return (team1Men === 2 && team1Women === 0 && team2Men === 0 && team2Women === 2) ||
         (team1Men === 0 && team1Women === 2 && team2Men === 2 && team2Women === 0);
}

function isMatchupBalanced(team1, team2) {
  const team1Grades = team1.map(p => p.grade).sort((a, b) => b - a); // High to low
  const team2Grades = team2.map(p => p.grade).sort((a, b) => b - a); // High to low
  
  const team1High = team1Grades[0];
  const team1Low = team1Grades[1];
  const team2High = team2Grades[0];
  const team2Low = team2Grades[1];
  
  // Rule 1: Both teams should have similar highest grades (within 1 grade)
  if (Math.abs(team1High - team2High) > 1) {
    return false;
  }
  
  // Rule 2: Calculate total team strength
  const team1Total = team1High + team1Low;
  const team2Total = team2High + team2Low;
  
  // Rule 3: Special handling for Grade 5 players
  const team1HasGrade5 = team1Grades.includes(5);
  const team2HasGrade5 = team2Grades.includes(5);
  
  // If one team has Grade 5 and the other doesn't, be very strict
  if (team1HasGrade5 && !team2HasGrade5) {
    // Team 2 needs at least 4+4 to compete with a team that has a Grade 5
    return team2High === 4 && team2Low === 4;
  }
  if (team2HasGrade5 && !team1HasGrade5) {
    // Team 1 needs at least 4+4 to compete with a team that has a Grade 5
    return team1High === 4 && team1Low === 4;
  }
  
  // For teams without Grade 5, allow reasonable differences
  return Math.abs(team1Total - team2Total) <= 2;
}

function getPlayerGender(playerName, data) {
  // Check sorted arrays first
  let menPlayer = data.sortedMen ? data.sortedMen.find(p => p.name === playerName) : null;
  let womenPlayer = data.sortedWomen ? data.sortedWomen.find(p => p.name === playerName) : null;
  
  // If not found, check available arrays
  if (!menPlayer && data.availableMen) {
    menPlayer = data.availableMen.find(p => p.name === playerName);
  }
  if (!womenPlayer && data.availableWomen) {
    womenPlayer = data.availableWomen.find(p => p.name === playerName);
  }
  
  return menPlayer ? 'M' : (womenPlayer ? 'F' : null);
}

function checkPlayingDownStatus(currentSetNumber, allMatches) {
  const playingDownInstances = [];
  
  allMatches.forEach((match, matchIndex) => {
    const allPlayersInMatch = [...match.team1, ...match.team2];
    
    // For each player, check if they're playing with anyone 2+ grades lower
    allPlayersInMatch.forEach(player => {
      const playerGrade = player.grade;
      const otherPlayers = allPlayersInMatch.filter(p => p.name !== player.name);
      
      const playingDown = otherPlayers.some(other => (playerGrade - other.grade) >= 2);
      
      if (playingDown) {
        const lowestOpponentGrade = Math.min(...otherPlayers.map(p => p.grade));
        const gradeDifference = playerGrade - lowestOpponentGrade;
        
        playingDownInstances.push({
          matchIndex: matchIndex,
          playerName: player.name,
          playerGrade: playerGrade,
          lowestOpponentGrade: lowestOpponentGrade,
          gradeDifference: gradeDifference
        });
      }
    });
  });
  
  return playingDownInstances;
}

function hasPlayedDownBefore(playerName, currentSetNumber) {
  for (let setNum = 1; setNum < currentSetNumber; setNum++) {
    if (!allSetsData[setNum] || !allSetsData[setNum].matches) continue;
    
    const hasPlayedDown = allSetsData[setNum].matches.some(match => {
      const allPlayersInMatch = [...match.team1, ...match.team2];
      const thisPlayer = allPlayersInMatch.find(p => p.name === playerName);
      
      if (!thisPlayer) return false;
      
      // Check if this player was with anyone 2+ grades lower
      const otherPlayers = allPlayersInMatch.filter(p => p.name !== playerName);
      return otherPlayers.some(other => (thisPlayer.grade - other.grade) >= 1);
    });
    
    if (hasPlayedDown) return true;
  }
  return false;
}


function testSwapReducesConflicts(matches, match1Index, team1Num, player1Index, match2Index, team2Num, player2Index, currentSetNum) {
  // Create a test copy of matches with the proposed swap
  const testMatches = JSON.parse(JSON.stringify(matches));
  
  const match1 = testMatches[match1Index];
  const match2 = testMatches[match2Index];
  const team1 = team1Num === 1 ? match1.team1 : match1.team2;
  const team2 = team2Num === 1 ? match2.team1 : match2.team2;
  
  // Get conflict count before swap
  const conflictsBefore = checkForRepeatPartnerships(currentSetNum, matches).length;
  
  // Perform the test swap
  const tempPlayer = team1[player1Index];
  team1[player1Index] = team2[player2Index];
  team2[player2Index] = tempPlayer;
  
  // Get conflict count after swap
  const conflictsAfter = checkForRepeatPartnerships(currentSetNum, testMatches).length;
  
  // The swap is beneficial if it reduces conflicts and doesn't create new ones in different partnerships
  return conflictsAfter < conflictsBefore;
}

function createSatOffPlayerBox(playerName, data) {
  // Find player data to get attributes
  const playerData = playerRows.find(p => p.name === playerName);
  if (!playerData) return '';
  
  const isNHC = playerData.nhc;

  const plusMinus = playerData.plusMinus || '';
  const downArrow = hasPlayedDownBefore(playerName, currentSetNumber) ? '‚Üì' : '';
  
  // Build CSS classes
  let cssClasses = 'player-box sat-off-player';
  if (isNHC) cssClasses += ' nhc';

  
  return `
    <span class="${cssClasses}" draggable="true" 
          data-type="sat-off-player" data-name="${playerName}" data-grade="${playerData.grade}"
          style="display: inline-block; background: #fff8dc; border: 2px solid #ffc107; 
       padding: 8px; margin: 4px 0; border-radius: 5px; cursor: move; 
       user-select: none; font-weight: bold; transition: all 0.2s ease;">
      ${downArrow}${playerName} (${translateGrade(playerData.grade)}${plusMinus})
    </span>`;
}

function displayResults(data, matches) {
  // Save current set data immediately when matches are generated
  currentSetNumber = parseInt(document.getElementById('setNumberSelector').value);
  
 // Use matches as-is to preserve order
const allMatches = matches; 
  
  allSetsData[currentSetNumber] = {
    data: JSON.parse(JSON.stringify(data)),
    matches: JSON.parse(JSON.stringify(allMatches)),
    restingPlayers: [],
    satOffPlayers: []
  };

  // Store resting players
  const restingPlayers = playerRows.filter(p => p.name && p.resting).map(p => p.name);
  if (restingPlayers.length > 0) {
    allSetsData[currentSetNumber].restingPlayers = [...restingPlayers];
    log("Stored " + allSetsData[currentSetNumber].restingPlayers.length + " resting players for Set " + currentSetNumber);
  }

  // Store sat off players (players marked as SO, not resting)
  const satOffPlayers = playerRows.filter(p => p.name && p.so).map(p => p.name);
  if (satOffPlayers.length > 0) {
    allSetsData[currentSetNumber].satOffPlayers = [...satOffPlayers];
    log("Stored " + allSetsData[currentSetNumber].satOffPlayers.length + " sat-off players for Set " + currentSetNumber);
  } else {
    log("No players sat off for Set " + currentSetNumber + " (evenly divisible by 4)");
  }

  log("Set " + currentSetNumber + " data saved to memory");
  
  const matchesDiv = document.getElementById('matches');
  const matchResults = document.getElementById('matchResults');
  
 const repeatPartners = checkForRepeatPartnerships(currentSetNumber, allMatches);
const repeatOpponents = checkForRepeatOpponents(currentSetNumber, allMatches);
 let matchHtml = '<div class="success">‚úì ' + allMatches.length + ' Matches Generated for Set ' + document.getElementById('setNumberSelector').value;
if (manualMatches.length > 0) {
  matchHtml += ' (' + manualMatches.length + ' manual + ' + matches.length + ' automatic)';
}
matchHtml += '</div>';
  matchHtml += '<p style="color: #666; font-style: italic;">Drag players or courts to swap them</p>';

// Add sat-off players section if any exist
// (satOffPlayers already declared above)
if (satOffPlayers.length > 0) {
  matchHtml += `
    <div style="background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px; padding: 10px; margin: 20px 0;">
  <h4 style="margin: 0 0 5px 0; color: #856404; font-size: 16px;">Players Sitting Off:</h4>
  <p style="margin: 0 0 8px 0; font-size: 13px; color: #856404; font-style: italic;">
    Drag these players into matches to swap them in
  </p>
  <div id="satOffPlayersContainer">
    ${satOffPlayers.map(playerName => createSatOffPlayerBox(playerName, data)).join('')}
  </div>
</div>`;
}
  
  const isNHCPlayer = (playerName) => {
    // Check original data first (for manual match players)
    let menPlayer = data.availableMen ? data.availableMen.find(p => p.name === playerName) : null;
    let womenPlayer = data.availableWomen ? data.availableWomen.find(p => p.name === playerName) : null;
    
    // If not found in original lists, check sorted lists (for auto match players)
    if (!menPlayer && data.sortedMen) {
      menPlayer = data.sortedMen.find(p => p.name === playerName);
    }
    if (!womenPlayer && data.sortedWomen) {
      womenPlayer = data.sortedWomen.find(p => p.name === playerName);
    }
    
    const foundPlayer = menPlayer || womenPlayer;
    return foundPlayer && foundPlayer.nhc;
  };


  
  // Create compact table format
  matchHtml += '<table style="width: 100%; border-collapse: collapse; margin: 20px 0;">';
  
  // Check if all matches are manual to determine button text
const allManual = allMatches.every(match => match.isManual);
const lockButtonText = allManual ? "Unlock All" : "Lock All";
const lockButtonOnclick = allManual ? "unlockAllMatches()" : "lockAllMatches()";

// Header row
matchHtml += '<tr style="background: #f8f9fa; border-bottom: 2px solid #333;">';
matchHtml += '<th style="padding: 0px 12px; line-height: 0.5em; text-align: center; font-weight: bold; border: 1px solid #ddd; width: 40px;">Court</th>';
matchHtml += '<th style="padding: 0px 12px; line-height: 0.5em; text-align: center; font-weight: bold; border: 1px solid #ddd; width: 45%;">Team 1</th>';
matchHtml += '<th style="padding: 0px 12px; line-height: 0.5em; text-align: center; font-weight: bold; border: 1px solid #ddd; width: 45%;">Team 2</th>';
matchHtml += `<th style="padding: 0px 12px; line-height: 0.5em; text-align: center; font-weight: bold; border: 1px solid #ddd; width: 80px;">`;

matchHtml += `<button onclick="${lockButtonOnclick}" style="padding: 4px 8px; font-size: 12px; cursor: pointer; font-weight: bold;">${lockButtonText}</button>`;
matchHtml += `</th>`;
matchHtml += '</tr>';
  
  // Match rows
  allMatches.forEach((match, matchIndex) => {
    const isManual = match.isManual || false;
    const rowClass = isManual ? 'style="background: #e6e6e6;"' : '';
    
    matchHtml += '<tr ' + rowClass + '>';

// Function to check if a partnership has grade gap > 1
const hasGradeGap = (team) => {
  if (team.length !== 2) return false;
  return Math.abs(team[0].grade - team[1].grade) > 1;
};

// Check grade gaps for both teams
const team1HasGradeGap = hasGradeGap(match.team1);
const team2HasGradeGap = hasGradeGap(match.team2);
    
  // Court column
    const courtClass = isManual ? 'court-box manual' : 'court-box';
    matchHtml += '<td style="padding: 8px; text-align: center; border: 1px solid #ddd; vertical-align: middle;">';
    matchHtml += '<div class="' + courtClass + '" draggable="true" data-type="court" data-match="' + matchIndex + '" data-court="' + match.court + '" ';
    matchHtml += 'style="display: inline-block; background: white; color: black; border: 2px solid #333; ';
    matchHtml += 'padding: 6px 10px; border-radius: 5px; font-weight: bold; cursor: move; user-select: none;">';
    matchHtml += match.court;
    matchHtml += '</div></td>';
    
   // Team 1 column
matchHtml += '<td style="padding: 8px; border: 1px solid #ddd; vertical-align: middle;">';
match.team1.forEach((player, playerIndex) => {
  const nhcClass = isNHCPlayer(player.name) ? ' nhc' : '';

  const manualClass = isManual ? ' manual-match' : '';
const gradeGapClass = team1HasGradeGap ? ' grade-gap' : '';
const isRepeatPartner = repeatPartners.some(rp => 
  rp.matchIndex === matchIndex && 
  rp.team === 1 && 
  rp.players.includes(player.name)
);
const isRepeatOpponent = repeatOpponents.some(ro => 
  ro.matchIndex === matchIndex && 
  (ro.player1 === player.name || ro.player2 === player.name)
);
const repeatClass = isRepeatPartner ? ' repeat-partner' : '';
const opponentClass = isRepeatOpponent ? ' repeat-opponent' : '';
  
  matchHtml += '<span class="player-box' + nhcClass + repeatClass + opponentClass + manualClass + gradeGapClass + '" draggable="true" ';
  matchHtml += 'data-type="player" data-match="' + matchIndex + '" data-team="1" data-player="' + playerIndex + '" ';
  matchHtml += 'data-name="' + player.name + '" data-grade="' + player.grade + '" ';
  matchHtml += 'style="display: inline-block; background: white; border: 2px solid #ddd; padding: 4px 8px; margin: 2px; ';
  matchHtml += 'border-radius: 5px; cursor: move; user-select: none; transition: all 0.2s ease; font-weight: bold;';  
  // Apply styling based on player attributes
  if (isNHCPlayer(player.name)) {
    matchHtml += ' background-color: #8ec6e0; font-weight: bold;';  // Light blue
  }
  
  if (isRepeatPartner) matchHtml += ' background-color: #ff9800; border: 2px solid #f57c00; font-weight: bold;';
if (isManual) matchHtml += ' background-color: #fff8dc; border: 2px solid #ffc107;';
  
  matchHtml += '">';
  const downArrow = hasPlayedDownBefore(player.name, currentSetNumber) ? '‚Üì' : '';
// Get plus/minus from playerRows data
const plusMinus = getPlayerPlusMinus(player.name, data);

matchHtml += downArrow + player.name + ' (' + translateGrade(player.grade) + plusMinus + ')';
  matchHtml += '</span>';
  if (playerIndex === 0) matchHtml += ', ';
});
matchHtml += '</td>';
    
    // Team 2 column
matchHtml += '<td style="padding: 8px; border: 1px solid #ddd; vertical-align: middle;">';

match.team2.forEach((player, playerIndex) => {
  const nhcClass = isNHCPlayer(player.name) ? ' nhc' : '';
  const manualClass = isManual ? ' manual-match' : '';
const gradeGapClass = team2HasGradeGap ? ' grade-gap' : '';
 const isRepeatPartner = repeatPartners.some(rp => 
  rp.matchIndex === matchIndex && 
  rp.team === 2 && 
  rp.players.includes(player.name)
);
const isRepeatOpponent = repeatOpponents.some(ro => 
  ro.matchIndex === matchIndex && 
  (ro.player1 === player.name || ro.player2 === player.name)
);
const repeatClass = isRepeatPartner ? ' repeat-partner' : '';
const opponentClass = isRepeatOpponent ? ' repeat-opponent' : '';
  
  matchHtml += '<span class="player-box' + nhcClass + repeatClass + opponentClass + manualClass + gradeGapClass + '" draggable="true" ';
  matchHtml += 'data-type="player" data-match="' + matchIndex + '" data-team="2" data-player="' + playerIndex + '" ';
  matchHtml += 'data-name="' + player.name + '" data-grade="' + player.grade + '" ';
  matchHtml += 'style="display: inline-block; background: white; border: 2px solid #ddd; padding: 4px 8px; margin: 2px; ';
  matchHtml += 'border-radius: 5px; cursor: move; user-select: none; transition: all 0.2s ease; font-weight: bold;';
  
  // Apply styling based on player attributes
  if (isNHCPlayer(player.name)) {
    matchHtml += ' background-color: #8ec6e0; font-weight: bold;';  // Light blue
  }
  
  if (isRepeatPartner) matchHtml += ' background-color: #ff9800; border: 2px solid #f57c00; font-weight: bold;';
if (isManual) matchHtml += ' background-color: #fff8dc; border: 2px solid #ffc107;';
  
  matchHtml += '">';
  const downArrow = hasPlayedDownBefore(player.name, currentSetNumber) ? '‚Üì' : '';
// Get plus/minus from playerRows data
const plusMinus = getPlayerPlusMinus(player.name, data);

matchHtml += downArrow + player.name + ' (' + translateGrade(player.grade) + plusMinus + ')';
  matchHtml += '</span>';
  if (playerIndex === 0) matchHtml += ', ';
});
matchHtml += '</td>';

// Lock button column
matchHtml += '<td style="padding: 8px; text-align: center; border: 1px solid #ddd;">';
if (!match.isManual) {
  matchHtml += `<button onclick="lockMatch(${matchIndex})" style="padding: 4px 8px; font-size: 12px; cursor: pointer;">Lock</button>`;
} else {
  // Find the index in manualMatches array
  const manualIndex = manualMatches.findIndex(m => 
    m.court === match.court &&
    m.team1.length === match.team1.length &&
    m.team1.every((p, i) => p.name === match.team1[i].name)
  );
  matchHtml += `<button onclick="removeManualMatch(${manualIndex})" style="padding: 4px 8px; font-size: 12px; cursor: pointer; background: #28a745; color: white; border: none; border-radius: 3px;">Unlock</button>`;
}
matchHtml += '</td>';

matchHtml += '</tr>';
});  // ‚Üê CLOSING THE MAIN allMatches.forEach LOOP
  
  matchHtml += '</table>';

// Add legend
matchHtml += `
<div style="background: #f8f9fa; border: 1px solid #ddd; border-radius: 8px; padding: 15px; margin: 20px 0;">
  <div style="font-weight: bold; font-size: 16px; margin-bottom: 10px; color: #333;">Player Color Legend:</div>
  <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 8px;">
    <div style="display: flex; align-items: center; gap: 8px; font-size: 14px;">
      <div style="width: 40px; height: 20px; border: 2px solid #ddd; border-radius: 4px; font-size: 11px; text-align: center; line-height: 16px; font-weight: bold; background-color: #8ec6e0;">NHC</div>
      <span>No Hard Courts</span>
    </div>
  
<div style="display: flex; align-items: center; gap: 8px; font-size: 14px;">
  <div style="width: 40px; height: 20px; border: 2px solid #ff8c42; border-radius: 4px; font-size: 11px; text-align: center; line-height: 16px; font-weight: bold; background: repeating-linear-gradient(45deg, white 0px, white 6px, #ff8c42 6px, #ff8c42 7px);">GAP</div>
  <span>Grade gap >1</span>
</div>
    <div style="display: flex; align-items: center; gap: 8px; font-size: 14px;">
      <div style="width: 40px; height: 20px; border: 2px solid #f57c00; border-radius: 4px; font-size: 11px; text-align: center; line-height: 16px; font-weight: bold; background-color: #ff9800;">RPP</div>
      <span>Repeat Partner (all)</span>
    </div>
    <div style="display: flex; align-items: center; gap: 8px; font-size: 14px;">
      <div style="width: 40px; height: 20px; border: 3px dashed #dc3545; border-radius: 4px; font-size: 11px; text-align: center; line-height: 14px; font-weight: bold; background-color: white;">RO</div>
      <span>Repeat Opponent (last 2 sets)</span>
    </div>
    <div style="display: flex; align-items: center; gap: 8px; font-size: 14px;">
      <div style="display: flex; align-items: center; gap: 8px; font-size: 14px;">
  <div style="width: 40px; height: 20px; border: 2px solid #666666; border-radius: 4px; font-size: 11px; text-align: center; line-height: 16px; font-weight: bold; background-color: #e6e6e6;">MAN</div>
  <span>Manual Match</span>
</div>
    </div>
<div style="display: flex; align-items: center; gap: 8px; font-size: 14px;">
      <div style="color: #cc0000; font-weight: bold; font-size: 16px;">‚Üì</div>
      <span>Played down previously</span>
    </div>
  </div>
</div>`;
  
  matchResults.innerHTML = matchHtml;
  matchesDiv.style.display = 'block';
  
  // Update current matches to include manual matches
  currentMatches = allMatches;
  
  setTimeout(() => initializeDragAndDrop(), 100);
saveDataToStorage();
}

function lockAllMatches() {
  // Lock all matches that aren't already manual
  currentMatches.forEach((match, matchIndex) => {
    if (!match.isManual) {
      // Convert to manual match
      const lockedMatch = {
        court: match.court,
        team1: [...match.team1],
        team2: [...match.team2],
        format: match.format,
        note: "Locked after adjustments",
        isManual: true
      };
      
      manualMatches.push(lockedMatch);
      currentMatches[matchIndex].isManual = true;
      
      // Mark players and court as excluded in the manual match interface
      [...match.team1, ...match.team2].forEach(player => {
        const playerElement = document.querySelector(`[data-player-name="${player.name}"]`);
        if (playerElement) {
          playerElement.classList.add('excluded');
        }
      });
      
      const courtElement = document.querySelector(`[data-court="${match.court}"]`);
      if (courtElement) {
        courtElement.classList.add('excluded');
      }
    }
  });
  
  updateManualMatchDisplay();
  refreshDisplay();
}

function unlockAllMatches() {
  // Create a copy of manual matches to iterate over
  const matchesToUnlock = [...manualMatches];
  
  // Unlock each manual match
  matchesToUnlock.forEach(() => {
    if (manualMatches.length > 0) {
      removeManualMatch(0); // Always remove the first one until none left
    }
  });
}

function lockMatch(matchIndex) {
  if (currentMatches[matchIndex].isManual) {
    alert("This match is already protected");
    return;
  }
  
  // Convert to manual match
  const match = currentMatches[matchIndex];
  const lockedMatch = {
    court: match.court,
    team1: [...match.team1],
    team2: [...match.team2],
    format: match.format,
    note: "Locked after adjustments",
    isManual: true
  };
  
  manualMatches.push(lockedMatch);
  currentMatches[matchIndex].isManual = true;
  
  // Mark players and court as excluded in the manual match interface
  [...match.team1, ...match.team2].forEach(player => {
    const playerElement = document.querySelector(`[data-player-name="${player.name}"]`);
    if (playerElement) {
      playerElement.classList.add('excluded');
    }
  });
  
  const courtElement = document.querySelector(`[data-court="${match.court}"]`);
  if (courtElement) {
    courtElement.classList.add('excluded');
  }
  
  // Update the manual match display
  updateManualMatchDisplay();
  
  // Silent protection - no alert message
  refreshDisplay();
}
function initializeDragAndDrop() {
  log("Initializing drag and drop");
  
  let draggedElement = null;
  let draggedData = null;
  
  const matchResults = document.getElementById('matchResults');
  if (!matchResults) return;
  
  const newMatchResults = matchResults.cloneNode(true);
  matchResults.parentNode.replaceChild(newMatchResults, matchResults);
  
 newMatchResults.addEventListener('dragstart', function(e) {
    if (e.target.getAttribute('draggable') === 'true') {
      draggedElement = e.target;
      
      if (e.target.classList.contains('sat-off-player')) {
        draggedData = {
          type: 'sat-off-player',
          name: e.target.dataset.name,
          grade: parseInt(e.target.dataset.grade)
        };
      } else {
        draggedData = {
          type: e.target.dataset.type,
          match: parseInt(e.target.dataset.match),
          team: e.target.dataset.team,
          player: parseInt(e.target.dataset.player),
          court: e.target.dataset.court,
          name: e.target.dataset.name,
          grade: e.target.dataset.grade
        };
      }
      
      e.target.classList.add('dragging');
      log("Dragging: " + (draggedData.name || draggedData.court));
    }
  });
  
  newMatchResults.addEventListener('dragend', function(e) {
  if (e.target.getAttribute('draggable') === 'true') {
    e.target.classList.remove('dragging');
    newMatchResults.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
    stopAutoScroll(); // Stop any auto-scrolling when drag ends
  }
});
  
  newMatchResults.addEventListener('dragover', function(e) {
  e.preventDefault();
  // Check if we should auto-scroll based on mouse position
  checkAutoScroll(e);
});
  
  newMatchResults.addEventListener('dragenter', function(e) {
    if (e.target.classList.contains('player-box') || e.target.classList.contains('court-box')) {
      e.target.classList.add('drag-over');
    }
  });
  
  newMatchResults.addEventListener('dragleave', function(e) {
    if (e.target.classList.contains('player-box') || e.target.classList.contains('court-box')) {
      e.target.classList.remove('drag-over');
    }
  });
  
  newMatchResults.addEventListener('drop', function(e) {
    e.preventDefault();
    
    if (!draggedElement || !draggedData) return;
    
    const dropTarget = e.target;
    if (dropTarget === draggedElement) return;
    
    dropTarget.classList.remove('drag-over');
    
    if (draggedData.type === 'player' && dropTarget.classList.contains('player-box')) {
      const targetData = {
        match: parseInt(dropTarget.dataset.match),
        team: dropTarget.dataset.team,
        player: parseInt(dropTarget.dataset.player),
        name: dropTarget.dataset.name
      };
      
      log("Swapping players: " + draggedData.name + " ‚Üî " + targetData.name);
      swapPlayers(draggedData, targetData);
      // Update stored data
      if (allSetsData[currentSetNumber]) {
        allSetsData[currentSetNumber].matches = JSON.parse(JSON.stringify(currentMatches));
      }
      refreshDisplay();
    }
    else if (draggedData.type === 'court' && dropTarget.classList.contains('court-box')) {
      const targetMatch = parseInt(dropTarget.dataset.match);
      const targetCourt = dropTarget.dataset.court;
      
      log("Swapping courts: " + draggedData.court + " ‚Üî " + targetCourt);
      swapCourts(draggedData.match, targetMatch);
      // Update stored data
      if (allSetsData[currentSetNumber]) {
        allSetsData[currentSetNumber].matches = JSON.parse(JSON.stringify(currentMatches));
      }
      refreshDisplay();
    }
    else if (draggedData.type === 'sat-off-player' && dropTarget.classList.contains('player-box') && !dropTarget.classList.contains('sat-off-player')) {
      const targetData = {
        match: parseInt(dropTarget.dataset.match),
        team: dropTarget.dataset.team,
        player: parseInt(dropTarget.dataset.player),
        name: dropTarget.dataset.name
      };
      
      log("Swapping sat-off player: " + draggedData.name + " ‚Üî " + targetData.name);
      swapSatOffWithPlayer(draggedData, targetData);
      refreshDisplay();
    }
    
    draggedElement = null;
    draggedData = null;
stopAutoScroll(); // Stop auto-scrolling when drop completes
  });
}

function swapPlayers(player1, player2) {
  const match1 = currentMatches[player1.match];
  const match2 = currentMatches[player2.match];
  
  const team1 = player1.team === '1' ? match1.team1 : match1.team2;
  const team2 = player2.team === '1' ? match2.team1 : match2.team2;
  
  const tempPlayer = { ...team1[player1.player] };
  team1[player1.player] = { ...team2[player2.player] };
  team2[player2.player] = tempPlayer;

// Update match formats after swap
updateMatchFormat(currentMatches[player1.match]);
updateMatchFormat(currentMatches[player2.match]);

// Mark both matches as manually adjusted (for Excel export tracking)
currentMatches[player1.match].manuallyAdjusted = true;
currentMatches[player2.match].manuallyAdjusted = true;
log(`Marked matches ${player1.match} and ${player2.match} as manually adjusted`);
}

function updateMatchFormat(match) {
  if (!match || !match.team1 || !match.team2) return;
// Debug: Check what the data looks like
  console.log("currentData:", currentData);
  console.log("sortedMen:", currentData.sortedMen);
  console.log("sortedWomen:", currentData.sortedWomen);
  console.log("First player from team1:", match.team1[0]);
  
  // Count players by gender in each team
  const team1Men = match.team1.filter(p => getPlayerGender(p.name, currentData) === 'M').length;
  const team1Women = match.team1.filter(p => getPlayerGender(p.name, currentData) === 'F').length;
  const team2Men = match.team2.filter(p => getPlayerGender(p.name, currentData) === 'M').length;
  const team2Women = match.team2.filter(p => getPlayerGender(p.name, currentData) === 'F').length;
  
  // Determine correct format
  if (team1Men === 1 && team1Women === 1 && team2Men === 1 && team2Women === 1) {
    match.format = "Mixed Doubles";
  } else if (team1Men === 2 && team2Men === 2) {
    match.format = "Same-Sex Doubles (Men)";
  } else if (team1Women === 2 && team2Women === 2) {
    match.format = "Same-Sex Doubles (Women)";
  } else {
    match.format = "Mixed Gender";
  }
}

function getPlayerGender(playerName, data) {
  // Check sorted arrays first
  let menPlayer = data.sortedMen ? data.sortedMen.find(p => p.name === playerName) : null;
  let womenPlayer = data.sortedWomen ? data.sortedWomen.find(p => p.name === playerName) : null;
  
  // If not found, check available arrays
  if (!menPlayer && data.availableMen) {
    menPlayer = data.availableMen.find(p => p.name === playerName);
  }
  if (!womenPlayer && data.availableWomen) {
    womenPlayer = data.availableWomen.find(p => p.name === playerName);
  }
  
  return menPlayer ? 'M' : (womenPlayer ? 'F' : null);
}

function swapCourts(match1Index, match2Index) {
  const tempCourt = currentMatches[match1Index].court;
  currentMatches[match1Index].court = currentMatches[match2Index].court;
  currentMatches[match2Index].court = tempCourt;
}

function swapSatOffWithPlayer(satOffData, targetData) {
  // Find the sat-off player in playerRows and mark as no longer sitting off
  const satOffPlayerRow = playerRows.find(p => p.name === satOffData.name);
  if (satOffPlayerRow) {
    satOffPlayerRow.so = false;
  }
  
  // Find the target player and mark them as sitting off
  const targetPlayerRow = playerRows.find(p => p.name === targetData.name);
  if (targetPlayerRow) {
    targetPlayerRow.so = true;
  }
  
  // Get the target player's current data from the match
  const match = currentMatches[targetData.match];
  const team = targetData.team === '1' ? match.team1 : match.team2;
  const targetPlayerData = team[targetData.player];
  
  // Replace the target player with the sat-off player in the match
  team[targetData.player] = {
    name: satOffData.name,
    grade: satOffData.grade,
    // Copy other properties from playerRows
    nhc: satOffPlayerRow.nhc,
    plusMinus: satOffPlayerRow.plusMinus
  };
  
  // Update match format after the swap
  updateMatchFormat(match);
  
  // Mark match as manually adjusted (for Excel export tracking)
  match.manuallyAdjusted = true;
  log(`Marked match ${targetData.match} as manually adjusted (sat-off swap)`);
  
  // Update stored data
  if (allSetsData[currentSetNumber]) {
    allSetsData[currentSetNumber].matches = JSON.parse(JSON.stringify(currentMatches));
    // Update sat-off players list
    allSetsData[currentSetNumber].satOffPlayers = playerRows.filter(p => p.so).map(p => p.name);
  }
  
  // Save to localStorage
  saveDataToStorage();
  
  log(`Swapped ${satOffData.name} (was sitting off) with ${targetData.name} (now sitting off)`);
}

function refreshDisplay() {
  // Update the player input table to reflect current SO status
  updatePlayerTableSOStatus();
  
  // Refresh the match display
  displayResults(currentData, currentMatches);
  
  // Update full screen display if open
  updateFullScreenDisplay();
}
function updatePlayerTableSOStatus() {
  // Get current list of players sitting off (from the current matches and sat-off section)
  const currentSatOffPlayers = playerRows.filter(p => p.so).map(p => p.name);
  
  // Update all player rows to match current status
  playerRows.forEach((player, index) => {
    const soCheckbox = document.getElementById(`so-${index}`);
    if (soCheckbox) {
      soCheckbox.checked = player.so;
    }
  });
  
  log(`Updated player table SO status: ${currentSatOffPlayers.length} players sitting off`);
}

function startAutoScroll(direction, speed) {
  stopAutoScroll(); // Clear any existing scroll
  
  autoScrollSpeed = speed;
  autoScrollInterval = setInterval(() => {
    if (direction === 'up') {
      window.scrollBy(0, -autoScrollSpeed);
    } else if (direction === 'down') {
      window.scrollBy(0, autoScrollSpeed);
    }
  }, 16); // ~60fps
}

function stopAutoScroll() {
  if (autoScrollInterval) {
    clearInterval(autoScrollInterval);
    autoScrollInterval = null;
    autoScrollSpeed = 0;
  }
}

function checkAutoScroll(event) {
  const viewportHeight = window.innerHeight;
  const mouseY = event.clientY;
  
  // Check if mouse is near top of viewport
  if (mouseY < SCROLL_ZONE_SIZE) {
    const intensity = (SCROLL_ZONE_SIZE - mouseY) / SCROLL_ZONE_SIZE;
    const speed = Math.max(1, intensity * SCROLL_SPEED_MAX);
    startAutoScroll('up', speed);
  }
  // Check if mouse is near bottom of viewport
  else if (mouseY > viewportHeight - SCROLL_ZONE_SIZE) {
    const intensity = (mouseY - (viewportHeight - SCROLL_ZONE_SIZE)) / SCROLL_ZONE_SIZE;
    const speed = Math.max(1, intensity * SCROLL_SPEED_MAX);
    startAutoScroll('down', speed);
  }
  // Mouse is in the middle - stop scrolling
  else {
    stopAutoScroll();
  }
}

// Print match sheet function
function printMatchSheet(data, matches) {
  try {
    const printWindow = window.open('', '_blank', 'width=1200,height=800');
    
    const currentSetNum = parseInt(document.getElementById('setNumberSelector').value);
    const satOffPlayers = playerRows.filter(p => p.name && p.so).map(p => p.name);
    const restingPlayers = playerRows.filter(p => p.name && p.resting).map(p => p.name);
    
    let printHTML = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Tennis Match Sheet - Set ${currentSetNum}</title>
  <style>
    body { 
      font-family: Arial, sans-serif; 
      margin: 20px; 
      background: white; 
      color: black;
      line-height: 1.4;
    }
   .header { 
  margin-bottom: 20px; 
  border-bottom: 1px solid black; 
  padding-bottom: 10px;
}
.header-info { 
  font-size: 16px; 
  font-weight: bold;
  margin: 0;
}
    .sat-off-section { 
      background: #f0f0f0; 
      border: 2px solid black; 
      padding: 15px; 
      margin: 20px 0; 
      border-radius: 5px;
    }
    .sat-off-title { 
      font-size: 18px; 
      font-weight: bold; 
      margin-bottom: 10px;
    }
   .matches-grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 15px;
  margin: 20px 0;
}
    .match-card {
      border: 2px solid #333;
      padding: 15px;
      border-radius: 8px;
      background: white;
      break-inside: avoid;
    }
    .match-card.manual {
      background: #fff8dc;
      border-color: #ffc107;
    }
    .team {
      margin-bottom: 15px;
    }
    .player-line {
  margin: 8px 0;
  font-size: 14px;
  display: flex;
  align-items: center;
 z-index: 11;
  position: relative;
}
.player-info {
  width: 220px;
  flex-shrink: 0;
overflow: visible;
  z-index: 1;
}
.player-name {
  font-weight: bold;
}
.court-boxes { 
  display: flex; 
  gap: 2px; 
  z-index: 10;
  position: relative;
}
.court-box {
  width: 20px;
  height: 20px;
  border: 1px solid #333;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 10px;
  font-weight: bold;
  background: white;
  flex-shrink: 0;
 z-index: 11;
  position: relative;
}
    .court-box.filled {
      background: white;
    }
    .court-box.team2 {
  background: white;
}
    .court-box.sat-off {
      background: white;
    }
    @media print {
      body { margin: 15px; font-size: 12px; }
      .matches-grid { grid-template-columns: repeat(2, 1fr); gap: 15px; }
      .match-card { padding: 10px; }
      .player-line { font-size: 12px; }
      .court-box { width: 18px; height: 18px; font-size: 9px; }
    }
  </style>
</head>
<body>
  <div class="header">
  <div style="display: flex; justify-content: space-between; align-items: center;">
    <div class="header-info">Date: ${new Date().toLocaleDateString()}</div>
    <div class="header-info">Set Number: ${currentSetNum}</div>
    <div class="header-info">Format: ${data.setFormatPreference}</div>
  </div>
</div>
`;

    if (restingPlayers.length > 0 || satOffPlayers.length > 0) {
      printHTML += `
  <div class="sat-off-section">
    <div style="display: flex; justify-content: space-between;">
      <div style="flex: 1;">
        <div class="sat-off-title">Resting:</div>
        <div class="sat-off-list">${restingPlayers.length > 0 ? restingPlayers.join(', ') : 'None'}</div>
      </div>
      <div style="flex: 1; text-align: right;">
        <div class="sat-off-title">Sitting Off:</div>
        <div class="sat-off-list">${satOffPlayers.length > 0 ? satOffPlayers.join(', ') : 'None'}</div>
      </div>
    </div>
  </div>
`;
    }

// Function to get court boxes with team position shading
function getCourtBoxes(playerName) {
  const boxes = [];
  for (let setNum = 1; setNum <= 6; setNum++) {
    let courtFound = false;
    let courtValue = '';
    let boxClass = 'court-box';
    
    if (setNum <= currentSetNum) {
      if (setNum === currentSetNum) {
        // Current set - check current matches
        matches.forEach(match => {
          // Check if player is in team1
          const inTeam1 = match.team1.some(p => p.name === playerName);
          // Check if player is in team2
          const inTeam2 = match.team2.some(p => p.name === playerName);
          
          if (inTeam1) {
  courtValue = match.court;
  boxClass = 'court-box filled'; // Team 1 - no dot
  courtFound = true;
} else if (inTeam2) {
  courtValue = match.court + '.';
  boxClass = 'court-box filled'; // Team 2 - with dot
  courtFound = true;
}
        });
      } else {
        // Previous sets - check stored data
        if (allSetsData[setNum] && allSetsData[setNum].matches) {
          allSetsData[setNum].matches.forEach(match => {
            // Check if player is in team1
            const inTeam1 = match.team1.some(p => p.name === playerName);
            // Check if player is in team2  
            const inTeam2 = match.team2.some(p => p.name === playerName);
            
           if (inTeam1) {
  courtValue = match.court;
  boxClass = 'court-box filled'; // Team 1 - no dot
  courtFound = true;
} else if (inTeam2) {
  courtValue = match.court + '.';
  boxClass = 'court-box filled'; // Team 2 - with dot
  courtFound = true;
}
          });
        }
      }
      
      // If player sat off, mark with 'X'
      if (!courtFound) {
        if (setNum < currentSetNum && allSetsData[setNum] && allSetsData[setNum].satOffPlayers && 
            allSetsData[setNum].satOffPlayers.includes(playerName)) {
          courtValue = 'X';
          boxClass = 'court-box sat-off';
        } else if (setNum === currentSetNum && satOffPlayers.includes(playerName)) {
          courtValue = 'X';
          boxClass = 'court-box sat-off';
        }
      }
    }
    
    boxes.push(`<div class="${boxClass}">${courtValue}</div>`);
  }
  return boxes.join('');
}

    printHTML += '<div class="matches-grid">';

    matches.forEach((match, index) => {
      const isManual = match.isManual || false;
      const cardClass = isManual ? 'match-card manual' : 'match-card';
      
      printHTML += `<div class="${cardClass}">`;
      
      // Team 1
      printHTML += '<div class="team">';
      match.team1.forEach(player => {
        printHTML += `<div class="player-line">`;
        printHTML += `<div class="player-info">`;
        printHTML += `<span class="player-name">${player.name}</span> (${translateGrade(player.grade)})`;
        printHTML += `</div>`;
        printHTML += `<div class="court-boxes">${getCourtBoxes(player.name)}</div>`;
        printHTML += `</div>`;
      });
      printHTML += '</div>';

      // Team 2 (with gap)
      printHTML += '<div class="team" style="margin-top: 15px;">';
      match.team2.forEach(player => {
        printHTML += `<div class="player-line">`;
        printHTML += `<div class="player-info">`;
        printHTML += `<span class="player-name">${player.name}</span> (${translateGrade(player.grade)})`;
        printHTML += `</div>`;
        printHTML += `<div class="court-boxes">${getCourtBoxes(player.name)}</div>`;
        printHTML += `</div>`;
      });
      printHTML += '</div>';
      
      printHTML += '</div>';
    });

    printHTML += '</div>';
    printHTML += '</body></html>';

    printWindow.document.write(printHTML);
    printWindow.document.close();
    
    setTimeout(() => {
      printWindow.focus();
      printWindow.print();
    }, 250);
    
    log("Print dialog opened for match sheet with court history boxes");
    
  } catch (error) {
    alert("Error creating print sheet: " + error.message);
    log("Error creating print sheet: " + error.message);
  }
}

function openFullScreenDisplay() {
  if (!currentData || !currentMatches) {
    alert('No matches to display. Please generate matches first.');
    return;
  }

  // Check if window already exists and is open
  if (fullScreenDisplayWindow && !fullScreenDisplayWindow.closed) {
    fullScreenDisplayWindow.focus();
    updateFullScreenDisplay();
    return;
  }

  fullScreenDisplayWindow = window.open('', 'FullScreenDisplay', 'fullscreen=yes,scrollbars=yes,menubar=no,toolbar=no,location=no,status=no');
  
  const currentSetNum = parseInt(document.getElementById('setNumberSelector').value);
  
  let printHTML = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Tennis Match Sheet - Set ${currentSetNum}</title>
  <style>
    body { 
      font-family: Arial, sans-serif; 
      margin: 5px; 
      background: white; 
      color: black;
      line-height: 1.3;
    }
    @page { size: landscape; }
   
    .sat-off-section { 
      background: #f0f0f0; 
      border: 2px solid black; 
      padding: 15px; 
      margin: 20px 0; 
      border-radius: 5px;
    }
    .sat-off-title { 
      font-size: 18px; 
      font-weight: bold; 
      margin-bottom: 10px;
    }
    .sat-off-list { 
      font-size: 16px; 
      font-weight: bold;
    }
    .page {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      padding: 12px 16px;
    }

    .bottom-stack {
      display: flex;
      flex-direction: column;
      gap: 0px;
      margin-top: auto;
    }
 
    .matches-container {
      display: flex;
      gap: 40px;
      justify-content: space-between;
      margin: 0;
    }

    .match-table {
      width: 48%;
      border-collapse: collapse;
      margin: 5px 0;
    }
    .match-table th {
      background: #f8f9fa;
      border: 2px solid #333;
      padding: 4px 12px;
      text-align: center;
      font-weight: bold;
      font-size: 14px;
    }
    .match-table td {
      border: 1px solid #333;
      padding: 4px 8px;
      vertical-align: middle;
    }
  
    .court-number {
      background: none;
      color: black;
      border: none;
      padding: 0;
      border-radius: 0;
      font-weight: bold;
      display: inline-block;
    }
    .team-cell {
      font-size: 18px;
    }
    .match-table th:nth-child(1) {
      width: 10%;
    }
    .match-table th:nth-child(2), .match-table th:nth-child(3) {
      width: 45%;
    }
  </style>
</head>
<body>
  <div id="contentContainer"></div>
</body>
</html>`;

  fullScreenDisplayWindow.document.write(printHTML);
  fullScreenDisplayWindow.document.close();
  fullScreenDisplayWindow.focus();
  
  // Initial update
  updateFullScreenDisplay();
}

function updateFullScreenDisplay() {
  if (!fullScreenDisplayWindow || fullScreenDisplayWindow.closed) {
    return;
  }
  
  if (!currentData || !currentMatches) {
    return;
  }
  
  const currentSetNum = parseInt(document.getElementById('setNumberSelector').value);
  
  const currentSet = parseInt(document.getElementById('setNumberSelector').value);
  const restingPlayers = playerRows.filter(p => {
    if (!p.name || !p.resting) return false;
    // Check if player has any available set from current set onward
    for (let s = currentSet; s <= 6; s++) {
      if (!p.unavailableSets || !p.unavailableSets[`set${s}`]) {
        return true; // Has at least one available future set
      }
    }
    return false; // Unavailable for all remaining sets - don't show as resting
  }).map(p => p.name);
  
  const satOffPlayers = playerRows.filter(p => p.name && p.so).map(p => p.name);
  
  let contentHTML = `
  <div class="page">
    <div class="bottom-stack">
`;

  // Create two-column table format
  const midPoint = Math.ceil(currentMatches.length / 2);

  contentHTML += `
<div class="matches-container">
  <table class="match-table">
    <tr>
      <th>Court</th>
      <th>Team 1</th>
      <th>Team 2</th>
    </tr>
`;

  // First table - first half of matches
  for (let i = 0; i < midPoint; i++) {
    const match = currentMatches[i];
    const team1Str = match.team1.map(p => `<strong style="color: ${p.name.endsWith(' (V)') ? 'green' : (p.gender === 'F' ? '#2563eb' : 'black')};">${p.name}</strong>`).join(', ');
    const team2Str = match.team2.map(p => `<strong style="color: ${p.name.endsWith(' (V)') ? 'green' : (p.gender === 'F' ? '#2563eb' : 'black')};">${p.name}</strong>`).join(', ');
    const isManual = match.isManual || false;
    
    contentHTML += `
    <tr${isManual ? ' class="manual"' : ''}>
      <td style="text-align: center;">
        <div class="court-number">${match.court}</div>
      </td>
      <td class="team-cell">${team1Str}</td>
      <td class="team-cell">${team2Str}</td>
    </tr>
`;
  }

  contentHTML += `
  </table>
  <table class="match-table">
    <tr>
      <th>Court</th>
      <th>Team 1</th>
      <th>Team 2</th>
    </tr>
`;

  // Second table - second half of matches  
  for (let i = midPoint; i < currentMatches.length; i++) {
    const match = currentMatches[i];
    const team1Str = match.team1.map(p => `<strong style="color: ${p.name.endsWith(' (V)') ? 'green' : (p.gender === 'F' ? '#2563eb' : 'black')};">${p.name}</strong>`).join(', ');
    const team2Str = match.team2.map(p => `<strong style="color: ${p.name.endsWith(' (V)') ? 'green' : (p.gender === 'F' ? '#2563eb' : 'black')};">${p.name}</strong>`).join(', ');
    const isManual = match.isManual || false;
    
    contentHTML += `
    <tr${isManual ? ' class="manual"' : ''}>
      <td style="text-align: center;">
        <div class="court-number">${match.court}</div>
      </td>
      <td class="team-cell">${team1Str}</td>
      <td class="team-cell">${team2Str}</td>
    </tr>
`;
  }

  contentHTML += `
  </table>
</div>
`;

  // Always show sitting off section with Set number
  contentHTML += `
  <div class="sat-off-section">
    <div style="display: flex; align-items: center; justify-content: space-between; font-size: 18px; font-weight: bold;">
      <div style="flex: 1; text-align: left;">Resting: ${restingPlayers.length > 0 ? restingPlayers.join(', ') : 'None'}</div>
      <div style="flex: 1; text-align: center;">Set ${currentSetNum}</div>
      <div style="flex: 1; text-align: right;">Sitting Off: ${satOffPlayers.length > 0 ? satOffPlayers.join(', ') : 'None'}</div>
    </div>
  </div>
    </div>  <!-- /.bottom-stack -->
  </div>    <!-- /.page -->
`;

  const container = fullScreenDisplayWindow.document.getElementById('contentContainer');
  if (container) {
    container.innerHTML = contentHTML;
  }
}

function createPlayerSummarySheet(wb) {
  // Collect all unique players from all sets
  const playerMap = new Map(); // Use Map to store unique players by name
  
  const completedSets = Object.keys(allSetsData).sort((a, b) => parseInt(a) - parseInt(b));
  
  completedSets.forEach(setNum => {
    const setData = allSetsData[setNum];
    
    // Get all men from this set
    if (setData.data.availableMen) {
      setData.data.availableMen.forEach(player => {
        if (!playerMap.has(player.name)) {
          playerMap.set(player.name, {
            name: player.name,
            grade: player.grade,
            gender: 'M'
          });
        }
      });
    }
    
    // Get all women from this set
    if (setData.data.availableWomen) {
      setData.data.availableWomen.forEach(player => {
        if (!playerMap.has(player.name)) {
          playerMap.set(player.name, {
            name: player.name,
            grade: player.grade,
            gender: 'F'
          });
        }
      });
    }
  });
  
  // Convert Map to array and sort alphabetically by first name
  const playerList = Array.from(playerMap.values()).sort((a, b) => {
    return a.name.localeCompare(b.name);
  });
  
  // Create worksheet data
  const wsData = [];
  
  // Get current date in format "October 26, 2025"
  const dateOptions = { year: 'numeric', month: 'long', day: 'numeric' };
  const formattedDate = new Date().toLocaleDateString('en-US', dateOptions);
  
  // Add header rows
  wsData.push([`Total list of players on: ${formattedDate}`]);
  wsData.push([`Total Players on the day: ${playerList.length}`]);
  wsData.push([]); // Blank row
  wsData.push(['Name', 'Grade', 'Gender']); // Column headers
  
  // Add player data
  playerList.forEach(player => {
    wsData.push([
      player.name,
      translateGrade(player.grade),
      player.gender
    ]);
  });
  
  // Create worksheet
  const ws = XLSX.utils.aoa_to_sheet(wsData);
  
  // Set column widths
  ws['!cols'] = [
    { wch: 30 }, // Name
    { wch: 10 }, // Grade
    { wch: 10 }  // Gender
  ];
  
  // Add underline to headers (row 4, which is index 3)
  if (ws['A4']) ws['A4'].s = { font: { underline: true, bold: true } };
  if (ws['B4']) ws['B4'].s = { font: { underline: true, bold: true } };
  if (ws['C4']) ws['C4'].s = { font: { underline: true, bold: true } };
  
  // Add sheet to workbook
  XLSX.utils.book_append_sheet(wb, ws, 'Player Summary');
}

function downloadResults(data, matches) {
  try {
    const wb = XLSX.utils.book_new();
    
    // Get all completed sets from storage
    const completedSets = Object.keys(allSetsData).sort((a, b) => parseInt(a) - parseInt(b));
    
    if (completedSets.length === 0) {
      // Fallback to current set if no stored data
      createSingleSetSheet(wb, data, matches, currentSetNumber);
    } else {
      // Create a sheet for each completed set
      completedSets.forEach(setNum => {
        const setData = allSetsData[setNum];
       createSingleSetSheet(wb, setData.data, setData.matches, setNum, setData.restingPlayers, setData.satOffPlayers);
      });
    }
    
 // Add Player Summary sheet if we have completed sets
    if (completedSets.length > 0) {
      createPlayerSummarySheet(wb);
    }
    
    // Create a readable date format like "9 Nov 25"
const now = new Date();
const day = now.getDate();
const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
const month = months[now.getMonth()];
const year = now.getFullYear().toString().slice(-2);
const dateStr = `${day} ${month} ${year}`;

const filename = `Social Tennis Results ${dateStr}.xlsx`;
    
    // Download the file
    XLSX.writeFile(wb, filename);
    
    log("Excel file downloaded: " + filename + " with " + (completedSets.length || 1) + " sheets");
    
  } catch (error) {
    alert("Error creating Excel file: " + error.message);
    log("Error creating Excel file: " + error.message);
  }
}

function createSingleSetSheet(wb, data, matches, setNumber, restingPlayers = [], satOffPlayers = []) {
  const wsData = [];
  
  // Add header information
  wsData.push(['Date', new Date().toISOString().split('T')[0]]);
  wsData.push(['Set Number', 'Set ' + setNumber]);
  wsData.push(['Set Format Preference', data.setFormatPreference]);
  wsData.push([]);
  
  // Add match headers AND player list headers on the same row (row 5)
  // Updated headers to include +/- column
  wsData.push(['Court', 'Team 1', 'Team 2', 'Match Format', 'Match Type', 'Resting Players', 'Sat Off Players', '', 'Total Men Players', 'Grade', 'NHC', 'Resting', '+/-', 'PSO', '', 'Total Women Players', 'Grade', 'NHC', 'Resting', '+/-', 'PSO']);
  
  // Determine how many rows we need (matches vs players)
  const maxRows = Math.max(matches.length, data.availableMen.length, data.availableWomen.length);
  
  // Add data rows
  for (let i = 0; i < maxRows; i++) {
    const row = ['', '', '', '', '', '', '', '']; // Columns A-H (matches + spacing)
    
   // Add match data if we have a match for this row
    if (i < matches.length) {
      const match = matches[i];
      const team1Str = match.team1.map(p => `${p.name} (${translateGrade(p.grade)}${p.plusMinus || ''})`).join(', ');
      const team2Str = match.team2.map(p => `${p.name} (${translateGrade(p.grade)}${p.plusMinus || ''})`).join(', ');
      const restingPlayer = i < restingPlayers.length ? restingPlayers[i] : '';
      const satOffPlayer = i < satOffPlayers.length ? satOffPlayers[i] : '';
      // Show 'Manual' if match was locked OR adjusted via drag-drop
      const matchType = (match.isManual || match.manuallyAdjusted) ? 'Manual' : 'Auto';
      
      row[0] = match.court;           // A: Court
      row[1] = team1Str;              // B: Team 1
      row[2] = team2Str;              // C: Team 2
      row[3] = match.format;          // D: Match Format
      row[4] = matchType;             // E: Match Type
      row[5] = restingPlayer;         // F: Resting Players
      row[6] = satOffPlayer;          // G: Sat Off Players
      row[7] = '';                    // H: Spacing
    }
    
   // Add men's data if we have a man for this row (columns I-N, now includes +/-)
    if (i < data.availableMen.length) {
      const player = data.availableMen[i];
      row[8] = player.name;           // I: Men's names
      row[9] = translateGrade(player.grade);  // J: Men's grade
      row[10] = player.nhc ? 'y' : ''; // K: Men's NHC
      row[11] = player.resting ? 'y' : ''; // L: Men's resting
      row[12] = player.plusMinus || ''; // M: Men's +/-
      row[13] = player.pso ? 'y' : ''; // N: Men's PSO
    }
    
    // Column O: Spacing between men and women
    row[14] = '';
    
    // Add women's data if we have a woman for this row (columns P-U, now includes +/-)
    if (i < data.availableWomen.length) {
      const player = data.availableWomen[i];
      row[15] = player.name;          // P: Women's names
      row[16] = translateGrade(player.grade); // Q: Women's grade
      row[17] = player.nhc ? 'y' : ''; // R: Women's NHC
      row[18] = player.resting ? 'y' : ''; // S: Women's resting
      row[19] = player.plusMinus || ''; // T: Women's +/-
      row[20] = player.pso ? 'y' : ''; // U: Women's PSO
    }
    
    wsData.push(row);
  }
  
  // Create worksheet
  const ws = XLSX.utils.aoa_to_sheet(wsData);
  
  // Set column widths 
 ws['!cols'] = [
    { wch: 20 }, // A: Court
    { wch: 50 }, // B: Team 1
    { wch: 50 }, // C: Team 2
    { wch: 25 }, // D: Match Format
    { wch: 10 }, // E: Match Type
    { wch: 20 }, // F: Resting Players
    { wch: 20 }, // G: Sat Off Players
    { wch: 3 },  // H: Spacing
    { wch: 20 }, // I: Men's names
    { wch: 8 },  // J: Men's grade
    { wch: 6 },  // K: Men's NHC
    { wch: 8 },  // L: Men's resting
    { wch: 6 },  // M: Men's +/-
    { wch: 6 },  // N: Men's PSO
    { wch: 3 },  // O: Spacing
    { wch: 20 }, // P: Women's names
    { wch: 8 },  // Q: Women's grade
    { wch: 6 },  // R: Women's NHC
    { wch: 8 },  // S: Women's resting
    { wch: 6 },  // T: Women's +/-
    { wch: 6 }   // U: Women's PSO
  ];
  
  // Add worksheet to workbook
  XLSX.utils.book_append_sheet(wb, ws, 'Set ' + setNumber + ' Summary');
}
// Initialize the page with auto-restore
document.addEventListener('DOMContentLoaded', () => {
  initializeCourts();
  loadMemberListOnStartup();
  
  // Try to load saved data
  setTimeout(() => {
    loadDataFromStorage();
  }, 500);
  
  // Auto-connect to check-in server (silent - no error if server not running)
  setTimeout(() => {
    tryAutoConnect();
  }, 500);
});
// Download and print functions
document.getElementById('downloadBtn').onclick = function() {
  if (currentData && currentMatches) {
    // Download the Excel results file
    downloadResults(currentData, currentMatches);
    
    // Wait a brief moment, then download the updated member list
    setTimeout(() => {
      generateUpdatedMasterList();
    }, 500);
  } else {
    alert('No matches to download. Please generate matches first.');
  }
};

document.getElementById('downloadBtnTop').onclick = function() {
  if (currentData && currentMatches) {
    downloadResults(currentData, currentMatches);
    setTimeout(() => {
      generateUpdatedMasterList();
    }, 500);
  } else {
    alert('No matches to download. Please generate matches first.');
  }
};

document.getElementById('printBtn').onclick = function() {
  if (currentData && currentMatches) {
    printMatchSheet(currentData, currentMatches);
  } else {
    alert('No matches to print. Please generate matches first.');
  }
};

document.getElementById('fullScreenBtn').onclick = function() {
  openFullScreenDisplay();
};

// Export results as input files for future use
document.getElementById('exportInputBtn').onclick = function() {
  if (!currentData || !currentMatches) {
    alert('No matches to export. Please generate matches first.');
    return;
  }
  exportAsInputFiles();
};

function exportAsInputFiles() {
  try {
    const completedSets = Object.keys(allSetsData).sort((a, b) => parseInt(a) - parseInt(b));
    
    if (completedSets.length === 0) {
      alert('No completed sets to export.');
      return;
    }
    
    // Show initial message
    alert(`Preparing to export ${completedSets.length} input file(s). Files will download with a short delay between each.`);
    
    // Download files with delay
    completedSets.forEach((setNum, index) => {
      setTimeout(() => {
        const setData = allSetsData[setNum];
        createInputFileForSet(setNum, setData);
        
        // Show completion message after last file
        if (index === completedSets.length - 1) {
          setTimeout(() => {
            alert(`Export complete! ${completedSets.length} file(s) should now be in your Downloads folder.`);
          }, 500);
        }
      }, index * 1000); // 1 second delay between each file
    });
    
  } catch (error) {
    alert(`Error creating input files: ${error.message}`);
    console.error('Export error:', error);
  }
}

function createInputFileForSet(setNumber, setData) {
  const wb = XLSX.utils.book_new();
  
  // Create "Today's Players" sheet
  const playersData = [
    ['Men\'s Name', 'Men\'s Grade', 'Men\'s NHC', 'Men\'s NXD', 'Men\'s +/-', '', 
     'Women\'s Name', 'Women\'s Grade', 'Women\'s NHC', 'Women\'s NXD', 'Women\'s +/-']
  ];
  
  // Get all players who participated in this set
  const participatingMen = [];
  const participatingWomen = [];
  
  // Extract players from matches
  setData.matches.forEach(match => {
    [...match.team1, ...match.team2].forEach(player => {
      const playerData = findPlayerFullData(player.name, setData.data);
      if (playerData) {
        if (playerData.gender === 'M' && !participatingMen.some(p => p.name === player.name)) {
          participatingMen.push(playerData);
        } else if (playerData.gender === 'F' && !participatingWomen.some(p => p.name === player.name)) {
          participatingWomen.push(playerData);
        }
      }
    });
  });
  
  // Add sat-off players
  if (setData.satOffPlayers) {
    setData.satOffPlayers.forEach(playerName => {
      const playerData = findPlayerFullData(playerName, setData.data);
      if (playerData) {
        if (playerData.gender === 'M' && !participatingMen.some(p => p.name === playerName)) {
          participatingMen.push(playerData);
        } else if (playerData.gender === 'F' && !participatingWomen.some(p => p.name === playerName)) {
          participatingWomen.push(playerData);
        }
      }
    });
  }
  
  // Sort by grade (highest first)
  participatingMen.sort((a, b) => b.grade - a.grade);
  participatingWomen.sort((a, b) => b.grade - a.grade);
  
  // Build rows
  const maxRows = Math.max(participatingMen.length, participatingWomen.length);
  for (let i = 0; i < maxRows; i++) {
    const row = [];
    
   // Men's data
    if (i < participatingMen.length) {
      const player = participatingMen[i];
      row.push(player.name);
      row.push(translateGrade(player.grade));
      row.push(player.nhc ? 'y' : '');
      row.push('');  // NXD column empty
      row.push(player.plusMinus || '');
    } else {
      row.push('', '', '', '', '');
    }
    
    // Spacer
    row.push('');
    
   // Women's data
    if (i < participatingWomen.length) {
      const player = participatingWomen[i];
      row.push(player.name);
      row.push(translateGrade(player.grade));
      row.push(player.nhc ? 'y' : '');
      row.push('');  // NXD column empty
      row.push(player.plusMinus || '');
    } else {
      row.push('', '', '', '', '');
    }
    
    playersData.push(row);
  }
  
  const playersSheet = XLSX.utils.aoa_to_sheet(playersData);
  playersSheet['!cols'] = [
    { wch: 20 }, { wch: 10 }, { wch: 8 }, { wch: 8 }, { wch: 6 }, { wch: 3 },
    { wch: 20 }, { wch: 10 }, { wch: 8 }, { wch: 8 }, { wch: 6 }
  ];
  XLSX.utils.book_append_sheet(wb, playersSheet, "Today's Players");
  
  // Create "Available Courts" sheet
  const courtsData = [['Priority', 'Court']];
  
  // Use the courts from the set data
  if (setData.data && setData.data.courts) {
    setData.data.courts.forEach((court, index) => {
      courtsData.push([index + 1, court.court]);
    });
  } else if (availableCourts && availableCourts.length > 0) {
    // Fallback to current available courts
    availableCourts.forEach((court, index) => {
      courtsData.push([index + 1, court]);
    });
  }
  
  const courtsSheet = XLSX.utils.aoa_to_sheet(courtsData);
  courtsSheet['!cols'] = [{ wch: 10 }, { wch: 15 }];
  XLSX.utils.book_append_sheet(wb, courtsSheet, "Available Courts");
  
  // Generate filename
  const timestamp = new Date().toISOString().slice(0, 10);
  const filename = `Tennis_Set_${setNumber}_Input_${timestamp}.xlsx`;
  
  // Download the file
  XLSX.writeFile(wb, filename);
  
  console.log(`Exported input file for Set ${setNumber}: ${filename}`);
}

function findPlayerFullData(playerName, setData) {
  // Check in available men
  if (setData.availableMen) {
    const found = setData.availableMen.find(p => p.name === playerName);
    if (found) return { ...found, gender: 'M' };
  }
  
  // Check in available women
  if (setData.availableWomen) {
    const found = setData.availableWomen.find(p => p.name === playerName);
    if (found) return { ...found, gender: 'F' };
  }
  
  // Check in sorted lists
  if (setData.sortedMen) {
    const found = setData.sortedMen.find(p => p.name === playerName);
    if (found) return { ...found, gender: 'M' };
  }
  
  if (setData.sortedWomen) {
    const found = setData.sortedWomen.find(p => p.name === playerName);
    if (found) return { ...found, gender: 'F' };
  }
  
  // Fallback to playerRows
  const playerRow = playerRows.find(p => p.name === playerName);
  if (playerRow) return playerRow;
  
  return null;
}
// Excel import functionality
document.getElementById('importExcelBtn').addEventListener('click', () => {
  document.getElementById('excelFileInput').click();
});

document.getElementById('excelFileInput').addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  
  try {
    const arrayBuffer = await file.arrayBuffer();
    const workbook = XLSX.read(arrayBuffer, { type: 'array' });
    
    // Check if required sheets exist
    if (!workbook.SheetNames.includes("Today's Players")) {
      alert("Error: Excel file must contain a sheet named \"Today's Players\"");
      return;
    }
    if (!workbook.SheetNames.includes("Available Courts")) {
      alert("Error: Excel file must contain a sheet named \"Available Courts\"");
      return;
    }
    
    // Parse Today's Players sheet
    const playersSheet = workbook.Sheets["Today's Players"];
    const playersData = XLSX.utils.sheet_to_json(playersSheet, { header: 1 });
    
    // Parse Available Courts sheet
    const courtsSheet = workbook.Sheets["Available Courts"];
    const courtsData = XLSX.utils.sheet_to_json(courtsSheet, { header: 1 });
    
    // Process players data
    const importedPlayers = [];
    
    // Skip header row (index 0), process data rows
    for (let i = 1; i < playersData.length; i++) {
      const row = playersData[i];
      if (!row || row.length === 0) continue;
      
      // Men's data (columns A-E)
if (row[0] && typeof row[0] === 'string' && row[0].trim() !== '') {
  const menGrade = parseGrade(row[1]);
  if (menGrade !== null) {
    importedPlayers.push({
      name: row[0].trim(),
      grade: menGrade,
      gender: 'M',
      nhc: parseBoolean(row[2]),
     // NXD column (row[3]) ignored
      plusMinus: parsePlusMinus(row[4]),
      arrivalOrder: ++arrivalCounter,
      resting: false,
      pso: false,
      so: false
    });
  }
}
      
      // Women's data (columns G-K)
if (row[6] && typeof row[6] === 'string' && row[6].trim() !== '') {
  const womenGrade = parseGrade(row[7]);
  if (womenGrade !== null) {
    importedPlayers.push({
      name: row[6].trim(),
      grade: womenGrade,
      gender: 'F',
      nhc: parseBoolean(row[8]),
      // NXD column (row[9]) ignored
      plusMinus: parsePlusMinus(row[10]),
      arrivalOrder: ++arrivalCounter,
      resting: false,
      pso: false,
      so: false
    });
  }
}
    }
    
// Process courts data
const importedCourts = [];

console.log("Courts sheet data:", courtsData);

// Skip header row, process data rows
for (let i = 1; i < courtsData.length; i++) {
  const row = courtsData[i];
  console.log(`Row ${i}:`, row);
  
  if (!row || row.length < 2) {
    console.log(`Skipping row ${i} - insufficient data`);
    continue;
  }
  
  const priority = parseInt(row[0]);
  const courtName = row[1];
  
  console.log(`Row ${i}: priority=${priority}, courtName="${courtName}"`);
  
  const isValidPriority = !isNaN(priority) && priority > 0;
const isValidCourtName = courtName !== null && courtName !== undefined && courtName.toString().trim() !== '';

if (isValidPriority && isValidCourtName) {
    const courtToAdd = {
      priority: priority,
      court: courtName.toString().trim()
    };
    console.log(`Adding court:`, courtToAdd);
    importedCourts.push(courtToAdd);
  } else {
    console.log(`Skipping row ${i} - invalid data: priority=${priority}, courtName="${courtName}"`);
  }
}

console.log("Final imported courts:", importedCourts);
    
    // Sort courts by priority
    importedCourts.sort((a, b) => a.priority - b.priority);
    
    
    
    // Clear existing data
    playerRows = [];
    availableCourts = [];
    
    // Import players
    playerRows = [...importedPlayers];
    
// Restore PSO status from all previous sets for imported players
const currentSetNum = parseInt(document.getElementById('setNumberSelector').value);
for (let setNum = 1; setNum < currentSetNum; setNum++) {
  if (allSetsData[setNum] && allSetsData[setNum].satOffPlayers) {
    const previousSatOffPlayers = allSetsData[setNum].satOffPlayers;
    playerRows.forEach(player => {
      if (previousSatOffPlayers.includes(player.name)) {
        player.pso = true;
      }
    });
  }
}

 // Ensure we have at least 10 rows for manual additions
    while (playerRows.length < 10) {
  playerRows.push({
   name: '', grade: '', gender: '', nhc: false, plusMinus: '',
    resting: false, pso: false, so: false, arrivalOrder: null,
    unavailableSets: { set1: false, set2: false, set3: false, set4: false, set5: false, set6: false }
  });
}
    
    // Import courts
    availableCourts = importedCourts.map(c => c.court);
    
    // Refresh UI
    refreshPlayerTable();
    updateAvailableCourtsDisplay();

  // Refresh court pool and remove selected courts
initializeCourts();
availableCourts.forEach(court => {
  const courtElement = document.querySelector(`[data-court="${court}"]`);
  if (courtElement && courtElement.parentElement.id === 'courtPool') {
    courtElement.remove();
  }
});
    updateSitOffCalculation();
    updateProceedButton();
    
    // Show success message
// Show success message in the status area
document.getElementById('memberLoadStatus').innerHTML = 
  `<div class="success">‚úì Imported ${importedPlayers.length} players and ${importedCourts.length} courts from Excel file</div>`;
    
    // Auto-save the imported data
    saveDataToStorage();
    
  } catch (error) {
    alert(`Error reading Excel file: ${error.message}`);
    console.error('Excel import error:', error);
  }
  
  // Clear file input
  e.target.value = '';
});

// Helper function to parse grade values
function parseGrade(gradeValue) {
  if (!gradeValue) return null;
  return reverseTranslateGrade(gradeValue.toString().trim());
}

// Helper function to parse boolean values
function parseBoolean(value) {
  if (!value) return false;
  
  if (typeof value === 'boolean') return value;
  
  if (typeof value === 'string') {
    const str = value.toString().trim().toLowerCase();
    return str === 'y' || str === 'yes' || str === 'true' || str === '1';
  }
  
  if (typeof value === 'number') {
    return value === 1;
  }
  
  return false;
}

// Helper function to parse plus/minus values
function parsePlusMinus(value) {
  if (!value) return '';
  
  if (typeof value === 'string') {
    const str = value.toString().trim();
    if (str === '+' || str === '-') return str;
  }
  
  return '';
}

// Function to refresh the player table after import
function refreshPlayerTable() {
  const tbody = document.getElementById('playerTableBody');
  tbody.innerHTML = '';
  
  playerRows.forEach((player, index) => {
    addPlayerRowAtIndex(index);
    
    // Populate the row with imported data
    if (player.name) {
      document.querySelector(`[data-row="${index}"]`).value = player.name;
      document.getElementById(`grade-${index}`).value = player.grade;
      document.getElementById(`gender-${index}`).value = player.gender;
      document.getElementById(`nhc-${index}`).checked = player.nhc;
document.getElementById(`plusminus-${index}`).value = player.plusMinus || '';
      document.getElementById(`resting-${index}`).checked = player.resting;
      document.getElementById(`pso-${index}`).checked = player.pso;
      document.getElementById(`so-${index}`).checked = player.so;
      
     // Show delete button if player has complete data
      if (player.name && player.grade && player.gender) {
        document.querySelector(`[data-row="${index}"].delete-player-btn`).style.display = 'block';
      }
      
      // Restore unavailable sets display
      if (player.unavailableSets) {
        const selectedSets = [];
        for (let i = 1; i <= 6; i++) {
          if (player.unavailableSets[`set${i}`]) {
            selectedSets.push(i.toString());
          }
        }
        const hiddenInput = document.getElementById(`unavailable-${index}`);
        const button = document.getElementById(`sets-btn-${index}`);
        if (selectedSets.length === 0) {
          hiddenInput.value = '';
          button.textContent = 'None';
          button.classList.remove('has-selections');
        } else {
          hiddenInput.value = selectedSets.join(',');
          button.textContent = selectedSets.join(', ');
          button.classList.add('has-selections');
        }
      }
    }
  });
}

// Button-style selectors for format and set number
document.addEventListener('DOMContentLoaded', function() {

  // Format button handlers
document.querySelectorAll('.format-btn').forEach(btn => {
  btn.addEventListener('click', function() {
    // Remove active from all format buttons
    document.querySelectorAll('.format-btn').forEach(b => b.classList.remove('active'));
    // Add active to clicked button
    this.classList.add('active');
    // Update hidden select
    document.getElementById('formatSelector').value = this.dataset.format;
    // Trigger change event for compatibility
    document.getElementById('formatSelector').dispatchEvent(new Event('change'));
    // Check if matches have been generated and need updating
    checkForPlayerChangesAfterMatches();
  });
});

  // Set number button handlers
  document.querySelectorAll('.set-btn').forEach(btn => {
    btn.addEventListener('click', function() {
      // Remove active from all set buttons
      document.querySelectorAll('.set-btn').forEach(b => b.classList.remove('active'));
      // Add active to clicked button
      this.classList.add('active');
      // Update hidden select
      document.getElementById('setNumberSelector').value = this.dataset.set;
      // Trigger change event for compatibility
      document.getElementById('setNumberSelector').dispatchEvent(new Event('change'));
      autoRestPlayersForCurrentSet(); // Auto-rest unavailable players
    });
  });
});

let fullScreenDisplayWindow = null;

// ===== MAGNETIC STRIP DISPLAY =====
let stripDisplayWindow = null;

function openStripDisplay() {
  // Check if window already exists and is open
  if (stripDisplayWindow && !stripDisplayWindow.closed) {
    stripDisplayWindow.focus();
    return;
  }
  
 stripDisplayWindow = window.open('', 'StripDisplay', 'fullscreen=yes,scrollbars=no,menubar=no,toolbar=no,location=no,status=no');
  
  const stripHTML = `
<!DOCTYPE html>
<html>
<head>
  <title>Magnetic Strip Display</title>
 <style>
    body {
      font-family: Arial, sans-serif;
      padding: 10px;
      background: #f4f4f4;
      margin: 0;
      overflow: hidden;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }
    .header {
      background: linear-gradient(135deg, #1e40af 0%, #3b82f6 100%);
      color: white;
      padding: 12px;
      text-align: center;
      font-size: 24px;
      font-weight: bold;
      margin-bottom: 10px;
      border-radius: 8px;
      flex-shrink: 0;
    }
   .strips-container {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      padding: 10px;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      flex: 1;
      overflow: auto;
      align-content: flex-start;
    }
    /* Default styles for 60+ players (20 per column, 5 columns) */
.strip-column {
  flex: 0 0 auto;
  display: flex;
  flex-direction: column;
  gap: 3px;
  width: 272px;
  margin-right: 12px;
}
.player-strip {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 5px 0 5px 10px;
  background: white;
  border: 2px solid #333;
  border-right: none;
  border-radius: 4px 0 0 4px;
  font-size: 10px;
  width: 100%;
  height: 26px;
  box-sizing: border-box;
}
.player-strip.group-separator {
  margin-bottom: 11px;
}
.player-info {
  flex: 1;
  font-weight: bold;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  min-width: 0;
}
.strip-boxes {
  display: flex;
  flex-shrink: 0;
  border: 1px solid #333;
}
.strip-box {
  width: 21px;
  height: 21px;
  border-right: 1px solid #333;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 11px;
  font-weight: bold;
  background: white;
  flex-shrink: 0;
}
.strip-box:last-child {
  border-right: none;
}
.strip-box.unavailable {
  font-size: 34px;
  line-height: 1;
  font-weight: normal;
  color: black;
}

.strip-box:nth-child(3) {
  border-right: 3px solid #FF1493;
}

/* Spacious mode for 60 or fewer players (15 per column, 4 columns) */
.strips-container.spacious-mode .strip-column {
  width: 336px;
  margin-right: 16px;
  gap: 3px;
}
.strips-container.spacious-mode .player-strip {
  padding: 8px 0 8px 13px;
  font-size: 11px;
  height: 34px;
  gap: 10px;
}
.strips-container.spacious-mode .player-strip.group-separator {
  margin-bottom: 14px;
}
.strips-container.spacious-mode .strip-box {
  width: 27px;
  height: 27px;
  font-size: 14px;
}
.strips-container.spacious-mode .strip-box:last-child {
  border-right: none;
}
.strips-container.spacious-mode .strip-box.unavailable {
  font-size: 44px;
}

.strips-container.spacious-mode .strip-box:nth-child(3) {
  border-right: 4px solid #FF1493;
}
    
   
  </style>
</head>
<body>
  <div class="header">Magnetic Strip Display</div>
  <div id="stripsContainer" class="strips-container">
    <!-- Columns will be created dynamically -->
  </div>
  
  <script>
    // This window will receive updates from the parent window
  <\/script>
</body>
</html>
  `;
  
  stripDisplayWindow.document.write(stripHTML);
  stripDisplayWindow.document.close();
  
  // Initial update
  updateStripDisplay();
}

function updateStripDisplay() {
  console.log('updateStripDisplay called');
  if (!stripDisplayWindow || stripDisplayWindow.closed) {
    console.log('Strip window is closed or null');
    return;
  }
  console.log('Strip window is open, updating...');
  
  // Get all players with complete data, sorted by arrival order
  const completePlayers = playerRows
    .filter(p => p.name && p.grade !== '' && p.gender !== '')
    .sort((a, b) => (a.arrivalOrder || 0) - (b.arrivalOrder || 0));
  
  // Clear container
  const container = stripDisplayWindow.document.getElementById('stripsContainer');
  if (!container) return;
  container.innerHTML = '';
  
  // Dynamic sizing based on player count
const playerCount = completePlayers.length;
let playersPerColumn, maxColumns;

if (playerCount <= 60) {
  // Spacious mode: 15 per column, max 4 columns
  playersPerColumn = 15;
  maxColumns = 4;
  container.classList.add('spacious-mode');
} else {
  // Compact mode: 20 per column, max 5 columns
  playersPerColumn = 20;
  maxColumns = 5;
  container.classList.remove('spacious-mode');
}

const numColumns = Math.min(Math.ceil(playerCount / playersPerColumn), maxColumns);
  
  // Create columns dynamically
  const columns = [];
  for (let i = 0; i < numColumns; i++) {
    const column = stripDisplayWindow.document.createElement('div');
    column.className = 'strip-column';
    column.id = `column${i}`;
    container.appendChild(column);
    columns.push(column);
  }
  
  // Track strips per column for grouping
  const columnCounts = new Array(numColumns).fill(0);
  
  // Distribute players across columns
  completePlayers.forEach((player, index) => {
    const stripDiv = stripDisplayWindow.document.createElement('div');
  stripDiv.className = 'player-strip';
    
    // Color coding: visitors in green, females in blue
    if (player.name && player.name.endsWith(' (V)')) {
      stripDiv.style.color = 'green';
    } else if (player.gender === 'F') {
      stripDiv.style.color = '#2563eb';
    }
    
    // Player info
    const playerInfo = stripDisplayWindow.document.createElement('div');
    playerInfo.className = 'player-info';
    playerInfo.textContent = `${player.name} (${translateGrade(player.grade)})`;
    stripDiv.appendChild(playerInfo);
    
    // Set boxes
    const boxesDiv = stripDisplayWindow.document.createElement('div');
    boxesDiv.className = 'strip-boxes';
    
    for (let setNum = 1; setNum <= 6; setNum++) {
      const box = stripDisplayWindow.document.createElement('div');
      box.className = 'strip-box';
      
      // Check if player is unavailable for this set
      if (player.unavailableSets && player.unavailableSets[`set${setNum}`]) {
        box.textContent = '√ó';
        box.classList.add('unavailable');
      } else {
        box.textContent = '';
      }
      
      boxesDiv.appendChild(box);
    }
    
    stripDiv.appendChild(boxesDiv);
    
    // Determine which column to add to
    const columnIndex = Math.floor(index / playersPerColumn);
    if (columns[columnIndex]) {
      columnCounts[columnIndex]++;
      
      // Add group separator class every 5 strips
      if (columnCounts[columnIndex] % 5 === 0 && columnCounts[columnIndex] < playersPerColumn) {
        stripDiv.classList.add('group-separator');
      }
      
      columns[columnIndex].appendChild(stripDiv);
    }
  });
}

// Auto-rest players who are unavailable for the current set
function autoRestPlayersForCurrentSet() {
  const currentSet = parseInt(document.getElementById('setNumberSelector').value);
  
  playerRows.forEach((player, index) => {
    const restCheckbox = document.getElementById(`resting-${index}`);
    if (!restCheckbox) return;
    
    // Check if player has this set marked as unavailable
    if (player.unavailableSets && player.unavailableSets[`set${currentSet}`]) {
      // Auto-check the Rest checkbox
      if (!restCheckbox.checked) {
        restCheckbox.checked = true;
        playerRows[index].resting = true;
        playerRows[index].autoRested = true; // Track that this was auto-rested
        console.log(`Auto-resting ${player.name} for Set ${currentSet}`);
      }
    } else {
      // Player is available for this set
      // If they were auto-rested before, uncheck the Rest checkbox
      if (restCheckbox.checked && playerRows[index].autoRested) {
        restCheckbox.checked = false;
        playerRows[index].resting = false;
        playerRows[index].autoRested = false;
        console.log(`Auto-unresting ${player.name} for Set ${currentSet}`);
      }
    }
  });
  
  // Update UI elements that depend on resting status
  updateSitOffCalculation();
  updateProceedButton();
  saveDataToStorage();
}

// ===== SETS SELECTION MODAL =====
let currentSetsRow = null;

// Initialize modal event listeners after DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
  // Handle checkbox changes
  document.querySelectorAll('.set-checkbox-item').forEach(item => {
    item.addEventListener('click', function(e) {
      // Don't toggle if clicking the checkbox itself (it handles its own toggle)
      if (e.target.tagName !== 'INPUT') {
        const checkbox = this.querySelector('input[type="checkbox"]');
        checkbox.checked = !checkbox.checked;
      }
      updateCheckboxItemStyling();
    });
  });

  // Clear all button
  document.getElementById('setsClearBtn').addEventListener('click', function() {
    document.querySelectorAll('.sets-modal input[type="checkbox"]').forEach(cb => {
      cb.checked = false;
    });
    updateCheckboxItemStyling();
  });

  // Done button
  document.getElementById('setsDoneBtn').addEventListener('click', function() {
    saveSetsSelection();
    closeSetsModal();
  });

  // Close modal when clicking outside
  document.getElementById('setsModalOverlay').addEventListener('click', function(e) {
    if (e.target === this) {
      saveSetsSelection();
      closeSetsModal();
    }
  });
});

// Open sets modal when button is clicked
document.addEventListener('click', function(e) {
  if (e.target.classList.contains('sets-button')) {
    const rowIndex = e.target.dataset.row;
    currentSetsRow = rowIndex;
    
    // Get player name for the modal
    const nameInput = document.querySelector(`[data-row="${rowIndex}"]`);
    const playerName = nameInput ? nameInput.value || 'this player' : 'this player';
    
    document.getElementById('setsModalPlayerName').textContent = `Select Unavailable Sets for ${playerName}`;
    document.getElementById('setsModalPlayerNameInline').textContent = playerName;
    
    // Load current selections
    const hiddenInput = document.getElementById(`unavailable-${rowIndex}`);
    const currentSelections = hiddenInput.value ? hiddenInput.value.split(',') : [];
    
    // Clear all checkboxes first
    document.querySelectorAll('.sets-modal input[type="checkbox"]').forEach(cb => {
      cb.checked = false;
    });
    
    // Set current selections
    currentSelections.forEach(set => {
      const checkbox = document.getElementById(`modal-set-${set}`);
      if (checkbox) {
        checkbox.checked = true;
      }
    });
    
    // Update checkbox item styling
    updateCheckboxItemStyling();
    
    // Show modal
    document.getElementById('setsModalOverlay').classList.add('active');
  }
});

// Update checkbox item styling based on checked state
function updateCheckboxItemStyling() {
  document.querySelectorAll('.set-checkbox-item').forEach(item => {
    const checkbox = item.querySelector('input[type="checkbox"]');
    if (checkbox.checked) {
      item.classList.add('checked');
    } else {
      item.classList.remove('checked');
    }
  });
}

// Save the sets selection
function saveSetsSelection() {
  if (currentSetsRow === null) return;
  
  const selectedSets = [];
  document.querySelectorAll('.sets-modal input[type="checkbox"]:checked').forEach(cb => {
    selectedSets.push(cb.value);
  });
  
  // Update hidden input
  const hiddenInput = document.getElementById(`unavailable-${currentSetsRow}`);
  hiddenInput.value = selectedSets.join(',');
  
  // Update button text
  const button = document.getElementById(`sets-btn-${currentSetsRow}`);
  if (selectedSets.length === 0) {
    button.textContent = 'None';
    button.classList.remove('has-selections');
  } else {
   button.textContent = selectedSets.join(', ');
    button.classList.add('has-selections');
  }
  
  // Update playerRows data structure
  if (playerRows[currentSetsRow]) {
    playerRows[currentSetsRow].unavailableSets = {};
    selectedSets.forEach(set => {
      playerRows[currentSetsRow].unavailableSets[`set${set}`] = true;
    });
  }
  
 // Update strip display if open
  if (stripDisplayWindow && !stripDisplayWindow.closed) {
    updateStripDisplay();
  }
  
  // Auto-rest player if they're unavailable for the current set
  autoRestPlayersForCurrentSet();
  
  // Notify check-in server of unavailable sets change
  if (checkinServerConnected && playerRows[currentSetsRow]) {
    notifyServerPlayerUpdated(playerRows[currentSetsRow]);
  }
}

// Close the modal
function closeSetsModal() {
  document.getElementById('setsModalOverlay').classList.remove('active');
  currentSetsRow = null;
}

// ===== CHECK-IN SERVER INTEGRATION =====

let checkinWebSocket = null;
let checkinServerConnected = false;
let checkinServerUrl = 'ws://localhost:3000';

// Try to auto-connect to check-in server (silent, no prompts)
function tryAutoConnect() {
  try {
    const ws = new WebSocket('ws://localhost:3000');
    
    ws.onopen = () => {
      console.log('Auto-connected to check-in server');
      checkinWebSocket = ws;
      checkinServerConnected = true;
      updateCheckinStatus(true);
      
      ws.send(JSON.stringify({
        type: 'register',
        clientType: 'main'
      }));
      
      sendMemberListToServer();
      
      ws.onmessage = (event) => {
        const data = JSON.parse(event.data);
        handleCheckinMessage(data);
      };
      
      ws.onclose = () => {
        checkinServerConnected = false;
        updateCheckinStatus(false);
      };
    };
    
    ws.onerror = () => {
      // Silent fail - server probably not running
      console.log('Check-in server not available (OK)');
    };
  } catch (e) {
    // Silent fail
  }
}

function promptForCheckinServer() {
  let defaultUrl = 'ws://localhost:3000';
  
  const url = prompt(
    'Enter the check-in server address:\n\n' +
    'If running on this computer: ws://localhost:3000\n' +
    'If running on another computer: ws://[IP]:3000\n\n' +
    '(The server will display the correct address when started)',
    defaultUrl
  );
  
  if (url) {
    connectToCheckinServer(url);
  }
}

function connectToCheckinServer(url) {
  if (checkinWebSocket) {
    checkinWebSocket.close();
  }
  
  checkinServerUrl = url;
  
  try {
    checkinWebSocket = new WebSocket(url);
    
    checkinWebSocket.onopen = () => {
      console.log('Connected to check-in server');
      checkinServerConnected = true;
      updateCheckinStatus(true);
      
      checkinWebSocket.send(JSON.stringify({
        type: 'register',
        clientType: 'main'
      }));
      
      sendMemberListToServer();
      
      checkinWebSocket.send(JSON.stringify({
        type: 'syncArrivalCounter',
        counter: arrivalCounter
      }));
    };
    
    checkinWebSocket.onmessage = (event) => {
      const data = JSON.parse(event.data);
      handleCheckinMessage(data);
    };
    
    checkinWebSocket.onclose = () => {
      console.log('Disconnected from check-in server');
      checkinServerConnected = false;
      updateCheckinStatus(false);
      
      setTimeout(() => {
        if (!checkinServerConnected && checkinServerUrl) {
          console.log('Attempting to reconnect to check-in server...');
          connectToCheckinServer(checkinServerUrl);
        }
      }, 5000);
    };
    
    checkinWebSocket.onerror = (error) => {
      console.error('Check-in server error:', error);
      alert('Could not connect to check-in server. Make sure the server is running.');
    };
    
  } catch (error) {
    console.error('Failed to connect:', error);
    alert('Invalid server address or connection failed.');
  }
}

function updateCheckinStatus(connected) {
  const statusEl = document.getElementById('checkinStatus');
  const btnEl = document.getElementById('connectCheckinBtn');
  
  if (statusEl) {
    statusEl.style.display = 'inline-flex';
    statusEl.className = `checkin-status ${connected ? 'connected' : 'disconnected'}`;
    statusEl.querySelector('.text').textContent = connected ? 'Check-in Connected' : 'Disconnected';
  }
  
  if (btnEl) {
    btnEl.textContent = connected ? 'üì± Reconnect Check-in' : 'üì± iPad Check-in';
    btnEl.style.background = connected ? '#4caf50' : '#9c27b0';
  }
}

function sendMemberListToServer() {
  if (!checkinWebSocket || checkinWebSocket.readyState !== WebSocket.OPEN) return;
  
  checkinWebSocket.send(JSON.stringify({
    type: 'memberList',
    members: masterListData.map(m => ({
      name: m.name,
      grade: m.grade,
      gender: m.gender,
      nhc: m.nhc,
      plusMinus: m.plusMinus
    }))
  }));
  
  console.log(`Sent ${masterListData.length} members to check-in server`);
}

function handleCheckinMessage(data) {
  switch(data.type) {
    case 'sync':
      console.log(`Syncing ${data.players.length} checked-in players`);
      
      if (data.arrivalCounter > arrivalCounter) {
        arrivalCounter = data.arrivalCounter;
      }
      
      data.players.forEach(player => {
        addCheckedInPlayer(player, false);
      });
      
      saveDataToStorage();
      break;
      
    case 'playerCheckedIn':
      console.log(`Check-in received: ${data.player.name}`);
      addCheckedInPlayer(data.player, true);
      showCheckinNotification(data.player.name);
      break;
      
    case 'playerRemoved':
      console.log(`Player removed: ${data.name}`);
      removeCheckedInPlayer(data.name);
      break;
      
    case 'playerUpdated':
      console.log(`Player updated: ${data.player.name}`);
      updateCheckedInPlayer(data.player);
      break;
  }
}

function addCheckedInPlayer(player, doSave = true) {
  const existingIndex = playerRows.findIndex(p => p.name === player.name);
  if (existingIndex !== -1) {
    console.log(`Player ${player.name} already in list, skipping`);
    return;
  }
  
  let targetIndex = playerRows.findIndex(p => !p.name || p.name.trim() === '');
  
  if (targetIndex === -1) {
    targetIndex = playerRows.length;
    playerRows.push({
      name: '',
      grade: '',
      gender: '',
      nhc: false,
      plusMinus: '',
      resting: false,
      pso: false,
      so: false,
      arrivalOrder: null,
      unavailableSets: { set1: false, set2: false, set3: false, set4: false, set5: false, set6: false }
    });
  }
  
  if (player.arrivalOrder && player.arrivalOrder > arrivalCounter) {
    arrivalCounter = player.arrivalOrder;
  }
  
  playerRows[targetIndex] = {
    name: player.name,
    grade: player.grade,
    gender: player.gender,
    nhc: player.nhc || false,
    plusMinus: player.plusMinus || '',
    resting: false,
    pso: false,
    so: false,
    arrivalOrder: ++arrivalCounter,
    unavailableSets: player.unavailableSets || { set1: false, set2: false, set3: false, set4: false, set5: false, set6: false }
  };
  
  refreshPlayerTable();
  updateSitOffCalculation();
  updateProceedButton();
  setTimeout(() => updateStripDisplay(), 100);
  autoRestPlayersForCurrentSet();
  
  if (doSave) {
    saveDataToStorage();
  }
  
  console.log(`Added player ${player.name} at row ${targetIndex}, arrival order ${playerRows[targetIndex].arrivalOrder}`);
}

function removeCheckedInPlayer(name) {
  const index = playerRows.findIndex(p => p.name === name);
  if (index === -1) return;
  
  playerRows[index] = {
    name: '',
    grade: '',
    gender: '',
    nhc: false,
    plusMinus: '',
    resting: false,
    pso: false,
    so: false,
    arrivalOrder: null,
    unavailableSets: { set1: false, set2: false, set3: false, set4: false, set5: false, set6: false }
  };
  
  refreshPlayerTable();
  updateSitOffCalculation();
  updateProceedButton();
  setTimeout(() => updateStripDisplay(), 100);
  saveDataToStorage();
}

function updateCheckedInPlayer(player) {
  const index = playerRows.findIndex(p => p.name === player.name);
  if (index === -1) return;
  
  playerRows[index] = {
    ...playerRows[index],
    unavailableSets: player.unavailableSets || playerRows[index].unavailableSets
  };
  
  refreshPlayerTable();
  autoRestPlayersForCurrentSet();
  setTimeout(() => updateStripDisplay(), 100);
  saveDataToStorage();
}

function showCheckinNotification(playerName) {
  const notification = document.createElement('div');
  notification.style.cssText = `
    position: fixed;
    top: 20px;
    right: 20px;
    background: linear-gradient(135deg, #4caf50 0%, #2e7d32 100%);
    color: white;
    padding: 16px 24px;
    border-radius: 12px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    z-index: 10000;
    font-size: 16px;
    font-weight: 600;
    animation: slideIn 0.3s ease-out;
  `;
  notification.innerHTML = `‚úì <strong>${playerName}</strong> checked in`;
  
  if (!document.getElementById('checkin-animations')) {
    const style = document.createElement('style');
    style.id = 'checkin-animations';
    style.textContent = `
      @keyframes slideIn {
        from { transform: translateX(100%); opacity: 0; }
        to { transform: translateX(0); opacity: 1; }
      }
    `;
    document.head.appendChild(style);
  }
  
  document.body.appendChild(notification);
  
  setTimeout(() => {
    notification.style.transition = 'opacity 0.5s, transform 0.5s';
    notification.style.opacity = '0';
    notification.style.transform = 'translateX(100%)';
    setTimeout(() => notification.remove(), 500);
  }, 3000);
}

function notifyServerPlayerRemoved(playerName) {
  if (!checkinWebSocket || checkinWebSocket.readyState !== WebSocket.OPEN) return;
  
  checkinWebSocket.send(JSON.stringify({
    type: 'removePlayer',
    name: playerName
  }));
}

function notifyServerPlayerUpdated(player) {
  if (!checkinWebSocket || checkinWebSocket.readyState !== WebSocket.OPEN) return;
  
  checkinWebSocket.send(JSON.stringify({
    type: 'updatePlayer',
    player: {
      name: player.name,
      unavailableSets: player.unavailableSets
    }
  }));
}

// Add event listener for check-in button
document.getElementById('connectCheckinBtn').addEventListener('click', promptForCheckinServer);

// ===== END CHECK-IN SERVER INTEGRATION =====


</script>
<!-- === REGEN MODAL HTML START === -->
<div id="regenModalOverlay">
  <div id="regenModal">
    <div id="regenModalHeader">
     <h3>You are generating matches for set <span id="regenSetNumber"></span> again</h3>
    </div>
    <div id="regenModalBody">

      <p style="font-size: 12px; color: #666; margin-top: 10px;">
        Choose one of the options below.
      </p>
    </div>
   <div id="regenModalButtons">
  <button id="regenRerunBtn" class="regen-btn regen-rerun">Re-run set <span id="regenSetNumberBtn"></span></button>
      <button id="regenCancelBtn" class="regen-btn regen-cancel">Cancel and choose a new set</button>
    </div>
  </div>
</div>
<!-- === REGEN MODAL HTML END === -->

<!-- === SETS SELECTION MODAL HTML START === -->
<div class="sets-modal-overlay" id="setsModalOverlay">
  <div class="sets-modal">
    <div class="sets-modal-header">
      <span id="setsModalPlayerName">Select Unavailable Sets</span>
    </div>
    <div class="sets-modal-body">
      <div class="sets-modal-instructions">
        Select the sets that <strong id="setsModalPlayerNameInline"></strong> is <strong>NOT available</strong> to play:
      </div>
      <div class="sets-checkbox-grid">
        <div class="set-checkbox-item" data-set="1">
          <input type="checkbox" id="modal-set-1" value="1">
          <label for="modal-set-1">Set 1</label>
        </div>
        <div class="set-checkbox-item" data-set="2">
          <input type="checkbox" id="modal-set-2" value="2">
          <label for="modal-set-2">Set 2</label>
        </div>
        <div class="set-checkbox-item" data-set="3">
          <input type="checkbox" id="modal-set-3" value="3">
          <label for="modal-set-3">Set 3</label>
        </div>
        <div class="set-checkbox-item" data-set="4">
          <input type="checkbox" id="modal-set-4" value="4">
          <label for="modal-set-4">Set 4</label>
        </div>
        <div class="set-checkbox-item" data-set="5">
          <input type="checkbox" id="modal-set-5" value="5">
          <label for="modal-set-5">Set 5</label>
        </div>
        <div class="set-checkbox-item" data-set="6">
          <input type="checkbox" id="modal-set-6" value="6">
          <label for="modal-set-6">Set 6</label>
        </div>
      </div>
    </div>
    <div class="sets-modal-footer">
      <button class="sets-modal-btn secondary" id="setsClearBtn">Clear All</button>
      <button class="sets-modal-btn primary" id="setsDoneBtn">Done</button>
    </div>
  </div>
</div>
<!-- === SETS SELECTION MODAL HTML END === -->


</body>
</html>
        